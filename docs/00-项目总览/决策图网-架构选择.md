# 决策图网：缓存架构选择路径

## 主决策流程图

```mermaid
graph TD
    Start[开始缓存设计] --> Q1{数据规模?}

    Q1 -->|单机GB级| Q2{并发量?}
    Q1 -->|分布式TB级| Q3{一致性要求?}

    Q2 -->|<10万QPS| RedisSingle[Redis单机]
    Q2 -->|>10万QPS| Q4{读写比例?}

    Q4 -->|读>>写| Sentinel[Redis Sentinel]
    Q4 -->|读写均衡| Cluster[Redis Cluster]

    Q3 -->|强一致| CPSystem[CP系统: etcd/ZK + Cache]
    Q3 -->|最终一致| CAPSystem[AP系统: Redis Cluster]

    RedisSingle --> Q5{持久化?}
    Sentinel --> Q6{分片策略?}
    Cluster --> Q7{客户端路由?}

    Q5 -->|需要| RDB_AOF[RDB + AOF混合]
    Q5 -->|高速| NoPersis[禁用持久化]

    Q6 -->|范围分片| PredSharded[预分片]
    Q6 -->|哈希分片| HashSharded[一致性哈希]

    Q7 -->|智能客户端| SmartClient[JedisCluster]
    Q7 -->|代理层| Proxy[Codis/Redis Cluster Proxy]

    Q8{缓存问题?} -->|穿透| BloomFilter[布隆过滤器]
    Q8 -->|雪崩| RandomTTL[随机TTL + 熔断]
    Q8 -->|击穿| Mutex[互斥锁/分布式锁]
    Q8 -->|热点| LocalCache[本地缓存 + 分片]

    style RedisSingle fill:#90EE90
    style Sentinel fill:#87CEEB
    style Cluster fill:#DDA0DD
    style CPSystem fill:#FFB6C1
```

## 行业场景决策树

```mermaid
graph TD
    Industry{行业类型?}

    Industry -->|电商| Ecom[电商场景]
    Industry -->|金融| Finance[金融场景]
    Industry -->|社交| Social[社交场景]
    Industry -->|游戏| Game[游戏场景]

    Ecom --> E1{秒杀场景?}
    E1 -->|是| E2[Redis Cluster<br/>分段锁 + Pipeline]
    E1 -->|否| E3[Redis Sentinel<br/>Cache-Aside]

    Finance --> F1{支付场景?}
    F1 -->|是| F2[Redis Sentinel + XA<br/>Write-Through + AOF always]
    F1 -->|否| F3[Redis Cluster<br/>Read-Through]

    Social --> S1{Feed流?}
    S1 -->|是| S2[Redis Cluster + Graph<br/>推拉结合模型]
    S1 -->|否| S3[Redis Sentinel<br/>Cache-Aside]

    Game --> G1{状态同步?}
    G1 -->|是| G2[Redis Cluster + JSON<br/>Pub/Sub + AOI]
    G1 -->|否| G3[Redis Sentinel<br/>Cache-Aside]

    style E2 fill:#90EE90
    style F2 fill:#FFB6C1
    style S2 fill:#87CEEB
    style G2 fill:#DDA0DD
```

## 性能优化决策路径

```mermaid
graph LR
    Problem{性能瓶颈?}

    Problem -->|延迟高| Latency[延迟优化]
    Problem -->|吞吐低| Throughput[吞吐优化]
    Problem -->|内存满| Memory[内存优化]

    Latency --> L1{网络延迟?}
    L1 -->|是| L2[Pipeline + 连接池]
    L1 -->|否| L3{Redis延迟?}
    L3 -->|是| L4[多IO线程 + io_uring]
    L3 -->|否| L5[NUMA绑定 + HugePages]

    Throughput --> T1{QPS限制?}
    T1 -->|单机| T2[Cluster分片]
    T1 -->|网络| T3[Pipeline批量]
    T1 -->|CPU| T4[多IO线程]

    Memory --> M1{内存碎片?}
    M1 -->|是| M2[内存整理 + 重启]
    M1 -->|否| M3{编码优化?}
    M3 -->|是| M4[ziplist + intset]
    M3 -->|否| M5[冷热分离 + Pika]

    style L2 fill:#90EE90
    style T2 fill:#87CEEB
    style M4 fill:#DDA0DD
```

## 持久化策略决策

```mermaid
graph TD
    Persist{需要持久化?}

    Persist -->|否| NoPersist[禁用持久化<br/>纯内存缓存]
    Persist -->|是| DataLoss{数据丢失容忍度?}

    DataLoss -->|可容忍分钟级| RDB[RDB快照<br/>save 900 1]
    DataLoss -->|可容忍秒级| AOF_SEC[AOF everysec<br/>平衡方案]
    DataLoss -->|零容忍| AOF_ALWAYS[AOF always<br/>强一致]

    AOF_SEC --> Mix{恢复速度要求?}
    Mix -->|快速恢复| Hybrid[混合持久化<br/>RDB + AOF]
    Mix -->|标准恢复| AOF_SEC

    RDB --> RDB_OPT[优化: 低峰期保存<br/>避免fork阻塞]
    AOF_ALWAYS --> AOF_OPT[优化: SSD + 异步线程<br/>降低延迟]
    Hybrid --> HYB_OPT[优化: 定期重写<br/>控制文件大小]

    style NoPersist fill:#90EE90
    style Hybrid fill:#87CEEB
    style AOF_ALWAYS fill:#FFB6C1
```

## 高可用架构决策

```mermaid
graph TD
    HA{需要高可用?}

    HA -->|否| Single[单机部署<br/>开发测试]
    HA -->|是| Scale{数据规模?}

    Scale -->|<10GB| MasterSlave[主从复制<br/>简单高可用]
    Scale -->|10-100GB| Sentinel[Sentinel哨兵<br/>自动故障转移]
    Scale -->|>100GB| Cluster[Cluster集群<br/>分片+高可用]

    MasterSlave --> MS_OPT[优化: 读写分离<br/>提升读性能]
    Sentinel --> SEN_OPT[优化: 3节点最小配置<br/>满足过半原则]
    Cluster --> CLU_OPT[优化: 16384槽位<br/>一致性哈希]

    CLU_OPT --> CLU_ROUTE{客户端路由?}
    CLU_ROUTE -->|智能客户端| Smart[JedisCluster<br/>自动路由]
    CLU_ROUTE -->|代理层| Proxy[Codis/Twemproxy<br/>透明代理]

    style Single fill:#90EE90
    style Sentinel fill:#87CEEB
    style Cluster fill:#DDA0DD
```

## 缓存模式选择决策

```mermaid
graph TD
    Pattern{缓存模式选择}

    Pattern --> Read{读操作特征?}
    Read -->|读多写少| CA[Cache-Aside<br/>旁路缓存]
    Read -->|读多写多| RT[Read-Through<br/>透读缓存]

    Pattern --> Write{写操作特征?}
    Write -->|写多读少| WA[Write-Around<br/>绕写缓存]
    Write -->|写多读多| WT[Write-Through<br/>透写缓存]
    Write -->|异步写入| WB[Write-Behind<br/>异步写缓存]

    Pattern --> Predict{可预测访问?}
    Predict -->|是| RA[Refresh-Ahead<br/>预刷新缓存]

    CA --> CA_SCENE[适用: 常规业务<br/>最终一致性]
    RT --> RT_SCENE[适用: 缓存即服务<br/>封装读逻辑]
    WT --> WT_SCENE[适用: 金融支付<br/>强一致性]
    WB --> WB_SCENE[适用: 写入密集型<br/>高性能写入]
    WA --> WA_SCENE[适用: 日志写入<br/>避免污染]
    RA --> RA_SCENE[适用: 热点数据<br/>预测性加载]

    style CA fill:#90EE90
    style WT fill:#FFB6C1
    style WB fill:#87CEEB
```

## 决策检查清单

### 架构选择检查清单

- [ ] **数据规模** < 10GB → Redis单机
- [ ] **QPS** > 10万 → Redis Cluster
- [ ] **强一致性** → Write-Through + AOF_ALWAYS
- [ ] **高可用** → 3 Sentinel + 3副本
- [ ] **大Key** > 10KB → 拆分或存储到HBase
- [ ] **热Key** → 本地缓存 + 一致性哈希
- [ ] **内存碎片** > 50% → 重启或内存整理

### 性能优化检查清单

- [ ] **延迟P99** > 100ms → Pipeline + 连接池
- [ ] **吞吐量** < 目标 → Cluster分片或多IO线程
- [ ] **内存使用率** > 80% → 编码优化或冷热分离
- [ ] **CPU使用率** > 80% → 多IO线程或io_uring

### 问题排查检查清单

- [ ] **缓存穿透** → 布隆过滤器 + 空值缓存
- [ ] **缓存雪崩** → 随机TTL + 熔断降级
- [ ] **缓存击穿** → 互斥锁 + 异步重建
- [ ] **热点Key** → 本地缓存 + Key分片
