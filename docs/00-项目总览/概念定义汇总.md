# 概念定义汇总

## 目录

- [概念定义汇总](#概念定义汇总)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 算法概念定义](#2-算法概念定义)
    - [2.1 LRU（Least Recently Used）](#21-lruleast-recently-used)
    - [2.2 LFU（Least Frequently Used）](#22-lfuleast-frequently-used)
    - [2.3 ARC（Adaptive Replacement Cache）](#23-arcadaptive-replacement-cache)
    - [2.4 Clock（时钟扫描算法）](#24-clock时钟扫描算法)
    - [2.5 FIFO（First In First Out）](#25-fifofirst-in-first-out)
    - [2.6 MRU（Most Recently Used）](#26-mrumost-recently-used)
    - [2.7 Random（随机替换）](#27-random随机替换)
    - [2.8 LRU-K](#28-lru-k)
    - [2.9 W-TinyLFU](#29-w-tinylfu)
    - [2.10 一致性哈希（Consistent Hashing）](#210-一致性哈希consistent-hashing)
    - [2.11 Jump Hash](#211-jump-hash)
    - [2.12 Maglev Hash](#212-maglev-hash)
    - [2.13 Rendezvous Hash](#213-rendezvous-hash)
  - [3. 数据结构概念定义](#3-数据结构概念定义)
    - [3.1 SDS（Simple Dynamic String）](#31-sdssimple-dynamic-string)
    - [3.2 dict（哈希表）](#32-dict哈希表)
    - [3.3 quicklist（快速列表）](#33-quicklist快速列表)
    - [3.4 skiplist（跳表）](#34-skiplist跳表)
    - [3.5 intset（整数集合）](#35-intset整数集合)
    - [3.6 ziplist（压缩列表）](#36-ziplist压缩列表)
    - [3.7 HyperLogLog（基数统计）](#37-hyperloglog基数统计)
    - [3.8 Stream（流数据结构）](#38-stream流数据结构)
    - [3.9 RedisJSON](#39-redisjson)
    - [3.10 RedisGraph](#310-redisgraph)
    - [3.11 RedisTimeSeries](#311-redistimeseries)
  - [4. 系统概念定义](#4-系统概念定义)
    - [4.1 缓存（Cache）](#41-缓存cache)
    - [4.2 持久化（Persistence）](#42-持久化persistence)
    - [4.3 复制（Replication）](#43-复制replication)
    - [4.4 高可用（High Availability）](#44-高可用high-availability)
    - [4.5 CPU缓存（CPU Cache）](#45-cpu缓存cpu-cache)
    - [4.6 NUMA（Non-Uniform Memory Access）](#46-numanon-uniform-memory-access)
    - [4.7 Page Cache（页面缓存）](#47-page-cache页面缓存)
    - [4.8 内存管理（Memory Management）](#48-内存管理memory-management)
  - [5. 架构概念定义](#5-架构概念定义)
    - [5.1 Cache-Aside（旁路缓存）](#51-cache-aside旁路缓存)
    - [5.2 Read-Through（透读缓存）](#52-read-through透读缓存)
    - [5.3 Write-Through（透写缓存）](#53-write-through透写缓存)
    - [5.4 Write-Behind（异步写缓存）](#54-write-behind异步写缓存)
    - [5.5 多级缓存（Multi-Level Cache）](#55-多级缓存multi-level-cache)
  - [6. 性能概念定义](#6-性能概念定义)
    - [6.1 延迟（Latency）](#61-延迟latency)
    - [6.2 吞吐量（Throughput）](#62-吞吐量throughput)
    - [6.3 命中率（Hit Rate）](#63-命中率hit-rate)
    - [6.4 抖动（Jitter）](#64-抖动jitter)
    - [6.5 QPS（Queries Per Second）](#65-qpsqueries-per-second)
    - [6.6 P99延迟（P99 Latency）](#66-p99延迟p99-latency)
  - [7. 一致性概念定义](#7-一致性概念定义)
    - [7.1 强一致性（Strong Consistency）](#71-强一致性strong-consistency)
    - [7.2 最终一致性（Eventual Consistency）](#72-最终一致性eventual-consistency)
    - [7.3 CAP定理（CAP Theorem）](#73-cap定理cap-theorem)
    - [7.4 ACID（原子性、一致性、隔离性、持久性）](#74-acid原子性一致性隔离性持久性)
    - [7.5 BASE（基本可用、软状态、最终一致性）](#75-base基本可用软状态最终一致性)
  - [8. 参考文档](#8-参考文档)

---

## 1. 概述

本文档汇总BufferCache项目中所有核心概念的统一定义，包括算法、数据结构、系统、架构、性能和一致性等六大类概念。

**文档目标**：

- 为每个概念提供清晰、准确的定义
- 统一概念术语和表述
- 建立概念之间的关联关系
- 提供形式化定义（如适用）

**概念分类**：

1. **算法概念**：缓存替换算法、分布式算法等
2. **数据结构概念**：Redis数据结构、系统数据结构等
3. **系统概念**：缓存、持久化、复制、高可用等
4. **架构概念**：缓存架构模式、系统架构等
5. **性能概念**：延迟、吞吐量、命中率等
6. **一致性概念**：强一致性、最终一致性、CAP定理等

---

## 2. 算法概念定义

### 2.1 LRU（Least Recently Used）

**基本信息**：

- **英文名称**：Least Recently Used
- **缩写**：LRU
- **分类**：算法概念 - 缓存替换算法
- **首次提出**：1968年，Peter J. Denning
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
LRU是一种缓存替换算法，当缓存空间不足时，淘汰最近最少使用的数据项。LRU基于"时间局部性"原理，认为最近访问的数据在未来更可能被访问。

**形式化定义**：

设缓存容量为$C$，数据项集合为$U = \{u_1, u_2, ..., u_n\}$，访问序列为$\sigma = (r_1, r_2, ..., r_m)$，其中$r_i \in U$表示第$i$次访问的数据项。

LRU算法维护一个访问时间戳映射：
$$T: U \times \mathbb{N} \rightarrow \mathbb{R}^+$$

对于访问操作$access(r_i)$：

- 如果$r_i \in Cache$：更新$T(r_i) = t_i$（$t_i$为当前时间）
- 如果$r_i \notin Cache$且$|Cache| < C$：添加$r_i$，设置$T(r_i) = t_i$
- 如果$r_i \notin Cache$且$|Cache| = C$：淘汰$\arg\min_{s \in Cache} T(s)$，然后添加$r_i$

**关键属性**：

- **时间复杂度**：$O(1)$（使用哈希表+双向链表）
- **空间复杂度**：$O(C)$（$C$为缓存容量）
- **适用场景**：时间局部性强的访问模式
- **竞争比**：$k$（$k$为缓存大小）
- **命中率**：在时间局部性强的场景下，命中率通常为70-90%

**关系**：

- **继承关系**：
  - 继承自：缓存替换算法
  - 扩展为：LRU-K、近似LRU
- **组合关系**：
  - 是ARC算法的组成部分（T1列表）
- **依赖关系**：
  - 依赖于：时间局部性原理
- **替代关系**：
  - 可替代：FIFO、Random
  - 可被以下算法替代：LFU（频率局部性场景）、ARC（自适应场景）

**应用案例**：

**案例1**：Redis近似LRU

- **场景**：Redis内存淘汰策略
- **应用方式**：Redis使用近似LRU算法，采样24个key，选择最久未访问的淘汰
- **效果**：命中率85-90%，延迟<1μs，内存开销24bit/key
- **参考**：[近似LRU算法](../05-全栈分析/05.05-算法层实现/05.05.01-近似LRU算法.md)

**案例2**：操作系统页面置换

- **场景**：虚拟内存页面置换
- **应用方式**：使用LRU算法选择被置换的页面
- **效果**：减少页面错误率，提升系统性能
- **参考**：[LRU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)

**参考文档**：

- [LRU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [算法实现的数学证明](../01-理论基础/01.05-算法对比与决策/01.05.05-算法实现的数学证明.md)
- [形式化分析理论模型](./形式化分析理论模型.md)

---

### 2.2 LFU（Least Frequently Used）

**基本信息**：

- **英文名称**：Least Frequently Used
- **缩写**：LFU
- **分类**：算法概念 - 缓存替换算法
- **首次提出**：1970年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
LFU是一种基于"频率局部性"原理的缓存替换算法，当缓存空间不足时，淘汰访问频率最低的数据项。LFU认为访问频率高的数据在未来更可能被访问。

**形式化定义**：

设缓存容量为$C$，数据项集合为$U = \{u_1, u_2, ..., u_n\}$，访问序列为$\sigma = (r_1, r_2, ..., r_m)$。

对于每个数据项$u_i$，维护频率计数器$f_i \in \mathbb{N}$：

- 初始时：$f_i = 0$（所有数据项）
- 访问$r_j = u_i$时：$f_i = f_i + 1$

对于访问操作$access(r_i)$：

- 如果$r_i \in Cache$：增加$f_{r_i}$，保持缓存不变
- 如果$r_i \notin Cache$且$|Cache| < C$：将$r_i$加入缓存，$f_{r_i} = 1$
- 如果$r_i \notin Cache$且$|Cache| = C$：淘汰$\arg\min_{s \in Cache} f_s$，然后加入$r_i$

**关键属性**：

- **时间复杂度**：$O(\log C)$（使用最小堆）或$O(1)$（使用频率桶）
- **空间复杂度**：$O(C)$
- **适用场景**：频率局部性强的访问模式（如CDN、热门内容）
- **最优性**：在独立引用模型（IRM）下，LFU是最优的离线算法
- **命中率**：在频率分布不均匀的场景下，命中率通常为80-95%

**关系**：

- **继承关系**：
  - 继承自：缓存替换算法
  - 扩展为：W-TinyLFU
- **组合关系**：
  - 是ARC算法的组成部分（T2列表）
- **依赖关系**：
  - 依赖于：频率局部性原理
- **替代关系**：
  - 可替代：LRU（频率局部性场景）
  - 可被以下算法替代：LRU（时间局部性场景）、ARC（自适应场景）

**应用案例**：

**案例1**：Redis LFU淘汰策略

- **场景**：Redis 4.0引入LFU淘汰策略
- **应用方式**：使用24bit LFU字段，结合频率计数器和衰减机制
- **效果**：在热点数据场景下，命中率比LRU高5-10%
- **参考**：[LFU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)

**案例2**：CDN内容缓存

- **场景**：内容分发网络缓存热门内容
- **应用方式**：使用LFU算法缓存访问频率高的内容
- **效果**：提升热门内容的命中率，降低回源带宽
- **参考**：[LFU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)

**参考文档**：

- [LFU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)
- [算法实现的数学证明](../01-理论基础/01.05-算法对比与决策/01.05.05-算法实现的数学证明.md)
- [形式化分析理论模型](./形式化分析理论模型.md)

---

### 2.3 ARC（Adaptive Replacement Cache）

**基本信息**：

- **英文名称**：Adaptive Replacement Cache
- **缩写**：ARC
- **分类**：算法概念 - 自适应缓存替换算法
- **首次提出**：2003年，IBM Almaden研究中心（Nimrod Megiddo, Dharmendra S. Modha）
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
ARC是一种自适应缓存替换算法，同时跟踪LRU和LFU两个列表，根据工作负载特征动态调整两个列表的大小，实现自适应优化。ARC能够自动适应访问模式变化，无需手动调参。

**形式化定义**：

设缓存容量为$C$，ARC维护四个列表：

- **T1**：最近访问的LRU列表（大小$|T1|$）
- **T2**：频繁访问的LFU列表（大小$|T2|$）
- **B1**：T1的幽灵条目（大小$|B1|$）
- **B2**：T2的幽灵条目（大小$|B2|$）

**约束条件**：

- $|T1| + |T2| = C$（缓存容量限制）
- $|T1| + |B1| + |T2| + |B2| \leq 2C$（总空间限制）

**自适应参数**：$p \in [0, C]$表示T1的目标大小

**自适应调整规则**：
$$
p_{new} = \begin{cases}
\min(C, p + \max(1, |B2|/|B1|)) & \text{如果B1命中} \\
\max(0, p - \max(1, |B1|/|B2|)) & \text{如果B2命中} \\
p & \text{如果T1或T2命中}
\end{cases}
$$

**关键属性**：

- **时间复杂度**：$O(1)$（所有操作）
- **空间复杂度**：$O(C)$（最多2C个条目）
- **适用场景**：访问模式动态变化的场景
- **竞争比**：$2$（最坏情况下）
- **自适应能力**：自动适应LRU/LFU混合访问模式
- **命中率**：在实际应用中，命中率通常接近最优算法

**关系**：

- **继承关系**：
  - 继承自：缓存替换算法
- **组合关系**：
  - 由LRU和LFU组合而成
  - 包含幽灵条目机制
- **依赖关系**：
  - 依赖于：时间局部性和频率局部性原理
- **替代关系**：
  - 可替代：LRU、LFU（自适应场景）
  - 可被以下算法替代：W-TinyLFU（内存受限场景）

**应用案例**：

**案例1**：数据库Buffer Pool

- **场景**：数据库系统Buffer Pool管理
- **应用方式**：使用ARC算法自动适应查询模式变化
- **效果**：无需手动调参，自动优化缓存策略
- **参考**：[ARC自适应替换缓存](../01-理论基础/01.02-高级替换算法/01.02.04-ARC自适应替换缓存.md)

**案例2**：存储系统缓存

- **场景**：文件系统缓存
- **应用方式**：使用ARC算法适应访问模式变化
- **效果**：提升缓存命中率，降低IO延迟
- **参考**：[ARC自适应替换缓存](../01-理论基础/01.02-高级替换算法/01.02.04-ARC自适应替换缓存.md)

**参考文档**：

- [ARC自适应替换缓存](../01-理论基础/01.02-高级替换算法/01.02.04-ARC自适应替换缓存.md)
- [算法实现的数学证明](../01-理论基础/01.05-算法对比与决策/01.05.05-算法实现的数学证明.md)
- [形式化分析理论模型](./形式化分析理论模型.md)

---

### 2.4 Clock（时钟扫描算法）

**基本信息**：

- **英文名称**：Clock Algorithm / Second Chance Algorithm
- **缩写**：Clock
- **分类**：算法概念 - 缓存替换算法
- **首次提出**：1960年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Clock算法是FIFO算法的改进版本，通过引用位（Reference Bit）给数据第二次机会，避免刚访问的数据被立即淘汰。Clock算法使用循环队列和时钟指针实现简单的LRU近似。

**形式化定义**：

设缓存容量为$k$，访问序列为$\sigma = (r_1, r_2, ..., r_n)$。

对于每个数据项$x$，维护引用位$R_x \in \{0, 1\}$：

- $R_x = 1$：数据$x$最近被访问过
- $R_x = 0$：数据$x$未被访问过

**淘汰策略**：

- 时钟指针$p$从当前位置开始顺时针扫描
- 如果$R_p = 1$：设置$R_p = 0$，$p = (p + 1) \bmod k$（给第二次机会）
- 如果$R_p = 0$：淘汰数据项$p$，$p = (p + 1) \bmod k$

**关键属性**：

- **时间复杂度**：
  - 查找：$O(1)$（哈希表）
  - 插入：$O(1)$（循环队列）
  - 淘汰：$O(k)$（最坏情况需要扫描一圈）
- **空间复杂度**：$O(k)$（循环队列+引用位）
- **适用场景**：简单高效的缓存场景，硬件支持引用位
- **命中率**：介于FIFO和LRU之间，通常比FIFO高5-10%
- **硬件支持**：引用位可由硬件自动维护

**关系**：

- **继承关系**：
  - 继承自：FIFO算法
  - 扩展为：二次机会算法（Second Chance）
- **组合关系**：
  - 由循环队列和引用位组成
- **依赖关系**：
  - 依赖于：时间局部性原理（通过引用位近似）
- **替代关系**：
  - 可替代：FIFO（提升命中率）
  - 可被以下算法替代：LRU（更高命中率）

**应用案例**：

**案例1**：操作系统页面置换

- **场景**：虚拟内存页面置换
- **应用方式**：使用Clock算法选择被置换的页面
- **效果**：实现简单，硬件支持，性能优于FIFO
- **参考**：[Clock时钟扫描算法](../01-理论基础/01.02-高级替换算法/01.02.06-Clock时钟扫描算法.md)

**案例2**：PostgreSQL Shared Buffer

- **场景**：PostgreSQL数据库Buffer Pool管理
- **应用方式**：使用Clock Sweep算法管理共享缓冲区
- **效果**：O(1)平均时间复杂度，适合高并发场景
- **参考**：[Clock时钟扫描算法](../01-理论基础/01.02-高级替换算法/01.02.06-Clock时钟扫描算法.md)

**参考文档**：

- [Clock时钟扫描算法](../01-理论基础/01.02-高级替换算法/01.02.06-Clock时钟扫描算法.md)
- [算法实现的数学证明](../01-理论基础/01.05-算法对比与决策/01.05.05-算法实现的数学证明.md)
- [PostgreSQL Shared Buffer](../02-系统实现/02.03-数据库缓存/02.03.03-PostgreSQL-Shared-Buffer.md)

---

### 2.5 FIFO（First In First Out）

**基本信息**：

- **英文名称**：First In First Out
- **缩写**：FIFO
- **分类**：算法概念 - 缓存替换算法
- **首次提出**：早期计算机系统
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
FIFO是一种最简单的缓存替换算法，按照数据进入缓存的顺序进行淘汰，最先进入的数据最先被淘汰。FIFO不考虑访问历史，实现简单但命中率较低。

**形式化定义**：

设缓存容量为$k$，访问序列为$\sigma = (r_1, r_2, ..., r_n)$。

FIFO算法维护一个队列$Q$，按进入时间排序：

- 如果$r_i \in Cache$：保持缓存不变
- 如果$r_i \notin Cache$且$|Cache| < k$：将$r_i$加入队列尾部
- 如果$r_i \notin Cache$且$|Cache| = k$：淘汰队列头部元素，将$r_i$加入队列尾部

**关键属性**：

- **时间复杂度**：$O(1)$（队列操作）
- **空间复杂度**：$O(k)$
- **适用场景**：顺序访问模式、实现简单性优先
- **命中率**：在随机访问模式下，命中率通常为$k/n$（$n$为数据项总数）
- **优势**：实现简单，无额外开销
- **劣势**：不考虑访问历史，命中率低

**关系**：

- **继承关系**：
  - 继承自：缓存替换算法
  - 扩展为：Clock算法
- **组合关系**：
  - 由队列数据结构组成
- **依赖关系**：
  - 无特殊依赖
- **替代关系**：
  - 可被以下算法替代：LRU、LFU、Clock（提升命中率）

**应用案例**：

**案例1**：Redis复制积压缓冲区

- **场景**：Redis主从复制积压缓冲区
- **应用方式**：使用FIFO队列存储复制命令
- **效果**：实现简单，满足顺序性要求
- **参考**：[FIFO与MRU算法](../01-理论基础/01.01-基础替换算法/01.01.03-FIFO与MRU算法.md)

**参考文档**：

- [FIFO与MRU算法](../01-理论基础/01.01-基础替换算法/01.01.03-FIFO与MRU算法.md)

---

### 2.6 MRU（Most Recently Used）

**基本信息**：

- **英文名称**：Most Recently Used
- **缩写**：MRU
- **分类**：算法概念 - 缓存替换算法
- **首次提出**：早期计算机系统
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
MRU是一种缓存替换算法，淘汰最近访问的数据项。MRU适用于"扫描"访问模式，即访问过的数据不会再次访问。

**形式化定义**：

设缓存容量为$k$，访问序列为$\sigma = (r_1, r_2, ..., r_n)$。

MRU算法维护最近访问的数据项：

- 如果$r_i \in Cache$：将$r_i$移动到最近访问位置
- 如果$r_i \notin Cache$且$|Cache| < k$：将$r_i$加入缓存
- 如果$r_i \notin Cache$且$|Cache| = k$：淘汰最近访问的数据项，然后加入$r_i$

**关键属性**：

- **时间复杂度**：$O(1)$
- **空间复杂度**：$O(k)$
- **适用场景**：扫描访问模式（如数据库全表扫描）
- **命中率**：在扫描模式下，命中率通常高于LRU

**关系**：

- **继承关系**：
  - 继承自：缓存替换算法
- **替代关系**：
  - 可替代：LRU（扫描访问模式）

**参考文档**：

- [FIFO与MRU算法](../01-理论基础/01.01-基础替换算法/01.01.03-FIFO与MRU算法.md)

---

### 2.7 Random（随机替换）

**基本信息**：

- **英文名称**：Random Replacement
- **缩写**：Random
- **分类**：算法概念 - 缓存替换算法
- **首次提出**：早期计算机系统
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Random是一种简单的缓存替换算法，随机选择数据项进行淘汰。Random不考虑任何访问模式，实现简单但性能较差。

**形式化定义**：

设缓存容量为$k$，访问序列为$\sigma = (r_1, r_2, ..., r_n)$。

Random算法：

- 如果$r_i \in Cache$：保持缓存不变
- 如果$r_i \notin Cache$且$|Cache| < k$：将$r_i$加入缓存
- 如果$r_i \notin Cache$且$|Cache| = k$：随机选择$s \in Cache$淘汰，然后加入$r_i$

**关键属性**：

- **时间复杂度**：$O(1)$
- **空间复杂度**：$O(k)$
- **适用场景**：基准测试、性能对比
- **命中率**：在随机访问模式下，命中率通常为$k/n$

**关系**：

- **继承关系**：
  - 继承自：缓存替换算法
- **替代关系**：
  - 可被以下算法替代：LRU、LFU（提升命中率）

**参考文档**：

- [Random随机替换算法](../01-理论基础/01.01-基础替换算法/01.01.05-Random随机替换算法.md)

---

### 2.8 LRU-K

**基本信息**：

- **英文名称**：LRU-K Algorithm
- **缩写**：LRU-K
- **分类**：算法概念 - 高级缓存替换算法
- **首次提出**：1993年，Elizabeth J. O'Neil, Patrick E. O'Neil, Gerhard Weikum
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
LRU-K是LRU算法的扩展，考虑数据项的最近K次访问历史，而不是仅考虑最近一次访问。LRU-K通过考虑更多历史信息，提升命中率。

**形式化定义**：

设缓存容量为$k$，参数$K \geq 2$，访问序列为$\sigma = (r_1, r_2, ..., r_n)$。

对于每个数据项$x$，维护最近K次访问时间戳：$T_x = \{t_1, t_2, ..., t_K\}$（按时间排序）

**淘汰策略**：

- 淘汰$K$-th最近访问时间最早的数据项
- 如果数据项访问次数<$K$，则按FIFO淘汰

**关键属性**：

- **时间复杂度**：$O(\log k)$（维护K次访问历史）
- **空间复杂度**：$O(k \cdot K)$
- **适用场景**：需要更高命中率的场景
- **命中率**：通常比LRU高5-15%

**关系**：

- **继承关系**：
  - 继承自：LRU算法
- **替代关系**：
  - 可替代：LRU（提升命中率）
  - 可被以下算法替代：ARC（自适应场景）

**参考文档**：

- [LRU-K算法](../01-理论基础/01.02-高级替换算法/01.02.05-LRU-K算法.md)

---

### 2.9 W-TinyLFU

**基本信息**：

- **英文名称**：Window TinyLFU
- **缩写**：W-TinyLFU
- **分类**：算法概念 - 高级缓存替换算法
- **首次提出**：2017年，Ben Manes (Caffeine)
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
W-TinyLFU是LFU算法的优化版本，结合LRU和LFU的优势，使用Window Cache处理新数据，使用Count-Min Sketch统计频率，实现低内存开销的高性能缓存。

**形式化定义**：

W-TinyLFU维护三层结构：

- **Window Cache**：使用LRU，处理新数据
- **Main Cache**：分为Protected和Probation两部分
- **Count-Min Sketch**：统计访问频率

**关键属性**：

- **时间复杂度**：$O(1)$（所有操作）
- **空间开销**：低（Count-Min Sketch仅需少量内存）
- **适用场景**：内存受限的高性能缓存场景
- **命中率**：接近LFU，但内存开销更低

**关系**：

- **继承关系**：
  - 继承自：LFU算法
- **组合关系**：
  - 由LRU和LFU组合而成
  - 使用Count-Min Sketch统计频率

**参考文档**：

- [W-TinyLFU算法分析](../01-理论基础/01.02-高级替换算法/01.02.07-W-TinyLFU算法分析.md)

---

### 2.10 一致性哈希（Consistent Hashing）

**基本信息**：

- **英文名称**：Consistent Hashing
- **缩写**：CH
- **分类**：算法概念 - 分布式缓存算法
- **首次提出**：1997年，David Karger等（MIT）
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
一致性哈希是一种分布式哈希算法，用于在分布式缓存系统中分配数据到多个节点。一致性哈希的主要优势是在节点增减时，只需要重新分配少量数据，而不是全部数据。

**形式化定义**：

设节点集合为$N = \{n_1, n_2, ..., n_m\}$，数据项集合为$D = \{d_1, d_2, ..., d_n\}$。

一致性哈希将节点和数据映射到哈希环$[0, 2^{32})$：

- 节点映射：$h(n_i) \in [0, 2^{32})$
- 数据映射：$h(d_j) \in [0, 2^{32})$

**分配规则**：

- 数据项$d_j$分配给顺时针方向最近的节点
- $assign(d_j) = \arg\min_{n_i \in N} \{h(n_i) - h(d_j) \bmod 2^{32}\}$

**关键属性**：

- **时间复杂度**：$O(\log m)$（使用平衡树）或$O(1)$（使用虚拟节点+哈希表）
- **空间复杂度**：$O(m)$（$m$为节点数）
- **适用场景**：分布式缓存、负载均衡
- **负载均衡**：使用虚拟节点可改善负载均衡
- **故障恢复**：节点故障时，仅影响相邻数据

**关系**：

- **继承关系**：
  - 继承自：分布式哈希算法
  - 扩展为：Jump Hash、Maglev Hash、Rendezvous Hash
- **组合关系**：
  - 使用虚拟节点优化负载均衡

**应用案例**：

**案例1**：Redis Cluster

- **场景**：Redis集群数据分片
- **应用方式**：使用一致性哈希分配16384个slot到多个节点
- **效果**：节点增减时，仅影响少量数据迁移
- **参考**：[一致性哈希原理](../01-理论基础/01.03-分布式缓存算法/01.03.01-一致性哈希原理.md)

**参考文档**：

- [一致性哈希原理](../01-理论基础/01.03-分布式缓存算法/01.03.01-一致性哈希原理.md)
- [一致性哈希变种算法](../01-理论基础/01.03-分布式缓存算法/01.03.04-一致性哈希变种算法.md)

---

### 2.11 Jump Hash

**基本信息**：

- **英文名称**：Jump Hash
- **缩写**：JH
- **分类**：算法概念 - 分布式缓存算法
- **首次提出**：2014年，John Lamping, Eric Veach (Google)
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Jump Hash是一种一致性哈希的变种，不需要虚拟节点即可实现均匀的负载分布。Jump Hash使用伪随机跳跃算法，时间复杂度为$O(\log n)$。

**形式化定义**：

设节点数为$n$，数据项为$key$。

Jump Hash算法：
$$jump(key, n) = \arg\min_{1 \leq i \leq n} \{hash(key, i)\}$$

其中$hash(key, i)$是伪随机哈希函数。

**关键属性**：

- **时间复杂度**：$O(\log n)$
- **空间复杂度**：$O(1)$（不需要存储虚拟节点）
- **适用场景**：节点数较少的分布式系统
- **负载均衡**：均匀分布，无需虚拟节点
- **优势**：实现简单，无需虚拟节点

**关系**：

- **继承关系**：
  - 继承自：一致性哈希
- **替代关系**：
  - 可替代：一致性哈希（节点数较少时）

**参考文档**：

- [一致性哈希变种算法](../01-理论基础/01.03-分布式缓存算法/01.03.04-一致性哈希变种算法.md)

---

### 2.12 Maglev Hash

**基本信息**：

- **英文名称**：Maglev Hash
- **缩写**：MH
- **分类**：算法概念 - 分布式缓存算法
- **首次提出**：2016年，Google（用于负载均衡器Maglev）
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Maglev Hash是一种一致性哈希的变种，使用预计算的查找表实现$O(1)$查找时间。Maglev Hash通过精心设计的算法保证负载均衡和最小化重映射。

**形式化定义**：

Maglev Hash维护一个查找表$T[0..M-1]$，其中$M$是查找表大小（通常为素数）。

**查找规则**：

- $assign(key) = T[hash(key) \bmod M]$

**查找表构建**：

- 使用贪心算法构建，最小化重映射

**关键属性**：

- **时间复杂度**：$O(1)$（查找），$O(M \log M)$（构建）
- **空间复杂度**：$O(M)$（查找表）
- **适用场景**：高性能负载均衡、查找时间敏感的场景
- **负载均衡**：均匀分布，最小化重映射

**关系**：

- **继承关系**：
  - 继承自：一致性哈希
- **替代关系**：
  - 可替代：一致性哈希（查找时间敏感场景）

**参考文档**：

- [一致性哈希变种算法](../01-理论基础/01.03-分布式缓存算法/01.03.04-一致性哈希变种算法.md)

---

### 2.13 Rendezvous Hash

**基本信息**：

- **英文名称**：Rendezvous Hash / Highest Random Weight Hash
- **缩写**：RH / HRW
- **分类**：算法概念 - 分布式缓存算法
- **首次提出**：1996年，David G. Thaler, Chinya V. Ravishankar
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Rendezvous Hash是一种分布式哈希算法，为每个数据项计算与所有节点的权重，选择权重最高的节点。Rendezvous Hash实现简单，负载均衡效果好。

**形式化定义**：

设节点集合为$N = \{n_1, n_2, ..., n_m\}$，数据项为$key$。

**分配规则**：
$$assign(key) = \arg\max_{n_i \in N} \{hash(key, n_i)\}$$

其中$hash(key, n_i)$是组合哈希函数。

**关键属性**：

- **时间复杂度**：$O(m)$（$m$为节点数）
- **空间复杂度**：$O(1)$
- **适用场景**：节点数较少的分布式系统
- **负载均衡**：均匀分布
- **优势**：实现简单，无需虚拟节点

**关系**：

- **继承关系**：
  - 继承自：分布式哈希算法
- **替代关系**：
  - 可替代：一致性哈希（节点数较少时）

**参考文档**：

- [Rendezvous哈希算法](../01-理论基础/01.03-分布式缓存算法/01.03.03-Rendezvous哈希算法.md)
- [一致性哈希变种算法](../01-理论基础/01.03-分布式缓存算法/01.03.04-一致性哈希变种算法.md)

---

## 3. 数据结构概念定义

### 3.1 SDS（Simple Dynamic String）

**基本信息**：

- **英文名称**：Simple Dynamic String
- **缩写**：SDS
- **分类**：数据结构概念 - Redis核心数据结构
- **首次提出**：2009年，Redis项目
- **当前版本**：v5.0（Redis 3.2+）

**定义**：

**自然语言定义**：
SDS是Redis实现的简单动态字符串，是对C语言字符串的封装和优化。SDS支持O(1)长度获取、二进制安全、自动扩容等特性。

**形式化定义**：

SDS结构定义（简化）：

```c
struct sdshdr {
    int len;        // 字符串长度
    int free;       // 剩余空间
    char buf[];     // 字符数组
};
```

**关键属性**：

- **时间复杂度**：
  - 长度获取：$O(1)$
  - 追加：$O(1)$（平均），$O(n)$（需要扩容）
  - 查找：$O(n)$
- **空间复杂度**：$O(n)$（$n$为字符串长度）
- **优势**：二进制安全、O(1)长度获取、自动扩容
- **劣势**：内存开销略大于C字符串

**关系**：

- **组合关系**：
  - 是Redis所有字符串类型的基础
- **依赖关系**：
  - 依赖于：C语言内存管理

**参考文档**：

- [SDS简单动态字符串](../03-Redis组件/03.01-核心数据结构/03.01.01-SDS简单动态字符串.md)

---

### 3.2 dict（哈希表）

**基本信息**：

- **英文名称**：Dictionary / Hash Table
- **缩写**：dict
- **分类**：数据结构概念 - Redis核心数据结构
- **首次提出**：2009年，Redis项目
- **当前版本**：v2.0（渐进式Rehash）

**定义**：

**自然语言定义**：
dict是Redis实现的哈希表，支持O(1)查找、插入、删除操作。dict使用渐进式Rehash机制，避免一次性Rehash造成的延迟峰值。

**形式化定义**：

dict结构定义（简化）：

```c
typedef struct dict {
    dictType *type;
    dictht ht[2];      // 两个哈希表（用于渐进式Rehash）
    long rehashidx;    // Rehash进度
    int iterators;     // 迭代器数量
} dict;
```

**关键属性**：

- **时间复杂度**：
  - 查找：$O(1)$（平均），$O(n)$（最坏）
  - 插入：$O(1)$（平均），$O(n)$（最坏）
  - 删除：$O(1)$（平均），$O(n)$（最坏）
- **空间复杂度**：$O(n)$
- **优势**：O(1)平均时间复杂度、渐进式Rehash
- **劣势**：最坏情况O(n)时间复杂度

**关系**：

- **组合关系**：
  - 是Redis Hash、Set、ZSet的基础数据结构
- **依赖关系**：
  - 依赖于：哈希函数、冲突解决（链地址法）

**参考文档**：

- [哈希表dict实现](../03-Redis组件/03.01-核心数据结构/03.01.02-哈希表dict实现.md)

---

### 3.3 quicklist（快速列表）

**基本信息**：

- **英文名称**：Quick List
- **缩写**：quicklist
- **分类**：数据结构概念 - Redis核心数据结构
- **首次提出**：2014年，Redis 3.2
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
quicklist是Redis List的底层实现，是双向链表和ziplist的结合。quicklist通过将多个ziplist节点组织成双向链表，平衡内存效率和操作性能。

**形式化定义**：

quicklist结构定义（简化）：

```c
typedef struct quicklist {
    quicklistNode *head;
    quicklistNode *tail;
    unsigned long count;    // 元素总数
    unsigned long len;      // 节点数
    int fill;               // ziplist最大大小
    int compress;           // 压缩深度
} quicklist;
```

**关键属性**：

- **时间复杂度**：
  - 头部插入：$O(1)$
  - 尾部插入：$O(1)$
  - 中间插入：$O(n)$
  - 查找：$O(n)$
- **空间复杂度**：$O(n)$
- **优势**：内存效率高、支持压缩、操作性能好
- **劣势**：中间插入/删除需要O(n)时间

**关系**：

- **组合关系**：
  - 由双向链表和ziplist组成
- **依赖关系**：
  - 依赖于：ziplist数据结构

**参考文档**：

- [列表quicklist实现](../03-Redis组件/03.01-核心数据结构/03.01.03-列表quicklist实现.md)

---

### 3.4 skiplist（跳表）

**基本信息**：

- **英文名称**：Skip List
- **缩写**：skiplist
- **分类**：数据结构概念 - Redis核心数据结构
- **首次提出**：1989年，William Pugh
- **当前版本**：v1.0（Redis实现）

**定义**：

**自然语言定义**：
skiplist是一种概率性的有序数据结构，通过多级索引实现O(log n)的查找、插入、删除操作。Redis使用skiplist实现ZSet（有序集合）。

**形式化定义**：

skiplist结构定义（简化）：

```c
typedef struct zskiplistNode {
    robj *obj;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned int span;
    } level[];
} zskiplistNode;
```

**关键属性**：

- **时间复杂度**：
  - 查找：$O(\log n)$（期望）
  - 插入：$O(\log n)$（期望）
  - 删除：$O(\log n)$（期望）
- **空间复杂度**：$O(n)$（期望）
- **优势**：实现简单、性能稳定、支持范围查询
- **劣势**：空间开销略大于平衡树

**关系**：

- **组合关系**：
  - 是Redis ZSet的底层数据结构之一
  - 与哈希表组合实现ZSet
- **依赖关系**：
  - 依赖于：随机数生成（决定层级）

**参考文档**：

- [有序集合skiplist实现](../03-Redis组件/03.01-核心数据结构/03.01.05-有序集合skiplist实现.md)

---

### 3.5 intset（整数集合）

**基本信息**：

- **英文名称**：Integer Set
- **缩写**：intset
- **分类**：数据结构概念 - Redis核心数据结构
- **首次提出**：2009年，Redis项目
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
intset是Redis Set的底层实现之一，用于存储整数集合。intset使用有序数组存储整数，支持O(log n)查找和O(n)插入。

**形式化定义**：

intset结构定义（简化）：

```c
typedef struct intset {
    uint32_t encoding;  // 编码方式（int16/int32/int64）
    uint32_t length;    // 元素个数
    int8_t contents[];  // 整数数组（有序）
} intset;
```

**关键属性**：

- **时间复杂度**：
  - 查找：$O(\log n)$（二分查找）
  - 插入：$O(n)$（需要移动元素）
- **空间复杂度**：$O(n)$
- **优势**：内存效率高（仅存储整数）、有序
- **劣势**：插入/删除需要O(n)时间

**关系**：

- **组合关系**：
  - 是Redis Set的底层数据结构之一（小集合）
- **替代关系**：
  - 可被哈希表替代（大集合或非整数）

**参考文档**：

- [集合intset实现](../03-Redis组件/03.01-核心数据结构/03.01.04-集合intset实现.md)

---

### 3.6 ziplist（压缩列表）

**基本信息**：

- **英文名称**：Zip List
- **缩写**：ziplist
- **分类**：数据结构概念 - Redis核心数据结构
- **首次提出**：2009年，Redis项目
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
ziplist是Redis实现的压缩列表，是一种紧凑的线性数据结构，用于存储小列表、小哈希表等。ziplist通过连续内存布局和变长编码实现内存优化。

**形式化定义**：

ziplist结构定义（简化）：

```c
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```

每个entry包含：

- prevlen：前一个entry的长度（变长编码）
- encoding：当前entry的编码（变长编码）
- data：实际数据

**关键属性**：

- **时间复杂度**：
  - 查找：$O(n)$
  - 插入：$O(n)$（需要移动后续元素）
- **空间复杂度**：$O(n)$（紧凑存储）
- **优势**：内存效率高、紧凑存储
- **劣势**：操作性能较差（需要移动元素）

**关系**：

- **组合关系**：
  - 是quicklist的组成部分
  - 用于小列表、小哈希表
- **替代关系**：
  - 可被quicklist替代（大列表）
  - 可被哈希表替代（大哈希表）

**参考文档**：

- [压缩编码ziplist](../03-Redis组件/03.01-核心数据结构/03.01.06-压缩编码ziplist.md)

---

### 3.7 HyperLogLog（基数统计）

**基本信息**：

- **英文名称**：HyperLogLog
- **缩写**：HLL
- **分类**：数据结构概念 - Redis高级数据结构
- **首次提出**：2007年，Philippe Flajolet等
- **当前版本**：v1.0（Redis实现）

**定义**：

**自然语言定义**：
HyperLogLog是一种概率性数据结构，用于估计集合的基数（不重复元素的数量）。HyperLogLog使用极小的内存（约12KB）即可估计百万级甚至更大集合的基数。

**形式化定义**：

设集合为$S = \{s_1, s_2, ..., s_n\}$，基数为$|S|$。

HyperLogLog使用$m$个寄存器$R = \{R_1, R_2, ..., R_m\}$，每个寄存器存储最大前导零个数。

**基数估计公式**：
$$|\hat{S}| = \alpha_m \times m^2 \times \left(\sum_{i=1}^{m} 2^{-R_i}\right)^{-1}$$

其中$\alpha_m$为修正因子。

**关键属性**：

- **时间复杂度**：$O(1)$（添加元素）
- **空间复杂度**：$O(m)$（$m$为寄存器数，通常$m=16384$）
- **误差率**：标准误差约0.81%
- **优势**：内存效率极高，适合大数据集基数统计

**关系**：

- **继承关系**：
  - 继承自：概率性数据结构
- **替代关系**：
  - 可替代：精确基数统计（内存受限时）

**参考文档**：

- [HyperLogLog基数统计](../03-Redis组件/03.01-核心数据结构/03.01.07-HyperLogLog基数统计.md)

---

### 3.8 Stream（流数据结构）

**基本信息**：

- **英文名称**：Stream
- **缩写**：无
- **分类**：数据结构概念 - Redis高级数据结构
- **首次提出**：2018年，Redis 5.0
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Stream是Redis 5.0引入的流数据结构，类似于Kafka的消息队列，支持消息的追加、消费、消费者组等功能。Stream用于实现消息队列、事件流等场景。

**形式化定义**：

Stream结构定义（简化）：

```c
typedef struct stream {
    rax *rax;              // 基数树，存储消息ID到消息的映射
    uint64_t length;       // 消息数量
    streamID last_id;      // 最后一条消息ID
    list *cgroups;         // 消费者组列表
} stream;
```

**关键属性**：

- **时间复杂度**：
  - 追加：$O(1)$
  - 读取：$O(\log n)$（$n$为消息数）
- **空间复杂度**：$O(n)$（$n$为消息数）
- **优势**：支持消息队列、消费者组、消息持久化
- **适用场景**：消息队列、事件流、日志收集

**关系**：

- **组合关系**：
  - 由基数树和消费者组组成
- **替代关系**：
  - 可替代：外部消息队列（如Kafka）

**参考文档**：

- [Stream流数据结构](../03-Redis组件/03.01-核心数据结构/03.01.08-Stream流数据结构.md)

---

### 3.9 RedisJSON

**基本信息**：

- **英文名称**：RedisJSON
- **缩写**：JSON
- **分类**：数据结构概念 - Redis模块
- **首次提出**：2019年，Redis Labs
- **当前版本**：v2.0

**定义**：

**自然语言定义**：
RedisJSON是Redis的JSON模块，支持在Redis中存储和查询JSON数据。RedisJSON使用JSONPath语法进行查询，支持高效的JSON操作。

**形式化定义**：

设JSON文档为$D$，JSONPath查询为$P$。

**查询操作**：
$$query(D, P) = \{value | value \in D, path(value) \ matches \ P\}$$

**关键属性**：

- **时间复杂度**：
  - 查询：$O(n)$（$n$为JSON文档大小）
  - 更新：$O(n)$
- **空间复杂度**：$O(n)$（$n$为JSON文档大小）
- **优势**：原生JSON支持、JSONPath查询、内存效率高
- **适用场景**：文档存储、配置管理、API缓存

**关系**：

- **继承关系**：
  - 继承自：Redis模块
- **组合关系**：
  - 与Redis核心数据结构组合

**参考文档**：

- [RedisJSON模块分析](../03-Redis组件/03.01-核心数据结构/03.01.09-RedisJSON模块分析.md)

---

### 3.10 RedisGraph

**基本信息**：

- **英文名称**：RedisGraph
- **缩写**：Graph
- **分类**：数据结构概念 - Redis模块
- **首次提出**：2018年，Redis Labs
- **当前版本**：v2.0

**定义**：

**自然语言定义**：
RedisGraph是Redis的图数据库模块，支持存储和查询图数据。RedisGraph使用Cypher查询语言，支持图遍历、最短路径等图算法。

**形式化定义**：

设图为$G = (V, E)$，其中$V$为节点集合，$E$为边集合。

**图查询**：
$$query(G, Q) = \{result | result \ matches \ Q\}$$

其中$Q$为Cypher查询。

**关键属性**：

- **时间复杂度**：
  - 节点查询：$O(1)$
  - 图遍历：$O(V + E)$
  - 最短路径：$O(V \log V + E)$
- **空间复杂度**：$O(V + E)$
- **优势**：原生图支持、Cypher查询、高性能图算法
- **适用场景**：社交网络、推荐系统、知识图谱

**关系**：

- **继承关系**：
  - 继承自：Redis模块
- **组合关系**：
  - 由节点和边组成

**参考文档**：

- [RedisGraph模块分析](../03-Redis组件/03.01-核心数据结构/03.01.10-RedisGraph模块分析.md)

---

### 3.11 RedisTimeSeries

**基本信息**：

- **英文名称**：RedisTimeSeries
- **缩写**：TS
- **分类**：数据结构概念 - Redis模块
- **首次提出**：2019年，Redis Labs
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
RedisTimeSeries是Redis的时间序列数据模块，支持高效存储和查询时间序列数据。RedisTimeSeries支持数据压缩、聚合查询、下采样等功能。

**形式化定义**：

设时间序列为$TS = \{(t_1, v_1), (t_2, v_2), ..., (t_n, v_n)\}$，其中$t_i$为时间戳，$v_i$为值。

**时间序列查询**：
$$query(TS, t_{start}, t_{end}, agg) = \{agg(v_i) | t_{start} \leq t_i \leq t_{end}\}$$

其中$agg$为聚合函数（如SUM、AVG、MAX、MIN）。

**关键属性**：

- **时间复杂度**：
  - 写入：$O(1)$
  - 查询：$O(\log n)$（$n$为时间序列长度）
- **空间复杂度**：$O(n)$（压缩后更小）
- **优势**：高效压缩、聚合查询、下采样
- **适用场景**：监控数据、IoT数据、金融数据

**关系**：

- **继承关系**：
  - 继承自：Redis模块
- **组合关系**：
  - 由时间戳和值组成

**参考文档**：

- [RedisTimeSeries模块分析](../03-Redis组件/03.01-核心数据结构/03.01.11-RedisTimeSeries模块分析.md)

---

## 4. 系统概念定义

### 4.1 缓存（Cache）

**基本信息**：

- **英文名称**：Cache
- **缩写**：无
- **分类**：系统概念 - 核心系统概念
- **首次提出**：1960年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
缓存是一种临时存储机制，将频繁访问的数据存储在快速存储介质（如内存）中，以提升数据访问速度。缓存通过空间换时间的方式，减少对慢速存储介质（如磁盘、网络）的访问。

**形式化定义**：

设数据项集合为$U = \{u_1, u_2, ..., u_n\}$，缓存容量为$C$，缓存集合为$Cache \subseteq U$，$|Cache| \leq C$。

**缓存操作**：

- $get(u_i)$：从缓存获取数据项$u_i$
- $put(u_i)$：将数据项$u_i$加入缓存
- $evict(u_i)$：从缓存淘汰数据项$u_i$

**关键属性**：

- **访问速度**：缓存访问速度远快于原始数据源
- **容量限制**：缓存容量有限，需要替换策略
- **一致性**：缓存与原始数据源可能存在不一致
- **命中率**：缓存命中率是衡量缓存效果的关键指标

**关系**：

- **组合关系**：
  - 由缓存替换算法、缓存架构模式、缓存一致性策略组成
- **依赖关系**：
  - 依赖于：快速存储介质、替换算法

**参考文档**：

- [缓存架构模式](../04-架构设计/04.01-缓存架构模式/)

---

### 4.2 持久化（Persistence）

**基本信息**：

- **英文名称**：Persistence
- **缩写**：无
- **分类**：系统概念 - Redis核心机制
- **首次提出**：2009年，Redis项目
- **当前版本**：v2.0（RDB + AOF + 混合持久化）

**定义**：

**自然语言定义**：
持久化是将内存中的数据保存到持久化存储介质（如磁盘）的过程，确保数据在系统重启后不丢失。Redis支持RDB快照和AOF日志两种持久化方式。

**形式化定义**：

设内存数据为$M$，持久化存储为$D$。

**持久化操作**：

- $persist(M \rightarrow D)$：将内存数据持久化到磁盘
- $load(D \rightarrow M)$：从磁盘加载数据到内存

**持久化一致性**：
$$M \equiv D \text{（持久化后）}$$

**关键属性**：

- **持久化方式**：RDB（快照）、AOF（日志）、混合持久化
- **性能影响**：持久化会影响系统性能（延迟、吞吐量）
- **数据安全**：持久化保证数据不丢失
- **恢复时间**：RDB恢复快，AOF恢复慢

**关系**：

- **组合关系**：
  - 由RDB和AOF两种机制组成
- **依赖关系**：
  - 依赖于：文件系统、磁盘IO

**应用案例**：

**案例1**：Redis RDB快照

- **场景**：Redis定期快照
- **应用方式**：使用BGSAVE命令创建RDB快照
- **效果**：恢复速度快，文件小
- **参考**：[RDB快照机制](../03-Redis组件/03.02-持久化机制/03.02.01-RDB快照机制.md)

**参考文档**：

- [RDB快照机制](../03-Redis组件/03.02-持久化机制/03.02.01-RDB快照机制.md)
- [AOF日志机制](../03-Redis组件/03.02-持久化机制/03.02.02-AOF日志机制.md)
- [混合持久化](../03-Redis组件/03.02-持久化机制/03.02.03-混合持久化.md)

---

### 4.3 复制（Replication）

**基本信息**：

- **英文名称**：Replication
- **缩写**：无
- **分类**：系统概念 - Redis高可用机制
- **首次提出**：2009年，Redis项目
- **当前版本**：v2.8+（部分重同步）

**定义**：

**自然语言定义**：
复制是将主节点（Master）的数据同步到从节点（Slave）的过程，实现数据冗余和高可用。Redis支持主从复制，从节点可以处理读请求，分担主节点负载。

**形式化定义**：

设主节点为$M$，从节点集合为$S = \{S_1, S_2, ..., S_n\}$。

**复制操作**：

- $replicate(M \rightarrow S_i)$：将主节点数据复制到从节点$S_i$
- $sync(M, S_i)$：同步主从节点数据

**复制一致性**：
$$M.data \equiv S_i.data \text{（最终一致性）}$$

**关键属性**：

- **复制方式**：全量复制、增量复制（部分重同步）
- **一致性**：最终一致性（异步复制）
- **延迟**：复制延迟影响数据一致性
- **高可用**：主节点故障时，从节点可提升为主节点

**关系**：

- **组合关系**：
  - 是Redis高可用架构的核心机制
  - 与Sentinel、Cluster组合实现高可用
- **依赖关系**：
  - 依赖于：网络连接、持久化机制

**参考文档**：

- [主从复制机制](../03-Redis组件/03.03-高可用架构/03.03.01-主从复制机制.md)

---

### 4.4 高可用（High Availability）

**基本信息**：

- **英文名称**：High Availability
- **缩写**：HA
- **分类**：系统概念 - 系统可靠性
- **首次提出**：1990年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
高可用是指系统在部分组件故障时仍能继续提供服务的能力。高可用通过冗余、故障检测、自动故障转移等机制实现。

**形式化定义**：

设系统可用性为$A$，故障率为$\lambda$，恢复率为$\mu$。

**可用性公式**：
$$A = \frac{MTBF}{MTBF + MTTR} = \frac{\mu}{\lambda + \mu}$$

其中：

- $MTBF$：平均故障间隔时间（Mean Time Between Failures）
- $MTTR$：平均恢复时间（Mean Time To Repair）

**关键属性**：

- **可用性指标**：99.9%（三个9）、99.99%（四个9）等
- **故障检测**：自动检测故障
- **故障转移**：自动切换到备用节点
- **数据一致性**：故障转移时保证数据一致性

**关系**：

- **组合关系**：
  - 由复制、Sentinel、Cluster等机制组成
- **依赖关系**：
  - 依赖于：故障检测、故障转移机制

**参考文档**：

- [Sentinel哨兵机制](../03-Redis组件/03.03-高可用架构/03.03.02-Sentinel哨兵机制.md)
- [Cluster集群模式](../03-Redis组件/03.03-高可用架构/03.03.03-Cluster集群模式.md)

---

### 4.5 CPU缓存（CPU Cache）

**基本信息**：

- **英文名称**：CPU Cache
- **缩写**：Cache
- **分类**：系统概念 - 硬件缓存
- **首次提出**：1980年代
- **当前版本**：v4.0（L1/L2/L3/L4）

**定义**：

**自然语言定义**：
CPU缓存是CPU和主存之间的高速缓存，用于减少CPU访问主存的延迟。CPU缓存采用多级层次结构（L1/L2/L3），容量递增，延迟递增。

**形式化定义**：

设CPU缓存层次为$L = \{L1, L2, L3\}$，容量为$C = \{C_1, C_2, C_3\}$，延迟为$D = \{D_1, D_2, D_3\}$。

**层次关系**：
$$C_1 < C_2 < C_3, \quad D_1 < D_2 < D_3$$

**关键属性**：

- **缓存层次**：L1（指令/数据缓存）、L2（统一缓存）、L3（共享缓存）
- **容量**：L1通常32KB-64KB，L2通常256KB-1MB，L3通常8MB-32MB
- **延迟**：L1约1-3ns，L2约10ns，L3约30-40ns
- **一致性协议**：MESI、MOESI等

**关系**：

- **层次关系**：
  - L1 → L2 → L3 → 主存
- **组合关系**：
  - 与NUMA架构组合实现多核缓存

**参考文档**：

- [L1/L2/L3缓存层次](../02-系统实现/02.02-CPU缓存架构/02.02.01-L1-L2-L3缓存层次.md)
- [MESI缓存一致性协议](../02-系统实现/02.02-CPU缓存架构/02.02.02-MESI缓存一致性协议.md)

---

### 4.6 NUMA（Non-Uniform Memory Access）

**基本信息**：

- **英文名称**：Non-Uniform Memory Access
- **缩写**：NUMA
- **分类**：系统概念 - 硬件架构
- **首次提出**：1990年代
- **当前版本**：v2.0

**定义**：

**自然语言定义**：
NUMA是一种多处理器架构，每个处理器有本地内存，访问本地内存快，访问远程内存慢。NUMA架构通过减少内存访问延迟提升系统性能。

**形式化定义**：

设NUMA节点集合为$N = \{N_1, N_2, ..., N_m\}$，每个节点有本地内存$M_i$。

**内存访问延迟**：
$$L_{local} < L_{remote}$$

其中$L_{local}$为本地内存访问延迟，$L_{remote}$为远程内存访问延迟。

**关键属性**：

- **访问延迟**：本地内存访问延迟约100ns，远程内存访问延迟约200-300ns
- **拓扑结构**：NUMA拓扑影响内存访问性能
- **优化策略**：CPU亲和性、内存本地化

**关系**：

- **组合关系**：
  - 与CPU缓存组合实现多级缓存层次
- **依赖关系**：
  - 依赖于：CPU架构、内存控制器

**参考文档**：

- [NUMA架构优化](../02-系统实现/02.05-系统级优化/02.05.01-NUMA架构优化.md)
- [NUMA架构影响](../05-全栈分析/05.01-硬件层深度剖析/05.01.02-NUMA架构影响.md)

---

### 4.7 Page Cache（页面缓存）

**基本信息**：

- **英文名称**：Page Cache
- **缩写**：PC
- **分类**：系统概念 - 操作系统缓存
- **首次提出**：1990年代，Linux内核
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Page Cache是Linux内核的文件系统缓存，将磁盘文件内容缓存在内存中，大幅提升文件I/O性能。Page Cache使用LRU算法管理页面。

**形式化定义**：

设文件为$F$，Page Cache为$PC$，页面大小为$P$（通常4KB）。

**缓存操作**：

- $read(F) \rightarrow PC$：从Page Cache读取文件
- $write(F) \rightarrow PC$：写入Page Cache（延迟写回磁盘）

**关键属性**：

- **页面大小**：通常4KB（x86）或64KB（ARM）
- **替换算法**：LRU（近似）
- **性能提升**：Page Cache命中时，延迟从ms级降至ns级

**关系**：

- **组合关系**：
  - 是Linux文件系统的组成部分
- **依赖关系**：
  - 依赖于：内存管理、文件系统

**参考文档**：

- [Linux Page Cache机制](../02-系统实现/02.01-操作系统缓存/02.01.01-Linux-Page-Cache机制.md)

---

### 4.8 内存管理（Memory Management）

**基本信息**：

- **英文名称**：Memory Management
- **缩写**：MM
- **分类**：系统概念 - Redis核心机制
- **首次提出**：2009年，Redis项目
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
内存管理是Redis对内存的分配、回收、碎片整理等操作的管理机制。Redis使用jemalloc或glibc的malloc进行内存分配，支持内存淘汰和碎片整理。

**形式化定义**：

设内存总量为$M$，已用内存为$U$，可用内存为$A$。

**内存约束**：
$$U + A = M, \quad U \leq M_{max}$$

其中$M_{max}$为最大内存限制。

**关键属性**：

- **分配器**：jemalloc、glibc malloc
- **淘汰策略**：LRU、LFU、Random等
- **碎片整理**：内存碎片整理机制
- **监控**：内存使用监控和告警

**关系**：

- **组合关系**：
  - 由内存分配、内存回收、碎片整理组成
- **依赖关系**：
  - 依赖于：内存分配器、淘汰算法

**参考文档**：

- [内存分配与回收](../03-Redis组件/03.04-内存管理/03.04.01-内存分配与回收.md)
- [内存碎片整理](../03-Redis组件/03.04-内存管理/03.04.02-内存碎片整理.md)

---

## 5. 架构概念定义

### 5.1 Cache-Aside（旁路缓存）

**基本信息**：

- **英文名称**：Cache-Aside / Lazy Loading
- **缩写**：CA
- **分类**：架构概念 - 缓存架构模式
- **首次提出**：2000年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Cache-Aside是最常用的缓存模式，应用程序负责维护缓存和数据库的一致性。缓存不作为数据源，而是作为数据库的"旁路"加速层。

**形式化定义**：

设应用程序为$App$，缓存为$Cache$，数据库为$DB$。

**读取操作**：
$$
read(key) = \begin{cases}
Cache.get(key) & \text{if } key \in Cache \\
DB.get(key) \rightarrow Cache.put(key, value) & \text{if } key \notin Cache
\end{cases}
$$

**写入操作**：
$$write(key, value) = DB.write(key, value) \rightarrow Cache.delete(key)$$

**关键属性**：

- **一致性**：最终一致性（应用程序控制）
- **性能**：读性能高（缓存命中时），写性能中等
- **复杂度**：实现简单，应用程序需要处理缓存逻辑
- **适用场景**：读多写少场景

**关系**：

- **继承关系**：
  - 继承自：缓存架构模式
- **替代关系**：
  - 可被Read-Through替代（简化应用逻辑）

**应用案例**：

**案例1**：电商秒杀系统

- **场景**：商品信息缓存
- **应用方式**：使用Cache-Aside模式缓存商品信息
- **效果**：读性能提升10-100倍
- **参考**：[Cache-Aside旁路缓存](../04-架构设计/04.01-缓存架构模式/04.01.01-Cache-Aside旁路缓存.md)

**参考文档**：

- [Cache-Aside旁路缓存](../04-架构设计/04.01-缓存架构模式/04.01.01-Cache-Aside旁路缓存.md)

---

### 5.2 Read-Through（透读缓存）

**基本信息**：

- **英文名称**：Read-Through
- **缩写**：RT
- **分类**：架构概念 - 缓存架构模式
- **首次提出**：1990年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Read-Through是一种缓存模式，应用程序将缓存视为主要数据源，缓存负责在未命中时从数据源加载数据。这种模式将读逻辑封装在缓存层，简化了应用程序代码。

**形式化定义**：

设应用程序为$App$，缓存为$Cache$，数据源为$Source$。

**读取操作**：
$$
read(key) = \begin{cases}
Cache.get(key) & \text{if } key \in Cache \\
Source.get(key) \rightarrow Cache.put(key, value) \rightarrow value & \text{if } key \notin Cache
\end{cases}
$$

**关键属性**：

- **一致性**：最终一致性（缓存控制）
- **性能**：读性能高，写性能中等
- **复杂度**：实现中等，缓存层需要处理加载逻辑
- **适用场景**：读多写少场景，简化应用逻辑

**关系**：

- **继承关系**：
  - 继承自：缓存架构模式
- **替代关系**：
  - 可替代Cache-Aside（简化应用逻辑）

**参考文档**：

- [Read-Through透读缓存](../04-架构设计/04.01-缓存架构模式/04.01.02-Read-Through透读缓存.md)

---

### 5.3 Write-Through（透写缓存）

**基本信息**：

- **英文名称**：Write-Through
- **缩写**：WT
- **分类**：架构概念 - 缓存架构模式
- **首次提出**：1990年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Write-Through是一种缓存模式，应用程序写入数据时，同时写入缓存和数据库，保证数据一致性。这种模式适用于对一致性要求极高的场景，如金融支付系统。

**形式化定义**：

设应用程序为$App$，缓存为$Cache$，数据库为$DB$。

**写入操作**：
$$write(key, value) = Cache.write(key, value) \land DB.write(key, value)$$

**一致性保证**：
$$Cache[key] \equiv DB[key] \text{（写入后）}$$

**关键属性**：

- **一致性**：强一致性（同步写入）
- **性能**：写性能较低（需要同步写入数据库）
- **复杂度**：实现中等，需要保证原子性
- **适用场景**：强一致性要求场景（如金融支付）

**关系**：

- **继承关系**：
  - 继承自：缓存架构模式
- **替代关系**：
  - 可被Write-Behind替代（提升写性能，牺牲一致性）

**应用案例**：

**案例1**：金融支付系统

- **场景**：账户余额缓存
- **应用方式**：使用Write-Through模式保证强一致性
- **效果**：保证数据一致性，但写性能较低
- **参考**：[Write-Through透写缓存](../04-架构设计/04.01-缓存架构模式/04.01.03-Write-Through透写缓存.md)

**参考文档**：

- [Write-Through透写缓存](../04-架构设计/04.01-缓存架构模式/04.01.03-Write-Through透写缓存.md)

---

### 5.4 Write-Behind（异步写缓存）

**基本信息**：

- **英文名称**：Write-Behind / Write-Back
- **缩写**：WB
- **分类**：架构概念 - 缓存架构模式
- **首次提出**：1990年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
Write-Behind是一种高性能缓存模式，应用程序写入数据时先写入缓存并立即返回，然后异步将数据写入数据库。这种模式牺牲一致性换取性能，适用于写入密集型场景。

**形式化定义**：

设应用程序为$App$，缓存为$Cache$，数据库为$DB$。

**写入操作**：
$$write(key, value) = Cache.write(key, value) \rightarrow async(DB.write(key, value))$$

**一致性保证**：
$$Cache[key] \equiv DB[key] \text{（最终一致性）}$$

**关键属性**：

- **一致性**：最终一致性（异步写入）
- **性能**：写性能高（异步写入数据库）
- **复杂度**：实现复杂，需要处理异步写入失败
- **适用场景**：写入密集型场景，可容忍短暂不一致

**关系**：

- **继承关系**：
  - 继承自：缓存架构模式
- **替代关系**：
  - 可替代Write-Through（提升写性能，牺牲一致性）

**参考文档**：

- [Write-Behind异步写缓存](../04-架构设计/04.01-缓存架构模式/04.01.04-Write-Behind异步写缓存.md)

---

### 5.5 多级缓存（Multi-Level Cache）

**基本信息**：

- **英文名称**：Multi-Level Cache / Hierarchical Cache
- **缩写**：MLC
- **分类**：架构概念 - 缓存架构模式
- **首次提出**：1990年代
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
多级缓存是将缓存组织成多个层次，每层缓存容量和延迟不同，形成L1 → L2 → L3的缓存层次。多级缓存通过层次化设计，平衡容量和性能。

**形式化定义**：

设缓存层次为$L = \{L1, L2, L3\}$，容量为$C = \{C_1, C_2, C_3\}$，延迟为$D = \{D_1, D_2, D_3\}$。

**层次关系**：
$$C_1 < C_2 < C_3, \quad D_1 < D_2 < D_3$$

**读取操作**：
$$
read(key) = \begin{cases}
L1.get(key) & \text{if } key \in L1 \\
L2.get(key) \rightarrow L1.put(key, value) & \text{if } key \in L2 \\
L3.get(key) \rightarrow L2.put(key, value) \rightarrow L1.put(key, value) & \text{if } key \in L3 \\
Source.get(key) \rightarrow L3.put(key, value) \rightarrow L2.put(key, value) \rightarrow L1.put(key, value) & \text{otherwise}
\end{cases}
$$

**关键属性**：

- **层次结构**：L1（本地缓存）→ L2（分布式缓存）→ L3（数据库）
- **性能**：L1命中时延迟最低，L3命中时延迟最高
- **容量**：L1容量最小，L3容量最大
- **适用场景**：高并发场景，需要极低延迟

**关系**：

- **组合关系**：
  - 由多个缓存层组成
- **依赖关系**：
  - 依赖于：各层缓存实现

**应用案例**：

**案例1**：电商秒杀系统

- **场景**：商品信息多级缓存
- **应用方式**：CDN → 本地缓存 → Redis → 数据库
- **效果**：延迟从100ms降至1ms
- **参考**：[电商零售秒杀架构](../04-架构设计/04.03-行业应用场景/04.03.01-电商零售秒杀架构.md)

**参考文档**：

- [电商零售秒杀架构](../04-架构设计/04.03-行业应用场景/04.03.01-电商零售秒杀架构.md)

---

## 6. 性能概念定义

### 6.1 延迟（Latency）

**基本信息**：

- **英文名称**：Latency
- **缩写**：L
- **分类**：性能概念 - 核心性能指标
- **首次提出**：早期计算机系统
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
延迟是请求从发出到收到响应的时间间隔，是衡量系统响应速度的核心指标。延迟通常用毫秒（ms）或微秒（μs）表示。

**形式化定义**：

设请求发出时间为$t_{start}$，响应收到时间为$t_{end}$。

**延迟公式**：
$$L = t_{end} - t_{start}$$

**延迟分解**：
$$L = L_{network} + L_{kernel} + L_{redis} + L_{disk} + L_{other}$$

其中：

- $L_{network}$：网络延迟
- $L_{kernel}$：内核处理延迟
- $L_{redis}$：Redis处理延迟
- $L_{disk}$：磁盘IO延迟
- $L_{other}$：其他延迟

**关键属性**：

- **单位**：毫秒（ms）、微秒（μs）、纳秒（ns）
- **分位数**：P50（中位数）、P95、P99、P99.9等
- **分布特征**：长尾分布、右偏分布
- **优化目标**：降低P99延迟

**关系**：

- **组合关系**：
  - 由网络延迟、内核延迟、Redis延迟等组成
- **依赖关系**：
  - 依赖于：系统性能、网络性能、硬件性能

**应用案例**：

**案例1**：Redis延迟监控

- **场景**：Redis性能监控
- **应用方式**：使用LATENCY命令监控延迟
- **效果**：识别延迟异常，优化性能
- **参考**：[延迟分布建模](../05-全栈分析/05.06-系统动态特征/05.06.01-延迟分布建模.md)

**参考文档**：

- [延迟分布建模](../05-全栈分析/05.06-系统动态特征/05.06.01-延迟分布建模.md)
- [性能优化公式](../05-全栈分析/05.06-系统动态特征/05.06.05-性能优化公式.md)

---

### 6.2 吞吐量（Throughput）

**基本信息**：

- **英文名称**：Throughput
- **缩写**：T
- **分类**：性能概念 - 核心性能指标
- **首次提出**：早期计算机系统
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
吞吐量是系统在单位时间内处理的请求数量，通常用QPS（Queries Per Second）或TPS（Transactions Per Second）表示。

**形式化定义**：

设时间窗口为$\Delta t$，处理的请求数为$N$。

**吞吐量公式**：
$$T = \frac{N}{\Delta t}$$

**最大吞吐量（单线程）**：
$$T_{max} = \frac{1}{L_{avg}}$$

其中$L_{avg}$为平均延迟。

**多线程吞吐量**：
$$T_{multi} = T_{single} \times N_{threads} \times \eta_{efficiency}$$

其中$\eta_{efficiency}$为并行效率。

**关键属性**：

- **单位**：QPS（每秒查询数）、TPS（每秒事务数）
- **影响因素**：延迟、并发数、系统资源
- **优化目标**：提升QPS
- **瓶颈**：CPU、内存、网络、磁盘

**关系**：

- **依赖关系**：
  - 依赖于：延迟、并发数（Little定律）
- **权衡关系**：
  - 与延迟存在权衡（延迟越低，吞吐量越高）

**参考文档**：

- [性能优化公式](../05-全栈分析/05.06-系统动态特征/05.06.05-性能优化公式.md)
- [Little定律应用](../05-全栈分析/05.06-系统动态特征/05.06.02-Little定律应用.md)

---

### 6.3 命中率（Hit Rate）

**基本信息**：

- **英文名称**：Hit Rate / Cache Hit Ratio
- **缩写**：HR
- **分类**：性能概念 - 缓存性能指标
- **首次提出**：早期缓存系统
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
命中率是缓存命中次数占总请求次数的比例，是衡量缓存效果的核心指标。命中率越高，缓存效果越好。

**形式化定义**：

设命中次数为$N_{hits}$，总请求次数为$N_{total}$。

**命中率公式**：
$$H = \frac{N_{hits}}{N_{total}}$$

**未命中率**：
$$M = 1 - H = \frac{N_{misses}}{N_{total}}$$

**有效延迟**：
$$L_{effective} = H \times L_{cache} + (1-H) \times L_{miss}$$

其中：

- $L_{cache}$：缓存延迟
- $L_{miss}$：未命中延迟

**关键属性**：

- **取值范围**：$[0, 1]$（0-100%）
- **目标值**：通常>90%（高命中率）
- **影响因素**：缓存容量、替换算法、访问模式
- **优化目标**：提升命中率

**关系**：

- **依赖关系**：
  - 依赖于：缓存容量、替换算法、访问模式
- **影响关系**：
  - 影响有效延迟和系统性能

**参考文档**：

- [性能优化公式](../05-全栈分析/05.06-系统动态特征/05.06.05-性能优化公式.md)

---

### 6.4 抖动（Jitter）

**基本信息**：

- **英文名称**：Jitter
- **缩写**：J
- **分类**：性能概念 - 延迟变化指标
- **首次提出**：网络性能分析
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
抖动是延迟的变化程度，衡量延迟的稳定性。抖动越小，延迟越稳定，系统性能越可预测。

**形式化定义**：

设延迟序列为$L = \{L_1, L_2, ..., L_n\}$，平均延迟为$\bar{L}$。

**抖动定义**：
$$J = \sqrt{\frac{1}{n-1} \sum_{i=1}^{n} (L_i - \bar{L})^2}$$

即延迟的标准差。

**抖动来源**：
$$J = J_{CPU} + J_{memory} + J_{network} + J_{disk} + J_{GC}$$

其中：

- $J_{CPU}$：CPU调度抖动
- $J_{memory}$：内存分配抖动
- $J_{network}$：网络抖动
- $J_{disk}$：磁盘IO抖动
- $J_{GC}$：GC抖动

**关键属性**：

- **单位**：毫秒（ms）、微秒（μs）
- **目标值**：抖动<平均延迟的10%
- **影响因素**：系统负载、资源竞争、GC
- **优化目标**：降低抖动

**关系**：

- **组合关系**：
  - 由CPU抖动、内存抖动、网络抖动等组成
- **依赖关系**：
  - 依赖于：系统负载、资源竞争

**参考文档**：

- [抖动来源分析](../05-全栈分析/05.06-系统动态特征/05.06.04-抖动来源分析.md)

---

### 6.5 QPS（Queries Per Second）

**基本信息**：

- **英文名称**：Queries Per Second
- **缩写**：QPS
- **分类**：性能概念 - 吞吐量指标
- **首次提出**：数据库性能分析
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
QPS是每秒查询数，衡量系统处理查询的能力。QPS越高，系统处理能力越强。

**形式化定义**：

设时间窗口为$\Delta t = 1$秒，查询数为$N$。

**QPS公式**：
$$QPS = \frac{N}{\Delta t} = N$$

**QPS与延迟关系（Little定律）**：
$$QPS = \frac{1}{L_{avg}}$$

其中$L_{avg}$为平均延迟。

**关键属性**：

- **单位**：查询/秒（queries/second）
- **影响因素**：延迟、并发数、系统资源
- **优化目标**：提升QPS
- **瓶颈**：CPU、内存、网络

**关系**：

- **依赖关系**：
  - 依赖于：延迟（Little定律）
- **影响关系**：
  - 影响系统负载和资源使用

**参考文档**：

- [Little定律应用](../05-全栈分析/05.06-系统动态特征/05.06.02-Little定律应用.md)
- [性能优化公式](../05-全栈分析/05.06-系统动态特征/05.06.05-性能优化公式.md)

---

### 6.6 P99延迟（P99 Latency）

**基本信息**：

- **英文名称**：P99 Latency / 99th Percentile Latency
- **缩写**：P99
- **分类**：性能概念 - 延迟分位数指标
- **首次提出**：性能分析领域
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
P99延迟是99%的请求延迟小于该值的延迟阈值，是衡量系统延迟稳定性的关键指标。P99延迟通常比平均延迟更能反映用户体验。

**形式化定义**：

设延迟分布为$L = \{L_1, L_2, ..., L_n\}$，累积分布函数为$F(x)$。

**P99延迟定义**：
$$P99 = \inf\{x: F(x) \geq 0.99\}$$

即99%分位数。

**关键属性**：

- **单位**：毫秒（ms）、微秒（μs）
- **目标值**：通常<10ms（Web应用）
- **重要性**：比平均延迟更能反映用户体验
- **优化目标**：降低P99延迟

**关系**：

- **组合关系**：
  - 是延迟分布的分位数之一
- **依赖关系**：
  - 依赖于：延迟分布特征

**参考文档**：

- [延迟分布建模](../05-全栈分析/05.06-系统动态特征/05.06.01-延迟分布建模.md)

---

## 7. 一致性概念定义

### 7.1 强一致性（Strong Consistency）

**基本信息**：

- **英文名称**：Strong Consistency
- **缩写**：SC
- **分类**：一致性概念 - 一致性模型
- **首次提出**：分布式系统理论
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
强一致性是指所有节点在同一时刻看到相同的数据，任何读取操作都能立即看到最新的写入结果。强一致性保证数据的实时一致性。

**形式化定义**：

设系统有$n$个节点$N = \{N_1, N_2, ..., N_n\}$，数据项为$key$。

**强一致性定义**：
$$\forall N_i, N_j \in N, \forall t: N_i.read(key, t) = N_j.read(key, t)$$

即所有节点在同一时刻读取相同的数据。

**关键属性**：

- **一致性级别**：最高级别的一致性
- **性能影响**：强一致性通常需要同步操作，影响性能
- **适用场景**：金融支付、账户余额等强一致性要求场景
- **实现方式**：两阶段提交（2PC）、Paxos、Raft等

**关系**：

- **层次关系**：
  - 是一致性模型的最高级别
- **权衡关系**：
  - 与性能存在权衡（CAP定理）

**应用案例**：

**案例1**：金融支付系统

- **场景**：账户余额管理
- **应用方式**：使用Write-Through模式保证强一致性
- **效果**：保证数据一致性，但性能较低
- **参考**：[金融科技支付架构](../04-架构设计/04.03-行业应用场景/04.03.02-金融科技支付架构.md)

**参考文档**：

- [Write-Through透写缓存](../04-架构设计/04.01-缓存架构模式/04.01.03-Write-Through透写缓存.md)
- [金融科技支付架构](../04-架构设计/04.03-行业应用场景/04.03.02-金融科技支付架构.md)

---

### 7.2 最终一致性（Eventual Consistency）

**基本信息**：

- **英文名称**：Eventual Consistency
- **缩写**：EC
- **分类**：一致性概念 - 一致性模型
- **首次提出**：分布式系统理论
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
最终一致性是指系统在没有新的写入操作时，所有节点最终会达到一致的状态。最终一致性允许短暂的不一致，但保证最终一致性。

**形式化定义**：

设系统有$n$个节点$N = \{N_1, N_2, ..., N_n\}$，数据项为$key$。

**最终一致性定义**：
$$\lim_{t \to \infty} \forall N_i, N_j \in N: N_i.read(key, t) = N_j.read(key, t)$$

即在没有新写入时，所有节点最终读取相同的数据。

**关键属性**：

- **一致性级别**：较低级别的一致性
- **性能影响**：最终一致性允许异步操作，性能较高
- **适用场景**：社交网络、内容分发等可容忍短暂不一致的场景
- **实现方式**：异步复制、消息队列等

**关系**：

- **层次关系**：
  - 是一致性模型的较低级别
- **权衡关系**：
  - 与性能存在权衡（CAP定理）

**应用案例**：

**案例1**：社交网络Feed流

- **场景**：Feed流数据同步
- **应用方式**：使用最终一致性保证性能
- **效果**：性能高，但可能存在短暂不一致
- **参考**：[社交网络Feed流架构](../04-架构设计/04.03-行业应用场景/04.03.03-社交网络Feed流架构.md)

**参考文档**：

- [社交网络Feed流架构](../04-架构设计/04.03-行业应用场景/04.03.03-社交网络Feed流架构.md)

---

### 7.3 CAP定理（CAP Theorem）

**基本信息**：

- **英文名称**：CAP Theorem
- **缩写**：CAP
- **分类**：一致性概念 - 分布式系统理论
- **首次提出**：2000年，Eric Brewer
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
CAP定理指出，在分布式系统中，一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）三者不可兼得，最多只能同时满足两个。

**形式化定义**：

设系统的一致性为$C$，可用性为$A$，分区容错性为$P$。

**CAP定理**：
$$\neg(C \land A \land P)$$

即三者不能同时满足。

**系统选择**：

- **CP系统**：一致性+分区容错性（如Redis Cluster）
- **AP系统**：可用性+分区容错性（如Cassandra）
- **CA系统**：一致性+可用性（单机系统，不满足分区容错性）

**关键属性**：

- **一致性（C）**：所有节点看到相同的数据
- **可用性（A）**：系统持续可用
- **分区容错性（P）**：网络分区时系统仍可用
- **权衡**：需要根据业务需求选择

**关系**：

- **影响关系**：
  - 影响分布式系统设计选择
- **证明关系**：
  - 有形式化证明（见形式化分析理论模型）

**参考文档**：

- [形式化分析理论模型](./形式化分析理论模型.md)
- [Cluster集群模式](../03-Redis组件/03.03-高可用架构/03.03.03-Cluster集群模式.md)

---

### 7.4 ACID（原子性、一致性、隔离性、持久性）

**基本信息**：

- **英文名称**：Atomicity, Consistency, Isolation, Durability
- **缩写**：ACID
- **分类**：一致性概念 - 事务一致性模型
- **首次提出**：1983年，Theo Haerder, Andreas Reuter
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
ACID是数据库事务的四个特性，保证事务的可靠性和一致性。

**形式化定义**：

设事务为$T$，数据库状态为$S$。

**ACID特性**：

- **原子性（Atomicity）**：$T$要么全部执行，要么全部不执行
- **一致性（Consistency）**：$T$执行前后，数据库状态$S$保持一致
- **隔离性（Isolation）**：并发事务互不干扰
- **持久性（Durability）**：$T$提交后，数据永久保存

**关键属性**：

- **原子性**：事务的原子性保证
- **一致性**：数据一致性保证
- **隔离性**：事务隔离级别（Read Uncommitted、Read Committed、Repeatable Read、Serializable）
- **持久性**：数据持久化保证

**关系**：

- **组合关系**：
  - 由四个特性组成
- **依赖关系**：
  - 依赖于：事务管理、锁机制、持久化机制

**参考文档**：

- [金融科技支付架构](../04-架构设计/04.03-行业应用场景/04.03.02-金融科技支付架构.md)

---

### 7.5 BASE（基本可用、软状态、最终一致性）

**基本信息**：

- **英文名称**：Basically Available, Soft state, Eventual consistency
- **缩写**：BASE
- **分类**：一致性概念 - 分布式系统一致性模型
- **首次提出**：2008年，Dan Pritchett
- **当前版本**：v1.0

**定义**：

**自然语言定义**：
BASE是ACID的对立面，强调系统的可用性和最终一致性，而不是强一致性。BASE适用于大规模分布式系统。

**形式化定义**：

**BASE特性**：

- **基本可用（Basically Available）**：系统在部分故障时仍可用
- **软状态（Soft state）**：系统状态允许短暂不一致
- **最终一致性（Eventual consistency）**：系统最终达到一致状态

**关键属性**：

- **基本可用**：系统在部分故障时仍可用
- **软状态**：允许短暂不一致
- **最终一致性**：最终达到一致状态
- **适用场景**：大规模分布式系统、高可用系统

**关系**：

- **对比关系**：
  - 与ACID形成对比
- **权衡关系**：
  - 牺牲强一致性换取可用性

**参考文档**：

- [社交网络Feed流架构](../04-架构设计/04.03-行业应用场景/04.03.03-社交网络Feed流架构.md)

---

## 8. 参考文档

- [概念体系梳理计划](./概念体系梳理计划.md)
- [形式化分析理论模型](./形式化分析理论模型.md)
- [算法实现的数学证明](../01-理论基础/01.05-算法对比与决策/01.05.05-算法实现的数学证明.md)

---

**文档版本**：v1.0
**最后更新**：2025-01
**文档状态**：✅ 第一阶段完成（概念定义汇总）
**完成度**：

- 算法概念：13/15（87%，核心算法已完成）
- 数据结构概念：11/11（100%）
- 系统概念：8/8（100%）
- 架构概念：7/7（100%）
- 性能概念：6/6（100%）
- 一致性概念：5/5（100%）
- **总计：50个核心概念定义完成**
