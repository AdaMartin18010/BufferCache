# 01.01.02 LFU算法原理与实现

## 概述

LFU（Least Frequently Used，最不常用）算法基于"频率局部性"原理，淘汰访问频率最低的数据项。

## 核心原理

### 频率局部性原理

**定义**：访问频率高的数据在未来更可能被访问。

**数学表达**：
$$P(\text{未来访问} | \text{高频访问}) > P(\text{未来访问} | \text{低频访问})$$

### LFU算法思想

**淘汰策略**：当缓存空间不足时，淘汰访问频率最低的数据项。

**决策依据**：访问计数器，频率越低，越优先被淘汰。

## 数学模型

### 命中率公式

假设有$n$个数据项，访问频率为$f_1, f_2, ..., f_n$，则LFU命中率：

$$P_{LFU} = \frac{1}{1 + \sum_{i=1}^{n}\frac{1}{f_i}}$$

其中：

- $f_i$：第$i$个数据项的访问频率
- $n$：缓存中的数据项数量

### 频率衰减模型

为防止旧数据长期占用缓存，引入频率衰减：

$$f_i(t) = f_i(t_0) \times e^{-\lambda(t-t_0)}$$

其中：

- $\lambda$：衰减系数
- $t$：当前时间
- $t_0$：上次访问时间

## 实现结构

### 数据结构设计

```c
// LFU节点
typedef struct LFUNode {
    void *key;
    void *value;
    int frequency;                  // 访问频率
    time_t last_access;            // 最后访问时间
    struct LFUNode *prev;
    struct LFUNode *next;
} LFUNode;

// 频率桶（相同频率的节点）
typedef struct FrequencyBucket {
    int frequency;
    LFUNode *head;
    LFUNode *tail;
    struct FrequencyBucket *prev;
    struct FrequencyBucket *next;
} FrequencyBucket;

// LFU缓存结构
typedef struct LFUCache {
    int capacity;
    int size;
    FrequencyBucket *buckets;      // 频率桶链表
    HashTable *hash_table;          // key -> LFUNode*
} LFUCache;
```

### 核心操作实现

#### 1. 查找操作

```c
void* lfu_get(LFUCache *cache, void *key) {
    LFUNode *node = hash_table_get(cache->hash_table, key);
    if (node == NULL) {
        return NULL;
    }

    // 增加频率
    increment_frequency(cache, node);
    node->last_access = time(NULL);

    return node->value;
}

// 增加频率
void increment_frequency(LFUCache *cache, LFUNode *node) {
    FrequencyBucket *old_bucket = find_bucket(cache, node->frequency);
    FrequencyBucket *new_bucket = find_bucket(cache, node->frequency + 1);

    // 从旧桶移除
    remove_from_bucket(old_bucket, node);

    // 频率+1
    node->frequency++;

    // 添加到新桶
    if (new_bucket == NULL) {
        new_bucket = create_bucket(node->frequency);
        insert_bucket(cache, new_bucket);
    }
    add_to_bucket(new_bucket, node);
}
```

#### 2. 插入操作

```c
void lfu_put(LFUCache *cache, void *key, void *value) {
    LFUNode *node = hash_table_get(cache->hash_table, key);

    if (node != NULL) {
        // 已存在，更新值并增加频率
        node->value = value;
        increment_frequency(cache, node);
        node->last_access = time(NULL);
    } else {
        // 不存在，需要插入
        if (cache->size >= cache->capacity) {
            // 淘汰频率最低的节点
            FrequencyBucket *min_bucket = cache->buckets;
            LFUNode *evict_node = min_bucket->tail;
            remove_from_bucket(min_bucket, evict_node);
            hash_table_remove(cache->hash_table, evict_node->key);
            free(evict_node);
            cache->size--;
        }

        // 创建新节点（频率=1）
        node = create_node(key, value);
        node->frequency = 1;
        node->last_access = time(NULL);

        FrequencyBucket *bucket = find_bucket(cache, 1);
        if (bucket == NULL) {
            bucket = create_bucket(1);
            insert_bucket(cache, bucket);
        }
        add_to_bucket(bucket, node);

        hash_table_put(cache->hash_table, key, node);
        cache->size++;
    }
}
```

## Redis中的LFU实现

### Redis LFU字段

```c
// Redis中的LFU字段（24bit）
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS;  // 复用LRU字段存储LFU信息
    int refcount;
    void *ptr;
} robj;

// LFU字段编码（24bit）
// +--------+----------------+--------+
// | 16 bits|     8 bits     | 8 bits |
// +--------+----------------+--------+
// | decr   |      log       | counter|
// +--------+----------------+--------+
```

### 频率计数器

```c
// LFU计数器（8bit，0-255）
#define LFU_INIT_VAL 5

// 获取LFU计数器
uint8_t LFUGetTime(uint8_t counter) {
    unsigned long lru = (unsigned long)LFUGetTimeInMinutes();
    return (counter & 0xff) | ((unsigned)lru << 8);
}

// 增加LFU计数器
uint8_t LFULogIncr(uint8_t counter) {
    if (counter == 255) return 255;
    double r = (double)rand()/RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval < 0) baseval = 0;
    double p = 1.0/(baseval*server.lfu_log_factor+1);
    if (r < p) counter++;
    return counter;
}
```

**设计优势**：

- 8bit计数器：节省内存（vs 32bit整数）
- 对数增长：防止计数器快速溢出
- 概率递增：降低热点数据频率增长过快

## 适用场景

### 优势场景

1. **视频CDN缓存**
   - 热门视频访问频率高且稳定
   - LFU能准确识别热点内容

2. **新闻推荐系统**
   - 热点新闻访问频率高
   - LFU保持热点内容在缓存中

3. **API响应缓存**
   - 高频API调用结果缓存
   - LFU优先保留高频接口数据

### 劣势场景

1. **突发访问**
   - 新数据初始频率低，容易被淘汰
   - 建议使用LRU或ARC算法

2. **周期性访问**
   - 固定周期访问，频率相同
   - 建议结合时间信息

## 性能优化

### 1. 频率衰减优化

```c
// 定期衰减频率
void lfu_decay_frequencies(LFUCache *cache) {
    time_t now = time(NULL);
    double decay_factor = exp(-DECAY_RATE * (now - cache->last_decay));

    // 对所有节点应用衰减
    for_each_node(cache, node) {
        node->frequency *= decay_factor;
    }

    cache->last_decay = now;
}
```

### 2. 频率桶优化

```c
// 使用跳表优化频率桶查找
typedef struct LFUCache {
    SkipList *frequency_list;  // 频率 -> 桶的映射
    // ...
} LFUCache;
```

## 算法对比

详见：[多维概念矩阵对比](../../00-项目总览/多维概念矩阵对比.md#1-缓存替换算法全面对比矩阵)

## 扩展阅读

- [LRU算法原理与实现](./01.01.01-LRU算法原理与实现.md)
- [ARC自适应替换缓存](../01.02-高级替换算法/01.02.04-ARC自适应替换缓存.md)
- [Redis LFU实现](../../03-Redis组件/03.04-内存管理/03.04.02-内存淘汰策略.md)

## 权威参考

- **《算法导论》** - MIT Press
- **Redis源码** - <https://github.com/redis/redis>
- **LFU论文** - "An O(1) algorithm for implementing the LFU cache eviction scheme"
