# 01.01.03 FIFO算法原理与实现

## 概述

FIFO（First In First Out，先进先出）是最简单的缓存替换算法，按照数据进入缓存的顺序进行淘汰，最早进入的数据最先被淘汰。

## 核心思想

### 设计原则

1. **队列结构**：使用队列维护数据顺序
2. **先进先出**：最早进入的数据最先淘汰
3. **简单高效**：实现简单，O(1)时间复杂度

### 工作流程

```
新数据进入 → 添加到队列尾部 → 队列满时 → 淘汰队列头部数据
```

## 数据结构设计

### 队列实现

```c
// FIFO缓存结构
typedef struct FIFOCache {
    int capacity;              // 缓存容量
    int size;                  // 当前大小
    struct Node *head;         // 队列头
    struct Node *tail;         // 队列尾
    struct Node **hash;        // 哈希表（快速查找）
} FIFOCache;

// 节点结构
typedef struct Node {
    int key;
    int value;
    struct Node *next;         // 队列指针
    struct Node *prev;
} Node;
```

### 简化实现（仅队列）

```c
// 简化版：只使用队列
typedef struct FIFOCacheSimple {
    int capacity;
    int size;
    int *queue;                 // 循环队列
    int front;                  // 队头
    int rear;                   // 队尾
    int *values;                // 值数组
} FIFOCacheSimple;
```

## 核心操作

### 1. 初始化

```c
FIFOCache* fifoCreate(int capacity) {
    FIFOCache *cache = (FIFOCache *)malloc(sizeof(FIFOCache));
    cache->capacity = capacity;
    cache->size = 0;
    cache->head = NULL;
    cache->tail = NULL;
    cache->hash = (Node **)calloc(capacity, sizeof(Node *));
    return cache;
}
```

### 2. 查找操作

```c
int fifoGet(FIFOCache *cache, int key) {
    // 使用哈希表快速查找
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            return node->value;
        }
        node = node->next;
    }

    return -1;  // 未找到
}
```

**时间复杂度**：O(1)（平均情况）

### 3. 插入操作

```c
void fifoPut(FIFOCache *cache, int key, int value) {
    // 1. 检查是否已存在
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            // 更新值
            node->value = value;
            return;
        }
        node = node->next;
    }

    // 2. 如果缓存已满，淘汰队头
    if (cache->size >= cache->capacity) {
        Node *evict = cache->head;
        cache->head = evict->next;
        if (cache->head) {
            cache->head->prev = NULL;
        } else {
            cache->tail = NULL;
        }

        // 从哈希表删除
        int evict_index = evict->key % cache->capacity;
        Node **prev = &cache->hash[evict_index];
        while (*prev != evict) {
            prev = &(*prev)->next;
        }
        *prev = evict->next;

        free(evict);
        cache->size--;
    }

    // 3. 添加新节点到队尾
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->key = key;
    new_node->value = value;
    new_node->next = NULL;
    new_node->prev = cache->tail;

    if (cache->tail) {
        cache->tail->next = new_node;
    } else {
        cache->head = new_node;
    }
    cache->tail = new_node;

    // 添加到哈希表
    index = key % cache->capacity;
    new_node->next = cache->hash[index];
    cache->hash[index] = new_node;

    cache->size++;
}
```

**时间复杂度**：O(1)

## 简化实现（循环队列）

### 循环队列实现

```c
typedef struct FIFOCacheSimple {
    int capacity;
    int size;
    int *queue;                 // 循环队列（存储key）
    int front;
    int rear;
    int *values;                // 值数组
    int *exists;                // 存在标记
} FIFOCacheSimple;

FIFOCacheSimple* fifoCreateSimple(int capacity) {
    FIFOCacheSimple *cache = (FIFOCacheSimple *)malloc(sizeof(FIFOCacheSimple));
    cache->capacity = capacity;
    cache->size = 0;
    cache->queue = (int *)malloc(capacity * sizeof(int));
    cache->values = (int *)malloc(capacity * sizeof(int));
    cache->exists = (int *)calloc(capacity, sizeof(int));
    cache->front = 0;
    cache->rear = 0;
    return cache;
}

int fifoGetSimple(FIFOCacheSimple *cache, int key) {
    if (key < 0 || key >= cache->capacity || !cache->exists[key]) {
        return -1;
    }
    return cache->values[key];
}

void fifoPutSimple(FIFOCacheSimple *cache, int key, int value) {
    if (key < 0 || key >= cache->capacity) {
        return;
    }

    // 如果key已存在，更新值
    if (cache->exists[key]) {
        cache->values[key] = value;
        return;
    }

    // 如果缓存已满，淘汰队头
    if (cache->size >= cache->capacity) {
        int evict_key = cache->queue[cache->front];
        cache->exists[evict_key] = 0;
        cache->front = (cache->front + 1) % cache->capacity;
        cache->size--;
    }

    // 添加新key到队尾
    cache->queue[cache->rear] = key;
    cache->values[key] = value;
    cache->exists[key] = 1;
    cache->rear = (cache->rear + 1) % cache->capacity;
    cache->size++;
}
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **实现简单** | 代码量少，易于理解 |
| **时间复杂度** | O(1)的插入和删除 |
| **内存开销** | 内存占用小 |

### 劣势

| 特性 | 说明 |
|------|------|
| **命中率低** | 不考虑访问频率和时间局部性 |
| **不适合热点数据** | 可能淘汰热点数据 |

## 适用场景

### 优势场景

1. **简单场景**
   - 数据访问模式随机
   - 对命中率要求不高

2. **内存受限**
   - 需要极简实现
   - 内存占用要求严格

3. **临时缓存**
   - 数据生命周期短
   - 不需要复杂策略

### 不适用场景

1. **热点数据场景**
   - 有明显的时间局部性
   - 建议使用LRU

2. **高命中率要求**
   - 需要高缓存命中率
   - 建议使用LRU或LFU

## 与其他算法对比

### FIFO vs LRU

| 维度 | FIFO | LRU |
|------|------|-----|
| **实现复杂度** | 低 | 中 |
| **命中率** | 低 | 高 |
| **时间复杂度** | O(1) | O(1) |
| **适用场景** | 随机访问 | 时间局部性 |

### FIFO vs LFU

| 维度 | FIFO | LFU |
|------|------|-----|
| **实现复杂度** | 低 | 高 |
| **命中率** | 低 | 高 |
| **时间复杂度** | O(1) | O(logN) |
| **适用场景** | 随机访问 | 频率局部性 |

## 扩展阅读

- [LRU算法原理与实现](./01.01.01-LRU算法原理与实现.md)
- [LFU算法原理与实现](./01.01.02-LFU算法原理与实现.md)
- [算法对比与决策](../01.05-算法对比与决策/README.md)

## 权威参考

- **《算法导论》** - MIT Press
- **《数据结构与算法分析》** - Mark Allen Weiss
- **缓存替换算法论文** - "A Study of Replacement Algorithms for a Virtual-Storage Computer"
