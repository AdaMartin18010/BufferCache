# 01.01.03 FIFO算法原理与实现

## 目录

- [01.01.03 FIFO算法原理与实现](#010103-fifo算法原理与实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 核心思想](#2-核心思想)
    - [2.1 设计原则](#21-设计原则)
    - [2.2 工作流程](#22-工作流程)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数学模型与理论分析](#3-数学模型与理论分析)
    - [3.1 命中率模型](#31-命中率模型)
    - [3.2 复杂度分析](#32-复杂度分析)
      - [3.2.1 时间复杂度](#321-时间复杂度)
      - [3.2.2 空间复杂度](#322-空间复杂度)
  - [4. 数据结构设计](#4-数据结构设计)
    - [4.1 队列实现](#41-队列实现)
    - [4.2 简化实现（仅队列）](#42-简化实现仅队列)
  - [5. 核心操作](#5-核心操作)
    - [5.1 初始化](#51-初始化)
    - [5.2 查找操作](#52-查找操作)
    - [5.3 插入操作](#53-插入操作)
    - [5.4 淘汰操作](#54-淘汰操作)
  - [6. 性能分析](#6-性能分析)
    - [6.1 性能特征](#61-性能特征)
      - [6.1.1 优势](#611-优势)
      - [6.1.2 劣势](#612-劣势)
    - [6.2 简化实现（循环队列）](#62-简化实现循环队列)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 算法对比](#8-算法对比)
  - [9. 程序设计分析](#9-程序设计分析)
    - [9.1 设计模式应用](#91-设计模式应用)
    - [9.2 代码结构分析](#92-代码结构分析)
    - [9.3 设计权衡](#93-设计权衡)
    - [9.4 可扩展性分析](#94-可扩展性分析)
  - [10. 扩展阅读](#10-扩展阅读)
  - [11. 权威参考](#11-权威参考)
    - [11.1 学术论文](#111-学术论文)
    - [11.2 经典书籍](#112-经典书籍)
    - [11.3 在线资源](#113-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**FIFO（First In First Out，先进先出）**是最简单的缓存替换算法，按照数据进入缓存的顺序进行淘汰，最早进入的数据最先被淘汰。

**历史发展**：

- **1960年代**：FIFO算法在操作系统页面置换中应用
- **1970年代**：FIFO在数据库缓存系统中应用
- **1980年代**：FIFO成为最简单的缓存替换算法
- **2020年代**：FIFO仍被用于简单场景和教学示例

### 1.2 应用价值

FIFO算法在以下场景中具有价值：

1. **简单场景**：对性能要求不高的简单缓存
2. **教学示例**：作为缓存替换算法的入门示例
3. **特殊应用**：某些特殊场景下FIFO表现良好

## 2. 核心思想

### 2.1 设计原则

1. **队列结构**：使用队列维护数据顺序
2. **先进先出**：最早进入的数据最先淘汰
3. **简单高效**：实现简单，O(1)时间复杂度

### 2.2 工作流程

```
新数据进入 → 添加到队列尾部 → 队列满时 → 淘汰队列头部数据
```

### 2.3 形式化定义

设缓存容量为$k$，访问序列为$\sigma = r_1, r_2, ..., r_n$。

**FIFO算法形式化定义**：

对于每次访问$r_i$：

- 如果$r_i$在缓存中：保持缓存不变
- 如果$r_i$不在缓存中且缓存未满：将$r_i$加入队列尾部
- 如果$r_i$不在缓存中且缓存已满：淘汰队列头部数据，将$r_i$加入队列尾部

## 3. 数学模型与理论分析

### 3.1 命中率模型

**FIFO命中率分析**：

对于独立引用模型（IRM），FIFO的命中率：

$$H_{FIFO}(k) = \sum_{i=1}^{n} p_i \cdot I_i(k)$$

其中$I_i(k)$表示数据项$i$在缓存中的指示函数。

**定理 3.1**：FIFO算法的竞争比为$k$，其中$k$为缓存容量。

**证明**：

- 最优算法（OPT）可以预知未来访问
- FIFO在最坏情况下，每次访问都导致缺失
- 竞争比：$\frac{\text{FIFO缺失次数}}{\text{OPT缺失次数}} \leq k$

### 3.2 复杂度分析

#### 3.2.1 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **查找** | O(1) | 哈希表查找 |
| **插入** | O(1) | 队列尾部插入 |
| **淘汰** | O(1) | 队列头部删除 |

#### 3.2.2 空间复杂度

- **队列**：O(k)，存储k个数据项
- **哈希表**：O(k)，存储k个键值对
- **总空间复杂度**：O(k)

## 4. 数据结构设计

### 4.1 队列实现

```c
// FIFO缓存结构
typedef struct FIFOCache {
    int capacity;              // 缓存容量
    int size;                  // 当前大小
    struct Node *head;         // 队列头
    struct Node *tail;         // 队列尾
    struct Node **hash;        // 哈希表（快速查找）
} FIFOCache;

// 节点结构
typedef struct Node {
    int key;
    int value;
    struct Node *next;         // 队列指针
    struct Node *prev;
} Node;
```

### 4.2 简化实现（仅队列）

```c
// 简化版：只使用队列
typedef struct FIFOCacheSimple {
    int capacity;
    int size;
    int *queue;                 // 循环队列
    int front;                  // 队头
    int rear;                   // 队尾
    int *values;                // 值数组
} FIFOCacheSimple;
```

## 5. 核心操作

### 5.1 初始化

```c
FIFOCache* fifoCreate(int capacity) {
    FIFOCache *cache = (FIFOCache *)malloc(sizeof(FIFOCache));
    cache->capacity = capacity;
    cache->size = 0;
    cache->head = NULL;
    cache->tail = NULL;
    cache->hash = (Node **)calloc(capacity, sizeof(Node *));
    return cache;
}
```

### 5.2 查找操作

```c
int fifoGet(FIFOCache *cache, int key) {
    // 使用哈希表快速查找
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            return node->value;
        }
        node = node->next;
    }

    return -1;  // 未找到
}
```

**时间复杂度**：O(1)（平均情况）

### 5.3 插入操作

```c
void fifoPut(FIFOCache *cache, int key, int value) {
    // 1. 检查是否已存在
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            // 更新值
            node->value = value;
            return;
        }
        node = node->next;
    }

    // 2. 如果缓存已满，淘汰队头
    if (cache->size >= cache->capacity) {
        Node *evict = cache->head;
        cache->head = evict->next;
        if (cache->head) {
            cache->head->prev = NULL;
        } else {
            cache->tail = NULL;
        }

        // 从哈希表删除
        int evict_index = evict->key % cache->capacity;
        Node **prev = &cache->hash[evict_index];
        while (*prev != evict) {
            prev = &(*prev)->next;
        }
        *prev = evict->next;

        free(evict);
        cache->size--;
    }

    // 3. 添加新节点到队尾
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->key = key;
    new_node->value = value;
    new_node->next = NULL;
    new_node->prev = cache->tail;

    if (cache->tail) {
        cache->tail->next = new_node;
    } else {
        cache->head = new_node;
    }
    cache->tail = new_node;

    // 添加到哈希表
    index = key % cache->capacity;
    new_node->next = cache->hash[index];
    cache->hash[index] = new_node;

    cache->size++;
}
```

**时间复杂度**：O(1)

### 5.4 淘汰操作

**淘汰策略**：当缓存满时，淘汰队列头部的数据（最早进入的数据）。

## 6. 性能分析

### 6.1 性能特征

#### 6.1.1 优势

| 特性 | 说明 |
|------|------|
| **实现简单** | 代码量少，易于理解 |
| **时间复杂度** | O(1)的插入和删除 |
| **内存开销** | 内存占用小 |

#### 6.1.2 劣势

| 特性 | 说明 |
|------|------|
| **命中率低** | 不考虑访问频率和时间局部性 |
| **不适合热点数据** | 可能淘汰热点数据 |

### 6.2 简化实现（循环队列）

**循环队列实现**

```c
typedef struct FIFOCacheSimple {
    int capacity;
    int size;
    int *queue;                 // 循环队列（存储key）
    int front;
    int rear;
    int *values;                // 值数组
    int *exists;                // 存在标记
} FIFOCacheSimple;

FIFOCacheSimple* fifoCreateSimple(int capacity) {
    FIFOCacheSimple *cache = (FIFOCacheSimple *)malloc(sizeof(FIFOCacheSimple));
    cache->capacity = capacity;
    cache->size = 0;
    cache->queue = (int *)malloc(capacity * sizeof(int));
    cache->values = (int *)malloc(capacity * sizeof(int));
    cache->exists = (int *)calloc(capacity, sizeof(int));
    cache->front = 0;
    cache->rear = 0;
    return cache;
}

int fifoGetSimple(FIFOCacheSimple *cache, int key) {
    if (key < 0 || key >= cache->capacity || !cache->exists[key]) {
        return -1;
    }
    return cache->values[key];
}

void fifoPutSimple(FIFOCacheSimple *cache, int key, int value) {
    if (key < 0 || key >= cache->capacity) {
        return;
    }

    // 如果key已存在，更新值
    if (cache->exists[key]) {
        cache->values[key] = value;
        return;
    }

    // 如果缓存已满，淘汰队头
    if (cache->size >= cache->capacity) {
        int evict_key = cache->queue[cache->front];
        cache->exists[evict_key] = 0;
        cache->front = (cache->front + 1) % cache->capacity;
        cache->size--;
    }

    // 添加新key到队尾
    cache->queue[cache->rear] = key;
    cache->values[key] = value;
    cache->exists[key] = 1;
    cache->rear = (cache->rear + 1) % cache->capacity;
    cache->size++;
}
```

## 7. 适用场景

### 7.1 优势场景

1. **简单场景**
   - 数据访问模式随机
   - 对命中率要求不高

2. **内存受限**
   - 需要极简实现
   - 内存占用要求严格

3. **临时缓存**
   - 数据生命周期短
   - 不需要复杂策略

### 7.2 不适用场景

1. **热点数据场景**
   - 有明显的时间局部性
   - 建议使用LRU

2. **高命中率要求**
   - 需要高缓存命中率
   - 建议使用LRU或LFU

## 8. 算法对比

详见：[多维概念矩阵对比](../../00-项目总览/多维概念矩阵对比.md#1-缓存替换算法全面对比矩阵)

## 9. 程序设计分析

### 9.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：FIFO算法作为缓存替换策略的一种实现
2. **队列模式**：使用队列数据结构实现FIFO语义
3. **模板方法模式**：定义缓存操作的基本流程

**策略模式实现**：

```c
// 缓存替换策略接口
typedef struct cache_replacement_strategy {
    void (*on_access)(Cache *cache, void *key);
    void (*on_evict)(Cache *cache);
    const char *name;
} CacheReplacementStrategy;

// FIFO策略实现
CacheReplacementStrategy fifo_strategy = {
    .on_access = fifo_on_access,
    .on_evict = fifo_evict,
    .name = "FIFO"
};
```

### 9.2 代码结构分析

**代码组织**：

1. **数据结构层**：队列结构定义
2. **算法层**：FIFO核心操作（插入、淘汰）
3. **接口层**：对外提供的缓存操作接口

**模块化设计**：

- **高内聚**：FIFO相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的替换策略

### 9.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 准确性** | 简单FIFO | 实现简单，性能高 |
| **简单 vs 复杂** | 队列实现 | 最简单的实现 |
| **通用 vs 专用** | 通用FIFO实现 | 适用顺序访问场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{memory} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（O(1)插入，O(1)淘汰）
- $C_{memory}$：内存成本（队列结构）
- $C_{complexity}$：复杂度成本（实现最简单）

### 9.4 可扩展性分析

**扩展点**：

1. **新替换策略**：可扩展为其他替换策略
2. **新队列实现**：可扩展为其他队列实现
3. **分布式FIFO**：可扩展为分布式FIFO实现

**扩展性设计**：

```c
// 可扩展的缓存接口
typedef struct cache {
    CacheReplacementStrategy *strategy;
    void *data_structure;
    int (*get)(struct cache *cache, void *key);
    int (*put)(struct cache *cache, void *key, void *value);
} Cache;
```

**可维护性**：

- **代码清晰**：FIFO逻辑清晰，易于理解
- **易于调试**：队列状态易于监控和调试
- **测试友好**：FIFO行为易于测试和验证

## 10. 扩展阅读

- [LRU算法原理与实现](./01.01.01-LRU算法原理与实现.md)
- [LFU算法原理与实现](./01.01.02-LFU算法原理与实现.md)
- [算法对比与决策](../01.05-算法对比与决策/README.md)

## 11. 权威参考

### 11.1 学术论文

1. **"A Study of Replacement Algorithms for a Virtual-Storage Computer"** - Belady, L. A., IBM Systems Journal, 1966
   - FIFO算法的经典论文
   - DOI: 10.1147/sj.52.0078
   - 首次提出FIFO页面置换算法

2. **"The Working Set Model for Program Behavior"** - Denning, P. J., Communications of the ACM, 1968
   - 工作集模型，分析FIFO等算法的性能
   - DOI: 10.1145/363095.363141

### 11.2 经典书籍

1. **《算法导论（第3版）》** - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
   - 出版社: MIT Press
   - ISBN: 978-0262033848
   - 第16章：贪心算法（包含缓存替换算法）

2. **《数据结构与算法分析：C语言描述（第2版）》** - Mark Allen Weiss
   - 出版社: 机械工业出版社
   - ISBN: 978-7111407010
   - 第3章：表、栈和队列（FIFO队列实现）

### 11.3 在线资源

1. **Wikipedia - FIFO**
   - URL: <https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)>
   - 提供FIFO的详细说明

2. **GeeksforGeeks - FIFO Cache Implementation**
   - URL: <https://www.geeksforgeeks.org/fifo-cache-implementation/>
   - 提供FIFO缓存的实现示例
