# 01.01.04 MRU算法原理与实现

## 目录

- [01.01.04 MRU算法原理与实现](#010104-mru算法原理与实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 核心思想](#2-核心思想)
    - [2.1 设计原则](#21-设计原则)
    - [2.2 工作流程](#22-工作流程)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数学模型与理论分析](#3-数学模型与理论分析)
    - [3.1 命中率模型](#31-命中率模型)
    - [3.2 复杂度分析](#32-复杂度分析)
      - [3.2.1 时间复杂度](#321-时间复杂度)
      - [3.2.2 空间复杂度](#322-空间复杂度)
  - [4. 数据结构设计](#4-数据结构设计)
    - [队列实现](#队列实现)
  - [5. 核心操作](#5-核心操作)
    - [5.1 查找操作](#51-查找操作)
    - [5.2 插入操作](#52-插入操作)
  - [6. 性能分析](#6-性能分析)
    - [6.1 性能特征](#61-性能特征)
      - [6.1.1 优势](#611-优势)
      - [6.1.2 劣势](#612-劣势)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 算法对比](#8-算法对比)
  - [9. 扩展阅读](#9-扩展阅读)
  - [10. 权威参考](#10-权威参考)
    - [10.1 学术论文](#101-学术论文)
    - [10.2 经典书籍](#102-经典书籍)
    - [10.3 在线资源](#103-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**MRU（Most Recently Used，最近使用）**是LRU的反向算法，优先淘汰最近使用的数据。MRU适用于某些特殊场景，如扫描模式访问。

**历史发展**：

- **1970年代**：MRU在数据库缓存研究中提出
- **1980年代**：MRU在顺序扫描场景中应用
- **1990年代**：MRU在某些特殊缓存场景中应用
- **2020年代**：MRU主要用于特殊场景和教学示例

### 1.2 应用价值

MRU算法在以下场景中具有价值：

1. **顺序扫描**：顺序访问数据，最近访问的数据不会再被访问
2. **教学示例**：作为LRU的反向示例
3. **特殊应用**：某些特殊场景下MRU表现良好

## 2. 核心思想

### 2.1 设计原则

1. **反向LRU**：与LRU相反，淘汰最近使用的数据
2. **扫描模式**：适用于顺序扫描场景
3. **简单实现**：实现简单，O(1)时间复杂度

### 2.2 工作流程

```text
新数据进入 → 添加到队列头部 → 队列满时 → 淘汰队列头部数据（最近使用的）
```

### 2.3 形式化定义

设缓存容量为$k$，访问序列为$\sigma = r_1, r_2, ..., r_n$。

**MRU算法形式化定义**：

对于每次访问$r_i$：

- 如果$r_i$在缓存中：将$r_i$移动到队列头部（标记为最近使用）
- 如果$r_i$不在缓存中且缓存未满：将$r_i$加入队列头部
- 如果$r_i$不在缓存中且缓存已满：淘汰队列头部数据（最近使用的），将$r_i$加入队列头部

## 3. 数学模型与理论分析

### 3.1 命中率模型

**MRU命中率分析**：

对于顺序扫描模式，MRU的命中率：

$$
H_{MRU}(k) = \begin{cases}
0 & \text{如果访问模式是严格顺序扫描} \\
\frac{k-1}{n} & \text{如果访问模式是部分顺序扫描}
\end{cases}
$$

**定理 3.1**：对于严格顺序扫描模式，MRU的命中率为0。

**证明**：

- 顺序扫描：$r_1, r_2, ..., r_n$，每个数据只访问一次
- MRU淘汰最近使用的数据
- 因此，已访问的数据会被立即淘汰
- 命中率：$H_{MRU} = 0$

### 3.2 复杂度分析

#### 3.2.1 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **查找** | O(1) | 哈希表查找 |
| **插入** | O(1) | 队列头部插入 |
| **淘汰** | O(1) | 队列头部删除 |

#### 3.2.2 空间复杂度

- **队列**：O(k)，存储k个数据项
- **哈希表**：O(k)，存储k个键值对
- **总空间复杂度**：O(k)

## 4. 数据结构设计

### 队列实现

```c
// MRU缓存结构（与LRU类似，但淘汰策略相反）
typedef struct MRUCache {
    int capacity;
    int size;
    struct Node *head;  // 队列头（最近使用）
    struct Node *tail;  // 队列尾（最久使用）
    struct Node **hash; // 哈希表（快速查找）
} MRUCache;

// 节点结构
typedef struct Node {
    int key;
    int value;
    struct Node *next;
    struct Node *prev;
} Node;
```

## 5. 核心操作

### 5.1 查找操作

```c
int mruGet(MRUCache *cache, int key) {
    // 1. 查找节点
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            // 2. 移动到头部（标记为最近使用）
            moveToHead(cache, node);
            return node->value;
        }
        node = node->next;
    }

    return -1;
}
```

### 5.2 插入操作

```c
void mruPut(MRUCache *cache, int key, int value) {
    // 1. 检查是否已存在
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            // 更新值并移动到头部
            node->value = value;
            moveToHead(cache, node);
            return;
        }
        node = node->next;
    }

    // 2. 如果缓存已满，淘汰头部（最近使用的）
    if (cache->size >= cache->capacity) {
        Node *evict = cache->head;
        cache->head = evict->next;
        if (cache->head) {
            cache->head->prev = NULL;
        } else {
            cache->tail = NULL;
        }

        // 从哈希表删除
        int evict_index = evict->key % cache->capacity;
        Node **prev = &cache->hash[evict_index];
        while (*prev != evict) {
            prev = &(*prev)->next;
        }
        *prev = evict->next;

        free(evict);
        cache->size--;
    }

    // 3. 添加新节点到头部
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->key = key;
    new_node->value = value;
    new_node->next = cache->head;
    new_node->prev = NULL;

    if (cache->head) {
        cache->head->prev = new_node;
    } else {
        cache->tail = new_node;
    }
    cache->head = new_node;

    // 添加到哈希表
    index = key % cache->capacity;
    new_node->next = cache->hash[index];
    cache->hash[index] = new_node;

    cache->size++;
}
```

## 6. 性能分析

### 6.1 性能特征

#### 6.1.1 优势

| 特性 | 说明 |
|------|------|
| **扫描模式** | 适合顺序扫描场景 |
| **实现简单** | 代码量少 |
| **时间复杂度** | O(1) |

#### 6.1.2 劣势

| 特性 | 说明 |
|------|------|
| **通用性差** | 只适用于特殊场景 |
| **命中率低** | 大多数场景命中率低 |

## 7. 适用场景

### 7.1 优势场景

1. **顺序扫描**
   - 数据按顺序访问
   - 访问过的数据不再访问
   - MRU可以提前淘汰

2. **循环访问**
   - 数据循环访问
   - 最近访问的数据不会立即再访问
   - MRU可以保留更久未访问的数据

3. **反向时间局部性**
   - 访问模式与时间局部性相反
   - 最近访问的数据不会再次访问

### 7.2 不适用场景

1. **时间局部性强的场景**：建议使用LRU
2. **频率局部性强的场景**：建议使用LFU

## 8. 算法对比

详见：[多维概念矩阵对比](../../00-项目总览/多维概念矩阵对比.md#1-缓存替换算法全面对比矩阵)

## 9. 扩展阅读

- [LRU算法原理与实现](./01.01.01-LRU算法原理与实现.md)
- [FIFO算法原理与实现](./01.01.03-FIFO算法原理与实现.md)
- [算法对比与决策](../01.05-算法对比与决策/README.md)

## 10. 权威参考

### 10.1 学术论文

1. **"A Study of Replacement Algorithms for a Virtual-Storage Computer"** - Belady, L. A., IBM Systems Journal, 1966
   - 缓存替换算法的经典论文
   - DOI: 10.1147/sj.52.0078
   - 分析了包括MRU在内的多种替换算法

### 10.2 经典书籍

1. **《算法导论（第3版）》** - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
   - 出版社: MIT Press
   - ISBN: 978-0262033848
   - 第16章：贪心算法（包含缓存替换算法）

2. **《数据结构与算法分析：C语言描述（第2版）》** - Mark Allen Weiss
   - 出版社: 机械工业出版社
   - ISBN: 978-7111407010
   - 第3章：表、栈和队列（队列实现）

### 10.3 在线资源

1. **Wikipedia - Cache Replacement Policies**
   - URL: <https://en.wikipedia.org/wiki/Cache_replacement_policies>
   - 提供缓存替换算法的详细说明
