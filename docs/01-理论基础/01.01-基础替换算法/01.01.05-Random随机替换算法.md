# 01.01.05 Random随机替换算法

## 概述

Random（随机替换）是最简单的缓存替换算法，随机选择数据进行淘汰。虽然简单，但在某些场景下表现良好。

## 核心思想

### 设计原则

1. **随机选择**：随机选择数据进行淘汰
2. **简单实现**：实现最简单，O(1)时间复杂度
3. **无状态**：不需要维护任何状态信息

### 工作流程

```
新数据进入 → 缓存满时 → 随机选择一个数据淘汰 → 插入新数据
```

## 数据结构设计

### 简化实现

```c
// Random缓存结构
typedef struct RandomCache {
    int capacity;
    int size;
    int *keys;      // 键数组
    int *values;    // 值数组
    int *exists;    // 存在标记
} RandomCache;
```

### 哈希表实现

```c
// Random缓存结构（使用哈希表）
typedef struct RandomCache {
    int capacity;
    int size;
    struct Node **hash;  // 哈希表
    struct Node **array; // 数组（用于随机选择）
} RandomCache;

// 节点结构
typedef struct Node {
    int key;
    int value;
    struct Node *next;
} Node;
```

## 核心操作

### 1. 初始化

```c
RandomCache* randomCreate(int capacity) {
    RandomCache *cache = (RandomCache *)malloc(sizeof(RandomCache));
    cache->capacity = capacity;
    cache->size = 0;
    cache->hash = (Node **)calloc(capacity, sizeof(Node *));
    cache->array = (Node **)malloc(capacity * sizeof(Node *));
    return cache;
}
```

### 2. 查找操作

```c
int randomGet(RandomCache *cache, int key) {
    // 使用哈希表快速查找
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            return node->value;
        }
        node = node->next;
    }

    return -1;
}
```

**时间复杂度**：O(1)（平均情况）

### 3. 插入操作

```c
void randomPut(RandomCache *cache, int key, int value) {
    // 1. 检查是否已存在
    int index = key % cache->capacity;
    Node *node = cache->hash[index];

    while (node) {
        if (node->key == key) {
            // 更新值
            node->value = value;
            return;
        }
        node = node->next;
    }

    // 2. 如果缓存已满，随机淘汰一个
    if (cache->size >= cache->capacity) {
        // 随机选择一个节点淘汰
        int random_index = rand() % cache->size;
        Node *evict = cache->array[random_index];

        // 从哈希表删除
        int evict_index = evict->key % cache->capacity;
        Node **prev = &cache->hash[evict_index];
        while (*prev != evict) {
            prev = &(*prev)->next;
        }
        *prev = evict->next;

        // 从数组删除（用最后一个元素替换）
        cache->array[random_index] = cache->array[cache->size - 1];

        free(evict);
        cache->size--;
    }

    // 3. 添加新节点
    Node *new_node = (Node *)malloc(sizeof(Node));
    new_node->key = key;
    new_node->value = value;
    new_node->next = cache->hash[index];
    cache->hash[index] = new_node;

    // 添加到数组
    cache->array[cache->size] = new_node;
    cache->size++;
}
```

**时间复杂度**：O(1)

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **实现简单** | 代码量最少 |
| **时间复杂度** | O(1) |
| **无状态** | 不需要维护状态 |
| **内存开销** | 最小 |

### 劣势

| 特性 | 说明 |
|------|------|
| **命中率低** | 不考虑任何访问模式 |
| **不可预测** | 淘汰结果不可预测 |

## 适用场景

### 优势场景

1. **完全随机访问**
   - 数据访问完全随机
   - 无任何访问模式

2. **简单场景**
   - 对命中率要求不高
   - 需要极简实现

3. **测试场景**
   - 作为基准测试
   - 对比其他算法

### 不适用场景

1. **有明显访问模式**
   - 有时间局部性：建议LRU
   - 有频率局部性：建议LFU

2. **高命中率要求**
   - 需要高缓存命中率
   - 建议LRU或LFU

## 性能分析

### 命中率

```
完全随机访问：
- Random命中率：~50%（缓存大小/总数据量）
- LRU命中率：~50%（相同）
- LFU命中率：~50%（相同）

结论：完全随机访问时，Random与LRU/LFU性能相同
```

### 时间复杂度

```
Random：O(1)
LRU：O(1)
LFU：O(logN)

结论：Random时间复杂度最优
```

## 与其他算法对比

### Random vs LRU

| 维度 | Random | LRU |
|------|--------|-----|
| **实现复杂度** | 最低 | 低 |
| **命中率** | 随机访问时相同 | 时间局部性时高 |
| **时间复杂度** | O(1) | O(1) |
| **适用场景** | 完全随机 | 时间局部性 |

### Random vs FIFO

| 维度 | Random | FIFO |
|------|--------|------|
| **实现复杂度** | 最低 | 低 |
| **命中率** | 相同 | 相同 |
| **时间复杂度** | O(1) | O(1) |
| **适用场景** | 完全随机 | 完全随机 |

## Redis中的应用

### Random淘汰策略

```c
// Redis支持Random淘汰策略
// maxmemory-policy allkeys-random
// maxmemory-policy volatile-random

// 实现：随机采样N个key，淘汰其中一个
int freeMemoryIfNeeded(void) {
    // ...

    if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||
        server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM) {

        // 随机采样
        for (int k = 0; k < server.maxmemory_samples; k++) {
            dictEntry *de = dictGetRandomKey(sampledict);
            // 淘汰
        }
    }

    // ...
}
```

## 扩展阅读

- [LRU算法原理与实现](./01.01.01-LRU算法原理与实现.md)
- [FIFO算法原理与实现](./01.01.03-FIFO算法原理与实现.md)
- [算法对比与决策](../01.05-算法对比与决策/README.md)

## 权威参考

- **《算法导论》** - MIT Press
- **《数据结构与算法分析》** - Mark Allen Weiss
- **缓存替换算法论文** - "A Study of Replacement Algorithms"
