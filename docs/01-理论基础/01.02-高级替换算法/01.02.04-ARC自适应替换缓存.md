# 01.02.04 ARC自适应替换缓存

## 概述

ARC（Adaptive Replacement Cache，自适应替换缓存）是IBM Almaden研究中心开发的高级缓存替换算法，能够自动适应工作负载变化，无需手动调参。

## 核心思想

### 设计理念

ARC同时跟踪**LRU**和**LFU**两个列表，根据工作负载特征动态调整两个列表的大小，实现自适应优化。

### 关键创新

1. **双列表机制**：同时维护LRU和LFU列表
2. **自适应调整**：根据命中率动态调整列表大小
3. **幽灵条目**：记录被淘汰的key，用于预测未来访问

## 数据结构设计

### 四个列表

```c
// ARC缓存结构
typedef struct ARCCache {
    int capacity;                    // 缓存容量

    // T1: 最近访问的LRU列表
    LRUList *T1;

    // T2: 频繁访问的LFU列表
    LFUList *T2;

    // B1: T1的幽灵条目（最近被淘汰）
    GhostList *B1;

    // B2: T2的幽灵条目（频繁访问后被淘汰）
    GhostList *B2;

    int p;                          // 自适应参数：T1的目标大小
} ARCCache;
```

### 列表关系

```text
┌─────────────────────────────────────┐
│         ARC缓存 (容量C)              │
├─────────────────────────────────────┤
│  T1 (LRU)    │  T2 (LFU)            │
│  最近访问     │  频繁访问             │
├─────────────────────────────────────┤
│  B1 (Ghost)  │  B2 (Ghost)          │
│  T1淘汰记录   │  T2淘汰记录          │
└─────────────────────────────────────┘

约束：|T1| + |T2| = C
      |T1| + |B1| + |T2| + |B2| ≤ 2C
```

## 核心算法

### 自适应参数p

**p的含义**：T1列表的目标大小

**调整规则**：

- 如果B1命中（在B1中找到key）：增加p，扩大T1
- 如果B2命中（在B2中找到key）：减少p，扩大T2
- 如果T1或T2命中：不调整p

### 查找操作

```c
void* arc_get(ARCCache *cache, void *key) {
    // 1. 在T1中查找
    if (lru_list_contains(cache->T1, key)) {
        // T1命中：移动到T2
        move_to_T2(cache, key);
        return get_value(key);
    }

    // 2. 在T2中查找
    if (lfu_list_contains(cache->T2, key)) {
        // T2命中：增加频率
        increment_frequency(cache->T2, key);
        return get_value(key);
    }

    // 3. 在B1中查找（幽灵命中）
    if (ghost_list_contains(cache->B1, key)) {
        // B1命中：增加p，将key移到T2
        cache->p = min(cache->capacity, cache->p +
                      max(1, |B2| / |B1|));
        replace(cache);
        move_to_T2(cache, key);
        return get_value(key);
    }

    // 4. 在B2中查找（幽灵命中）
    if (ghost_list_contains(cache->B2, key)) {
        // B2命中：减少p，将key移到T2
        cache->p = max(0, cache->p -
                      max(1, |B1| / |B2|));
        replace(cache);
        move_to_T2(cache, key);
        return get_value(key);
    }

    // 5. 缓存未命中
    return NULL;
}
```

### 插入操作

```c
void arc_put(ARCCache *cache, void *key, void *value) {
    // 如果已存在，更新即可
    if (arc_get(cache, key) != NULL) {
        update_value(key, value);
        return;
    }

    // 新key插入
    if (cache->T1->size + cache->T2->size >= cache->capacity) {
        // 缓存已满，需要淘汰
        replace(cache);
    }

    // 插入到T1
    lru_list_add_head(cache->T1, key, value);
}

// 替换策略
void replace(ARCCache *cache) {
    // 情况1: T1大小超过目标p
    if (cache->T1->size > 0 &&
        (cache->T1->size > cache->p ||
         (cache->B2->size > cache->B1->size &&
          cache->T1->size == cache->p))) {
        // 淘汰T1尾部，移到B1
        void *evict_key = lru_list_remove_tail(cache->T1);
        ghost_list_add_head(cache->B1, evict_key);
    } else {
        // 淘汰T2尾部，移到B2
        void *evict_key = lfu_list_remove_tail(cache->T2);
        ghost_list_add_head(cache->B2, evict_key);
    }
}
```

## 自适应机制证明

### 数学证明

**定理**：ARC算法能够自动适应工作负载，使命中率接近最优。

**证明思路**：

1. **B1命中增加p**：
   - B1命中说明最近访问模式重要
   - 增加p扩大T1，提升LRU效果

2. **B2命中减少p**：
   - B2命中说明频繁访问模式重要
   - 减少p扩大T2，提升LFU效果

3. **收敛性**：
   - p在[0, C]范围内调整
   - 当|B1| ≈ |B2|时，p趋于稳定
   - 此时命中率接近最优

**QED**

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **自适应** | 无需手动调参，自动适应工作负载 |
| **高命中率** | 接近最优算法性能 |
| **低开销** | O(1)时间复杂度 |
| **通用性** | 适用于各种访问模式 |

### 劣势

| 特性 | 说明 |
|------|------|
| **内存开销** | 需要维护4个列表，内存占用较高 |
| **实现复杂** | 逻辑复杂，调试困难 |
| **幽灵条目** | 需要额外空间存储淘汰记录 |

## Redis中的应用

### Redis未采用ARC的原因

1. **内存限制**：Redis追求极致内存优化
2. **实现复杂度**：ARC逻辑复杂，维护成本高
3. **近似LRU已足够**：Redis近似LRU在大多数场景下性能良好

### 替代方案

Redis采用**近似LRU + LFU**的组合策略：

- 默认使用近似LRU
- Redis 4.0+支持LFU模式
- 用户可根据场景选择

## 适用场景

### 优势场景

1. **动态工作负载**
   - 访问模式随时间变化
   - ARC自动适应变化

2. **混合访问模式**
   - 既有时间局部性，又有频率局部性
   - ARC平衡两种模式

3. **数据库缓存**
   - 查询模式复杂多变
   - ARC自动优化

### 不适用场景

1. **内存受限**
   - ARC内存开销较大
   - 建议使用LRU或LFU

2. **简单访问模式**
   - 访问模式单一且稳定
   - LRU或LFU已足够

## 算法对比

详见：[多维概念矩阵对比](../../00-项目总览/多维概念矩阵对比.md#1-缓存替换算法全面对比矩阵)

## 扩展阅读

- [LRU算法原理与实现](../01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [LFU算法原理与实现](../01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)
- [算法对比与决策](../01.05-算法对比与决策/README.md)

## 权威参考

- **ARC论文** - "ARC: A Self-Tuning, Low Overhead Replacement Cache"
- **IBM Almaden研究中心** - ARC算法原始论文
- **《算法导论》** - MIT Press
