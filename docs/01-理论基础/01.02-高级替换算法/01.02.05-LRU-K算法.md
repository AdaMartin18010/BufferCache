# 01.02.05 LRU-K算法

## 概述

LRU-K是LRU算法的改进版本，通过记录最近K次访问历史，更好地识别热点数据，提升缓存命中率。K通常取2，即LRU-2算法。

## 核心思想

### 设计原则

1. **K次访问历史**：记录每个数据的最近K次访问时间
2. **访问频率判断**：只有访问次数≥K的数据才进入缓存
3. **时间距离计算**：使用第K次访问时间作为排序依据

### 工作流程

```
新数据访问：
1. 记录访问时间
2. 如果访问次数 < K：不缓存（只记录历史）
3. 如果访问次数 = K：进入缓存
4. 如果访问次数 > K：更新缓存位置
```

## 数据结构设计

### LRU-2实现

```c
// LRU-2节点结构
typedef struct LRU2Node {
    int key;
    int value;

    // 访问历史（最多2次）
    long long access_time[2];
    int access_count;  // 访问次数

    struct LRU2Node *prev;
    struct LRU2Node *next;
} LRU2Node;

// LRU-2缓存结构
typedef struct LRU2Cache {
    int capacity;
    int size;

    LRU2Node *head;  // 最近访问（第2次）
    LRU2Node *tail;  // 最久访问（第2次）

    LRU2Node **hash;  // 哈希表（快速查找）
} LRU2Cache;
```

## 核心操作

### 1. 初始化

```c
LRU2Cache* lru2Create(int capacity) {
    LRU2Cache *cache = (LRU2Cache *)malloc(sizeof(LRU2Cache));
    cache->capacity = capacity;
    cache->size = 0;
    cache->head = NULL;
    cache->tail = NULL;
    cache->hash = (LRU2Node **)calloc(capacity, sizeof(LRU2Node *));
    return cache;
}
```

### 2. 访问操作

```c
int lru2Get(LRU2Cache *cache, int key) {
    LRU2Node *node = cache->hash[key % cache->capacity];

    // 查找节点
    while (node && node->key != key) {
        node = node->next;
    }

    if (!node) {
        return -1;  // 未找到
    }

    // 更新访问历史
    long long current_time = getCurrentTime();

    if (node->access_count < 2) {
        // 访问次数 < 2：只记录历史，不移动
        node->access_time[node->access_count] = current_time;
        node->access_count++;

        // 如果访问次数达到2，加入缓存
        if (node->access_count == 2) {
            addToCache(cache, node);
        }
    } else {
        // 访问次数 >= 2：更新历史并移动
        node->access_time[0] = node->access_time[1];
        node->access_time[1] = current_time;

        // 移动到头部（按第2次访问时间排序）
        moveToHead(cache, node);
    }

    return node->value;
}
```

### 3. 插入操作

```c
void lru2Put(LRU2Cache *cache, int key, int value) {
    LRU2Node *node = cache->hash[key % cache->capacity];

    // 查找节点
    while (node && node->key != key) {
        node = node->next;
    }

    if (node) {
        // 更新值
        node->value = value;
        lru2Get(cache, key);  // 更新访问历史
        return;
    }

    // 创建新节点
    node = (LRU2Node *)malloc(sizeof(LRU2Node));
    node->key = key;
    node->value = value;
    node->access_count = 1;
    node->access_time[0] = getCurrentTime();

    // 插入哈希表
    int index = key % cache->capacity;
    node->next = cache->hash[index];
    cache->hash[index] = node;

    // 访问次数 < 2：不加入缓存
    // 等待第2次访问时再加入
}
```

### 4. 淘汰操作

```c
void evictLRU2(LRU2Cache *cache) {
    if (cache->size < cache->capacity) {
        return;  // 未满，不需要淘汰
    }

    // 淘汰尾部节点（第2次访问时间最久）
    LRU2Node *tail = cache->tail;
    if (!tail) return;

    // 从链表移除
    if (tail->prev) {
        tail->prev->next = NULL;
        cache->tail = tail->prev;
    } else {
        cache->head = NULL;
        cache->tail = NULL;
    }

    // 从哈希表移除
    removeFromHash(cache, tail);

    free(tail);
    cache->size--;
}
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **命中率高** | 比LRU高5-15%（识别热点数据） |
| **抗扫描** | 能抵抗顺序扫描攻击 |
| **自适应** | 自动识别热点数据 |

### 劣势

| 特性 | 说明 |
|------|------|
| **内存开销** | 需要存储K次访问历史 |
| **实现复杂** | 比LRU复杂 |
| **延迟略高** | 更新历史有额外开销 |

## 适用场景

### 优势场景

1. **热点数据明显**
   - 有明显的数据访问热点
   - LRU-2能更好地识别热点

2. **顺序扫描场景**
   - 存在顺序扫描访问模式
   - LRU-2能抵抗扫描攻击

3. **高命中率要求**
   - 需要高缓存命中率
   - LRU-2比LRU命中率高5-15%

### 不适用场景

1. **内存受限**
   - 内存非常紧张
   - LRU-2需要额外内存存储历史

2. **延迟敏感**
   - 对延迟非常敏感
   - LRU-2有额外开销

## 性能分析

### 命中率对比

```
测试场景：Zipf分布（α=0.8）
- LRU命中率：~60%
- LRU-2命中率：~70%（+10%）
- LRU-3命中率：~72%（+2%）

结论：LRU-2是性价比最高的选择
```

### 时间复杂度

```
LRU-2：O(1)
LRU：O(1)

结论：时间复杂度相同
```

## 与其他算法对比

### LRU-2 vs LRU

| 维度 | LRU-2 | LRU |
|------|-------|-----|
| **命中率** | 高（+5-15%） | 中 |
| **内存开销** | 高（2倍） | 低 |
| **实现复杂度** | 高 | 低 |
| **抗扫描** | 是 | 否 |

### LRU-2 vs LFU

| 维度 | LRU-2 | LFU |
|------|-------|-----|
| **命中率** | 中 | 高 |
| **时间局部性** | 强 | 弱 |
| **频率局部性** | 中 | 强 |
| **实现复杂度** | 中 | 高 |

## Redis中的应用

### 潜在应用

```c
// Redis可以使用LRU-2改进近似LRU
// 当前：采样5个key，淘汰最久未访问的
// 改进：采样5个key，淘汰第2次访问时间最久的

// 实现思路：
// 1. 记录每个key的最近2次访问时间
// 2. 淘汰时使用第2次访问时间排序
// 3. 只有访问2次以上的key才参与淘汰
```

## 扩展阅读

- [LRU算法原理与实现](../01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [LFU算法原理与实现](../01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)
- [ARC自适应替换缓存](./01.02.04-ARC自适应替换缓存.md)

## 权威参考

- **《算法导论》** - MIT Press
- **LRU-K论文** - "The LRU-K Page Replacement Algorithm For Database Disk Buffering"
- **《数据库系统实现》** - 数据库经典教材
