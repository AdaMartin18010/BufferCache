# 01.02.06 Clock时钟扫描算法

## 概述

Clock算法（也称为Second Chance算法）是FIFO算法的改进版本，通过引用位（Reference Bit）给数据第二次机会，避免刚访问的数据被立即淘汰。

## 核心思想

### 设计原则

1. **循环队列**：数据组织成循环队列
2. **引用位**：每个数据有一个引用位（1表示最近访问过）
3. **时钟指针**：指针顺时针扫描，寻找可淘汰的数据

### 工作流程

```
淘汰时：
1. 检查当前指针位置的引用位
2. 如果引用位=1：清零，指针前进
3. 如果引用位=0：淘汰该数据，指针前进
4. 重复直到找到可淘汰的数据
```

## 数据结构设计

### Clock实现

```c
// Clock节点结构
typedef struct ClockNode {
    int key;
    int value;
    int reference_bit;  // 引用位（0或1）
    struct ClockNode *next;
} ClockNode;

// Clock缓存结构
typedef struct ClockCache {
    int capacity;
    int size;

    ClockNode *clock_hand;  // 时钟指针
    ClockNode **hash;       // 哈希表
} ClockCache;
```

## 核心操作

### 1. 初始化

```c
ClockCache* clockCreate(int capacity) {
    ClockCache *cache = (ClockCache *)malloc(sizeof(ClockCache));
    cache->capacity = capacity;
    cache->size = 0;
    cache->clock_hand = NULL;
    cache->hash = (ClockNode **)calloc(capacity, sizeof(ClockNode *));
    return cache;
}
```

### 2. 查找操作

```c
int clockGet(ClockCache *cache, int key) {
    ClockNode *node = cache->hash[key % cache->capacity];

    // 查找节点
    while (node && node->key != key) {
        node = node->next;
    }

    if (!node) {
        return -1;  // 未找到
    }

    // 设置引用位
    node->reference_bit = 1;

    return node->value;
}
```

### 3. 插入操作

```c
void clockPut(ClockCache *cache, int key, int value) {
    ClockNode *node = cache->hash[key % cache->capacity];

    // 查找节点
    while (node && node->key != key) {
        node = node->next;
    }

    if (node) {
        // 更新值
        node->value = value;
        node->reference_bit = 1;  // 设置引用位
        return;
    }

    // 如果缓存已满，淘汰一个
    if (cache->size >= cache->capacity) {
        evictClock(cache);
    }

    // 创建新节点
    node = (ClockNode *)malloc(sizeof(ClockNode));
    node->key = key;
    node->value = value;
    node->reference_bit = 1;  // 新数据引用位=1

    // 插入哈希表
    int index = key % cache->capacity;
    node->next = cache->hash[index];
    cache->hash[index] = node;

    // 插入循环队列
    if (!cache->clock_hand) {
        cache->clock_hand = node;
        node->next = node;  // 自环
    } else {
        node->next = cache->clock_hand->next;
        cache->clock_hand->next = node;
        cache->clock_hand = node;
    }

    cache->size++;
}
```

### 4. 淘汰操作

```c
void evictClock(ClockCache *cache) {
    if (!cache->clock_hand) return;

    ClockNode *current = cache->clock_hand;

    // 循环查找可淘汰的节点
    while (1) {
        if (current->reference_bit == 0) {
            // 引用位=0：可以淘汰
            break;
        } else {
            // 引用位=1：清零，给第二次机会
            current->reference_bit = 0;
            current = current->next;
        }
    }

    // 淘汰节点
    ClockNode *evict = current;

    // 从循环队列移除
    if (evict->next == evict) {
        // 只有一个节点
        cache->clock_hand = NULL;
    } else {
        // 找到前一个节点
        ClockNode *prev = evict;
        while (prev->next != evict) {
            prev = prev->next;
        }
        prev->next = evict->next;
        cache->clock_hand = evict->next;
    }

    // 从哈希表移除
    removeFromHash(cache, evict);

    free(evict);
    cache->size--;
}
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **实现简单** | 比LRU简单 |
| **时间复杂度** | O(1)平均情况 |
| **内存开销** | 小（只需1位） |
| **抗扫描** | 比FIFO好 |

### 劣势

| 特性 | 说明 |
|------|------|
| **命中率** | 比LRU低5-10% |
| **最坏情况** | O(N)（所有引用位=1） |

## 适用场景

### 优势场景

1. **内存受限**
   - 内存非常紧张
   - Clock只需1位额外开销

2. **实现简单**
   - 需要简单实现
   - Clock比LRU简单

3. **中等命中率要求**
   - 对命中率要求不高
   - Clock命中率中等

### 不适用场景

1. **高命中率要求**
   - 需要高缓存命中率
   - 建议LRU或LFU

2. **延迟敏感**
   - 对延迟非常敏感
   - Clock最坏情况O(N)

## 性能分析

### 命中率对比

```
测试场景：Zipf分布（α=0.8）
- FIFO命中率：~50%
- Clock命中率：~55%（+5%）
- LRU命中率：~60%（+5%）

结论：Clock比FIFO好，但不如LRU
```

### 时间复杂度

```
Clock：O(1)平均，O(N)最坏
LRU：O(1)
FIFO：O(1)

结论：平均情况相同，最坏情况Clock较差
```

## 与其他算法对比

### Clock vs FIFO

| 维度 | Clock | FIFO |
|------|-------|------|
| **命中率** | 高（+5%） | 低 |
| **实现复杂度** | 中 | 低 |
| **内存开销** | 中（+1位） | 低 |
| **抗扫描** | 是 | 否 |

### Clock vs LRU

| 维度 | Clock | LRU |
|------|-------|-----|
| **命中率** | 低（-5%） | 高 |
| **实现复杂度** | 低 | 中 |
| **内存开销** | 低 | 中 |
| **时间复杂度** | O(1)平均 | O(1) |

## 变种算法

### 1. Enhanced Clock（改进Clock）

```c
// 使用2个引用位（最近访问、修改）
typedef struct EnhancedClockNode {
    int key;
    int value;
    int reference_bit;  // 引用位
    int modified_bit;    // 修改位
} EnhancedClockNode;

// 淘汰优先级：
// 1. reference=0, modified=0（优先淘汰）
// 2. reference=0, modified=1
// 3. reference=1, modified=0
// 4. reference=1, modified=1（最后淘汰）
```

### 2. WSClock（工作集Clock）

```c
// 结合工作集概念
// 记录访问时间，淘汰最久未访问的
```

## Redis中的应用

### 潜在应用

```c
// Redis可以使用Clock改进近似LRU
// 当前：采样5个key，淘汰最久未访问的
// 改进：使用Clock算法，给最近访问的key第二次机会

// 实现思路：
// 1. 每个key有一个引用位
// 2. 访问时设置引用位=1
// 3. 淘汰时扫描，清零引用位，淘汰引用位=0的
```

## 扩展阅读

- [FIFO算法原理与实现](../01.01-基础替换算法/01.01.03-FIFO算法原理与实现.md)
- [LRU算法原理与实现](../01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [算法对比与决策](../01.05-算法对比与决策/README.md)

## 权威参考

- **《操作系统概念》** - 操作系统经典教材
- **Clock算法论文** - "The Working Set Model for Program Behavior"
- **《计算机系统设计原理》** - 系统设计经典教材
