# 02.01.03 Slab分配器

## 目录

- [02.01.03 Slab分配器](#020103-slab分配器)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. Slab分配器原理](#2-slab分配器原理)
    - [2.1 基本概念](#21-基本概念)
    - [2.2 三级缓存结构](#22-三级缓存结构)
  - [3. Slab分配器实现](#3-slab分配器实现)
    - [3.1 创建Slab Cache](#31-创建slab-cache)
    - [3.2 分配对象](#32-分配对象)
    - [3.3 释放对象](#33-释放对象)
  - [4. Slab着色](#4-slab着色)
    - [4.1 着色原理](#41-着色原理)
  - [5. 性能优化](#5-性能优化)
    - [5.1 CPU本地缓存大小](#51-cpu本地缓存大小)
    - [5.2 批量操作](#52-批量操作)
    - [5.3 NUMA优化](#53-numa优化)
  - [6. 监控和调优](#6-监控和调优)
    - [6.1 监控指标](#61-监控指标)
    - [6.2 调优参数](#62-调优参数)
  - [7. 性能分析](#7-性能分析)
    - [7.1 分配效率](#71-分配效率)
    - [7.2 碎片率](#72-碎片率)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 经典书籍](#91-经典书籍)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**Slab分配器**是Linux内核用于高效管理小对象内存的机制，减少内存碎片、提高分配效率。理解Slab分配器对于优化内核内存管理至关重要。

**历史发展**：

- **1990年代**：Slab分配器在Linux内核中引入
- **2000年代**：Slab分配器成为Linux内核的标准内存分配器
- **2010年代**：Slab分配器优化和NUMA支持
- **2020年代**：Slab分配器在高性能系统中广泛应用

### 1.2 应用价值

Slab分配器在内核内存管理中具有重要价值：

1. **性能提升**：大幅提升小对象分配效率
2. **碎片减少**：减少内存碎片，提高内存利用率
3. **缓存优化**：三级缓存结构，提高缓存命中率
4. **系统优化**：优化内核整体内存管理性能

## 2. Slab分配器原理

### 2.1 基本概念

```c
// Slab分配器基本概念
// 1. 按对象大小分类管理
// 2. 预分配对象池
// 3. 减少内存碎片

// Slab结构
struct slab {
    struct list_head list;        // 链表节点
    unsigned long colouroff;       // 着色偏移
    void *s_mem;                   // 对象起始地址
    unsigned int inuse;            // 使用中的对象数
    kmem_bufctl_t free;            // 空闲对象索引
};

// Slab Cache结构
struct kmem_cache {
    struct array_cache *cpu_cache;  // CPU本地缓存
    unsigned int size;              // 对象大小
    unsigned int objsize;           // 实际对象大小
    unsigned int align;             // 对齐要求
    const char *name;               // 名称
    struct kmem_cache_node *node[MAX_NUMNODES];  // 节点缓存
    // ...
};
```

**基本概念**：Slab分配器按对象大小分类管理，预分配对象池，减少内存碎片。

### 2.2 三级缓存结构

```c
// Slab三级缓存
// 1. CPU本地缓存（array_cache）：最快
// 2. Slab节点缓存（kmem_cache_node）：中等
// 3. Slab页面（slab）：最慢

// CPU本地缓存
struct array_cache {
    unsigned int avail;      // 可用对象数
    unsigned int limit;      // 限制
    unsigned int batchcount; // 批量数量
    void *entry[];          // 对象数组
};
```

**三级缓存结构**：CPU本地缓存（最快）→ Slab节点缓存（中等）→ Slab页面（最慢）。

**定理 2.1**：Slab分配器的时间复杂度为O(1)（CPU本地缓存命中）。

**证明**：

- CPU本地缓存分配：O(1)（数组操作）
- Slab节点缓存分配：O(1)（链表操作）
- Slab页面分配：O(1)（预分配对象池）
- 总时间复杂度：O(1)

## 3. Slab分配器实现

### 3.1 创建Slab Cache

```c
// 创建Slab Cache
struct kmem_cache *kmem_cache_create(const char *name,
                                     size_t size,
                                     size_t align,
                                     unsigned long flags,
                                     void (*ctor)(void *)) {
    struct kmem_cache *cachep;

    // 分配cache结构
    cachep = kmem_cache_alloc(kmem_cache, GFP_KERNEL);

    // 初始化cache
    cachep->name = name;
    cachep->size = size;
    cachep->objsize = size;
    cachep->align = align;

    // 计算对象大小（考虑对齐）
    calculate_slab_order(cachep);

    // 初始化节点缓存
    for_each_node(node) {
        init_cache_node(cachep, node);
    }

    return cachep;
}
```

**创建Slab Cache**：分配cache结构，初始化节点缓存。

### 3.2 分配对象

```c
// 分配对象
void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags) {
    void *obj;
    struct array_cache *ac;

    // 1. 从CPU本地缓存分配
    ac = cpu_cache_get(cachep);
    if (likely(ac->avail)) {
        ac->avail--;
        obj = ac->entry[ac->avail];
        return obj;
    }

    // 2. CPU缓存为空，从Slab填充
    obj = cache_alloc_refill(cachep, flags);
    return obj;
}

// 填充CPU缓存
static void *cache_alloc_refill(struct kmem_cache *cachep, gfp_t flags) {
    struct array_cache *ac;
    struct slab *slab;
    void *obj;
    int batchcount;

    ac = cpu_cache_get(cachep);
    batchcount = ac->batchcount;

    // 从节点缓存获取Slab
    slab = get_slab(cachep, flags);
    if (!slab)
        return NULL;

    // 从Slab分配对象
    while (batchcount-- && slab->inuse < cachep->num) {
        obj = slab_get_obj(cachep, slab);
        ac->entry[ac->avail++] = obj;
    }

    return ac->entry[--ac->avail];
}
```

**分配对象**：优先从CPU本地缓存分配，不足则从Slab填充。

### 3.3 释放对象

```c
// 释放对象
void kmem_cache_free(struct kmem_cache *cachep, void *objp) {
    struct array_cache *ac;

    // 1. 放回CPU本地缓存
    ac = cpu_cache_get(cachep);
    if (likely(ac->avail < ac->limit)) {
        ac->entry[ac->avail++] = objp;
        return;
    }

    // 2. CPU缓存满，批量释放到Slab
    cache_flusharray(cachep, ac);
    ac->entry[ac->avail++] = objp;
}

// 刷新CPU缓存
static void cache_flusharray(struct kmem_cache *cachep,
                             struct array_cache *ac) {
    int batchcount = ac->batchcount;
    struct slab *slab;

    // 获取Slab
    slab = get_slab(cachep, GFP_KERNEL);
    if (!slab)
        return;

    // 批量释放对象到Slab
    while (batchcount-- && ac->avail) {
        void *objp = ac->entry[--ac->avail];
        slab_put_obj(cachep, slab, objp);
    }
}
```

**释放对象**：优先放回CPU本地缓存，满则批量释放到Slab。

## 4. Slab着色

### 4.1 着色原理

```c
// Slab着色
// 1. 减少CPU缓存冲突
// 2. 通过偏移量分散对象
// 3. 提高缓存命中率

// 计算着色偏移
static unsigned int cache_line_size(void) {
    return L1_CACHE_BYTES;  // 通常64字节
}

static unsigned int slab_color(struct kmem_cache *cachep, struct slab *slab) {
    return (slab->colouroff / cache_line_size()) % cachep->colour;
}
```

**着色原理**：通过偏移量分散对象，减少CPU缓存冲突，提高缓存命中率。

## 5. 性能优化

### 5.1 CPU本地缓存大小

```c
// CPU本地缓存大小优化
// 1. 增大缓存减少Slab访问
// 2. 平衡内存使用和性能
// 3. 根据对象大小调整

// 默认配置
#define BOOT_CPUCACHE_ENTRIES 1
static int __init setup_cpu_cache_size(char *str) {
    // 从启动参数设置
    // ...
}
```

**CPU本地缓存大小**：增大缓存减少Slab访问，平衡内存使用和性能。

### 5.2 批量操作

```c
// 批量分配
void *kmem_cache_alloc_bulk(struct kmem_cache *cachep,
                            gfp_t flags,
                            size_t size,
                            void **p) {
    struct array_cache *ac;
    int i;

    ac = cpu_cache_get(cachep);

    // 从CPU缓存批量获取
    for (i = 0; i < size && ac->avail; i++) {
        p[i] = ac->entry[--ac->avail];
    }

    // 不足则填充
    if (i < size) {
        cache_alloc_refill(cachep, flags);
        while (i < size && ac->avail) {
            p[i++] = ac->entry[--ac->avail];
        }
    }

    return i;
}
```

**批量操作**：批量分配和释放，减少Slab访问次数。

### 5.3 NUMA优化

```c
// NUMA优化
// 1. 每个NUMA节点独立缓存
// 2. 优先从本地节点分配
// 3. 减少跨节点访问

static void *____cache_alloc_node(struct kmem_cache *cachep,
                                  gfp_t flags,
                                  int nodeid) {
    struct kmem_cache_node *n;
    struct slab *slab;

    // 从指定节点获取
    n = cachep->node[nodeid];
    slab = get_slab_from_node(cachep, n, flags);

    return slab_get_obj(cachep, slab);
}
```

**NUMA优化**：每个NUMA节点独立缓存，优先从本地节点分配。

## 6. 监控和调优

### 6.1 监控指标

```bash
# /proc/slabinfo查看Slab信息
cat /proc/slabinfo

# 查看特定cache
cat /proc/slabinfo | grep buffer_head

# 查看Slab统计
cat /proc/slabinfo | head -1
# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab>
```

**监控指标**：使用/proc/slabinfo查看Slab信息。

### 6.2 调优参数

```bash
# 调整CPU缓存大小
# 通过/proc/sys/vm/slab_reclaimable和slab_unreclaimable控制

# 查看当前值
cat /proc/sys/vm/slab_reclaimable
cat /proc/sys/vm/slab_unreclaimable

# 手动回收Slab
echo 2 > /proc/sys/vm/drop_caches  # 回收Slab
```

**调优参数**：调整CPU缓存大小，手动回收Slab。

## 7. 性能分析

### 7.1 分配效率

**分配效率**：

- **CPU本地缓存命中**：<1ns
- **Slab节点缓存分配**：~10ns
- **Slab页面分配**：~100ns

### 7.2 碎片率

**碎片率**：

- **传统分配器**：碎片率约30-50%
- **Slab分配器**：碎片率约5-10%
- **碎片率降低**：约80%

**定理 7.1**：Slab分配器可以将内存碎片率降低约80%。

**证明**：

- 传统分配器：碎片率约30-50%
- Slab分配器：碎片率约5-10%（预分配对象池）
- 碎片率降低：$\frac{30\% - 5\%}{30\%} = 83\%$（约80%）

## 8. 扩展阅读

- [Linux Page Cache机制](./02.01.01-Linux-Page-Cache机制.md)
- [Buffer Cache实现](./02.01.02-Buffer-Cache实现.md)
- [内存分配与回收](../../03-Redis组件/03.04-内存管理/03.04.01-内存分配与回收.md)

## 9. 权威参考

### 9.1 经典书籍

1. **《深入理解Linux内核（第3版）》** - Daniel P. Bovet, Marco Cesati
   - 出版社: 中国电力出版社
   - ISBN: 978-7508326232
   - 第8章：内存管理（Slab分配器详解）

2. **《Linux内核设计与实现（第3版）》** - Robert Love
   - 出版社: 机械工业出版社
   - ISBN: 978-7111406952
   - 第12章：内存管理（Slab分配器详解）

### 9.2 官方文档

1. **Linux内核文档 - Slab Allocator**
   - URL: <https://www.kernel.org/doc/html/latest/vm/slab.html>
   - Linux内核的Slab分配器文档

2. **Linux man pages - slabinfo(5)**
   - URL: <https://man7.org/linux/man-pages/man5/slabinfo.5.html>
   - slabinfo的官方文档

### 9.3 在线资源

1. **Wikipedia - Slab Allocation**
   - URL: <https://en.wikipedia.org/wiki/Slab_allocation>
   - 提供Slab分配器的详细说明
