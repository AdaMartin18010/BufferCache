# 02.01.04 VFS文件系统缓存

## 目录

- [02.01.04 VFS文件系统缓存](#020104-vfs文件系统缓存)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. VFS缓存原理](#2-vfs缓存原理)
    - [2.1 基本概念](#21-基本概念)
    - [2.2 缓存层次](#22-缓存层次)
  - [3. Dentry Cache实现](#3-dentry-cache实现)
    - [3.1 Dentry查找](#31-dentry查找)
    - [3.2 Dentry分配](#32-dentry分配)
    - [3.3 Dentry回收](#33-dentry回收)
  - [4. Inode Cache实现](#4-inode-cache实现)
    - [4.1 Inode查找](#41-inode查找)
    - [4.2 Inode分配](#42-inode分配)
    - [4.3 Inode回收](#43-inode回收)
  - [5. 性能优化](#5-性能优化)
    - [5.1 哈希表优化](#51-哈希表优化)
    - [5.2 LRU优化](#52-lru优化)
    - [5.3 预读优化](#53-预读优化)
  - [6. 监控和调优](#6-监控和调优)
    - [6.1 监控指标](#61-监控指标)
    - [6.2 调优参数](#62-调优参数)
  - [7. 性能分析](#7-性能分析)
    - [7.1 命中率分析](#71-命中率分析)
    - [7.2 延迟分析](#72-延迟分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 经典书籍](#91-经典书籍)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**VFS（Virtual File System）文件系统缓存**是Linux内核用于缓存文件系统元数据和目录信息的机制，提高文件系统操作性能。理解VFS缓存对于优化文件系统性能至关重要。

**历史发展**：

- **1990年代**：VFS在Linux内核中引入
- **2000年代**：VFS缓存成为Linux文件系统的标准
- **2010年代**：VFS缓存优化和性能提升
- **2020年代**：VFS缓存在高性能系统中广泛应用

### 1.2 应用价值

VFS缓存在文件系统性能中具有重要价值：

1. **性能提升**：大幅提升文件系统操作性能
2. **延迟降低**：减少磁盘访问，降低延迟
3. **吞吐量提升**：提升文件系统操作吞吐量
4. **系统优化**：优化系统整体文件系统性能

## 2. VFS缓存原理

### 2.1 基本概念

```c
// VFS缓存基本概念
// 1. 缓存inode（文件元数据）
// 2. 缓存dentry（目录项）
// 3. 缓存文件数据（Page Cache）

// Inode结构
struct inode {
    umode_t i_mode;                // 文件类型和权限
    uid_t i_uid;                   // 用户ID
    gid_t i_gid;                   // 组ID
    loff_t i_size;                 // 文件大小
    struct timespec64 i_atime;     // 访问时间
    struct timespec64 i_mtime;     // 修改时间
    struct timespec64 i_ctime;     // 状态改变时间
    unsigned long i_ino;           // Inode号
    struct super_block *i_sb;      // 超级块
    struct address_space *i_mapping; // 地址空间（Page Cache）
    // ...
};

// Dentry结构
struct dentry {
    unsigned int d_flags;          // 标志
    struct inode *d_inode;         // 关联的inode
    struct dentry *d_parent;       // 父目录
    struct qstr d_name;            // 文件名
    struct list_head d_lru;        // LRU链表
    struct list_head d_child;       // 子目录链表
    // ...
};
```

**基本概念**：VFS缓存inode（文件元数据）、dentry（目录项）和文件数据（Page Cache）。

### 2.2 缓存层次

```c
// VFS缓存层次
// 1. Dentry Cache：目录项缓存
// 2. Inode Cache：Inode缓存
// 3. Page Cache：文件数据缓存（已单独介绍）

// Dentry Cache
static struct kmem_cache *dentry_cache;

// Inode Cache
static struct kmem_cache *inode_cachep;
```

**缓存层次**：Dentry Cache（目录项缓存）→ Inode Cache（Inode缓存）→ Page Cache（文件数据缓存）。

**定理 2.1**：VFS缓存可以将文件系统操作延迟从约10ms（磁盘）降低到约0.1ms（内存）。

**证明**：

- 磁盘操作：约10ms（机械硬盘）
- VFS缓存操作：约0.1ms（内存）
- 延迟降低：$\frac{10ms}{0.1ms} = 100$倍

## 3. Dentry Cache实现

### 3.1 Dentry查找

```c
// 查找Dentry
struct dentry *d_lookup(const struct dentry *parent,
                        const struct qstr *name) {
    struct dentry *dentry;
    unsigned int hash = name->hash;

    // 在哈希表中查找
    rcu_read_lock();
    hlist_bl_for_each_entry_rcu(dentry, node,
                                 &dentry_hashtable[hash & d_hash_mask],
                                 d_hash) {
        if (dentry->d_name.hash != hash)
            continue;
        if (dentry->d_parent != parent)
            continue;
        if (parent->d_op && parent->d_op->d_compare) {
            if (parent->d_op->d_compare(parent, dentry, parent->d_inode,
                                         dentry->d_inode, name->len,
                                         name->name, &dentry->d_name))
                continue;
        } else {
            if (dentry->d_name.len != name->len)
                continue;
            if (memcmp(dentry->d_name.name, name->name, name->len))
                continue;
        }

        // 命中，更新LRU
        d_lru_del(dentry);
        d_lru_add(dentry);
        rcu_read_unlock();
        return dentry;
    }
    rcu_read_unlock();
    return NULL;
}
```

**Dentry查找**：在哈希表中查找，命中则更新LRU。

### 3.2 Dentry分配

```c
// 分配Dentry
static struct dentry *d_alloc(struct dentry *parent,
                               const struct qstr *name) {
    struct dentry *dentry;

    // 从Slab分配
    dentry = kmem_cache_alloc(dentry_cache, GFP_KERNEL);
    if (!dentry)
        return NULL;

    // 初始化
    dentry->d_name = *name;
    dentry->d_parent = parent;
    dentry->d_inode = NULL;
    INIT_LIST_HEAD(&dentry->d_lru);
    INIT_LIST_HEAD(&dentry->d_child);

    return dentry;
}
```

**Dentry分配**：从Slab分配，初始化字段。

### 3.3 Dentry回收

```c
// Dentry回收
static void dentry_lru_add(struct dentry *dentry) {
    if (unlikely(!(dentry->d_flags & DCACHE_LRU_LIST)))
        d_lru_add(dentry);
    else if (unlikely(!list_empty(&dentry->d_lru)))
        d_lru_move_tail(dentry);
}

// LRU回收
static void prune_dcache_sb(struct super_block *sb, int count) {
    struct dentry *dentry;
    struct list_head *tmp;
    int w_count;

    w_count = count / 2;
    while (!list_empty(&sb->s_dentry_lru)) {
        tmp = sb->s_dentry_lru.prev;
        dentry = list_entry(tmp, struct dentry, d_lru);

        // 检查是否可以回收
        if (dentry->d_count != 0) {
            list_move(&dentry->d_lru, &sb->s_dentry_lru);
            continue;
        }

        // 回收
        d_lru_del(dentry);
        d_free(dentry);

        if (--count <= 0)
            break;
    }
}
```

**Dentry回收**：使用LRU回收，检查引用计数。

## 4. Inode Cache实现

### 4.1 Inode查找

```c
// 查找Inode
struct inode *inode_lookup(struct super_block *sb, unsigned long ino) {
    struct inode *inode;
    struct hlist_head *head = inode_hashtable + hash(sb, ino);

    // 在哈希表中查找
    spin_lock(&inode_hash_lock);
    hlist_for_each_entry(inode, head, i_hash) {
        if (inode->i_ino == ino && inode->i_sb == sb) {
            // 命中
            __iget(inode);
            spin_unlock(&inode_hash_lock);
            return inode;
        }
    }
    spin_unlock(&inode_hash_lock);
    return NULL;
}
```

**Inode查找**：在哈希表中查找，命中则增加引用计数。

### 4.2 Inode分配

```c
// 分配Inode
struct inode *new_inode(struct super_block *sb) {
    struct inode *inode;

    // 从Slab分配
    inode = alloc_inode(sb);
    if (!inode)
        return NULL;

    // 初始化
    inode->i_sb = sb;
    inode->i_dev = sb->s_dev;
    inode->i_ino = get_next_ino();
    inode->i_state = 0;
    spin_lock_init(&inode->i_lock);

    return inode;
}
```

**Inode分配**：从Slab分配，初始化字段。

### 4.3 Inode回收

```c
// Inode回收
void iput(struct inode *inode) {
    if (inode) {
        BUG_ON(inode->i_state & I_CLEAR);

        if (atomic_dec_and_lock(&inode->i_count, &inode_lock)) {
            if (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {
                // 脏inode，写回
                mark_inode_dirty_sync(inode);
            }

            // 回收
            inode->i_state |= I_FREEING;
            inode_lru_list_del(inode);
            spin_unlock(&inode_lock);
            evict(inode);
        }
    }
}
```

**Inode回收**：减少引用计数，脏inode写回，回收inode。

## 5. 性能优化

### 5.1 哈希表优化

```c
// Dentry哈希表
static struct hlist_bl_head *dentry_hashtable __read_mostly;
static unsigned int d_hash_mask __read_mostly;
static unsigned int d_hash_shift __read_mostly;

// 初始化哈希表
static void __init dcache_init_early(void) {
    unsigned int loop;
    unsigned int hash_size;
    unsigned int hash_bits;

    // 计算哈希表大小
    hash_size = 1 << (PAGE_SHIFT + PAGE_SHIFT - 3);
    hash_bits = fls(hash_size);

    d_hash_mask = hash_size - 1;
    d_hash_shift = hash_bits;

    // 分配哈希表
    dentry_hashtable = alloc_large_system_hash("Dentry cache",
                                               sizeof(struct hlist_bl_head),
                                               hash_size, 13,
                                               HASH_EARLY | HASH_ZERO,
                                               &d_hash_shift,
                                               NULL,
                                               0,
                                               0);
}
```

**哈希表优化**：优化哈希表大小，减少哈希冲突。

### 5.2 LRU优化

```c
// LRU优化
// 1. 分离热数据和冷数据
// 2. 优先回收冷数据
// 3. 减少扫描开销

static void dentry_lru_move_tail(struct dentry *dentry) {
    if (list_empty(&dentry->d_lru))
        d_lru_add(dentry);
    else
        list_move_tail(&dentry->d_lru, &dentry->d_sb->s_dentry_lru);
}
```

**LRU优化**：分离热数据和冷数据，优先回收冷数据。

### 5.3 预读优化

```c
// Dentry预读
void readdir(struct file *file, struct dir_context *ctx) {
    // 预读目录项
    // 提高目录遍历性能
}
```

**预读优化**：预读目录项，提高目录遍历性能。

## 6. 监控和调优

### 6.1 监控指标

```bash
# /proc/sys/fs/dentry-state查看Dentry统计
cat /proc/sys/fs/dentry-state
# nr_dentry nr_unused age_limit want_pages

# /proc/sys/fs/inode-state查看Inode统计
cat /proc/sys/fs/inode-state
# nr_inodes nr_free_inodes

# 查看缓存命中率
# 通过/proc/slabinfo查看dentry和inode_cache的使用情况
cat /proc/slabinfo | grep -E "dentry|inode_cache"
```

**监控指标**：使用/proc/sys/fs/dentry-state和/proc/sys/fs/inode-state查看缓存统计。

### 6.2 调优参数

```bash
# 调整Dentry缓存大小
# 通过/proc/sys/fs/dentry-state控制

# 手动回收Dentry缓存
sync
echo 2 > /proc/sys/vm/drop_caches  # 回收Dentry和Inode缓存

# 调整Inode缓存
# 通过文件系统参数控制
# 例如：ext4的inode_ratio参数
```

**调优参数**：调整Dentry和Inode缓存大小，手动回收缓存。

## 7. 性能分析

### 7.1 命中率分析

**命中率指标**：

- **优秀**：>95%
- **正常**：80-95%
- **较差**：<80%

### 7.2 延迟分析

**延迟对比**：

- **缓存命中**：0.1-1μs
- **缓存未命中**：5-15ms（磁盘访问）
- **性能提升**：5000-150000倍

**定理 7.1**：VFS缓存可以将文件系统操作延迟降低约100倍。

**证明**：

- 磁盘操作：约10ms（机械硬盘）
- VFS缓存操作：约0.1ms（内存）
- 延迟降低：$\frac{10ms}{0.1ms} = 100$倍

## 8. 扩展阅读

- [Linux Page Cache机制](./02.01.01-Linux-Page-Cache机制.md)
- [Buffer Cache实现](./02.01.02-Buffer-Cache实现.md)
- [Slab分配器](./02.01.03-Slab分配器.md)

## 9. 权威参考

### 9.1 经典书籍

1. **《深入理解Linux内核（第3版）》** - Daniel P. Bovet, Marco Cesati
   - 出版社: 中国电力出版社
   - ISBN: 978-7508326232
   - 第12章：虚拟文件系统（VFS缓存详解）

2. **《Linux内核设计与实现（第3版）》** - Robert Love
   - 出版社: 机械工业出版社
   - ISBN: 978-7111406952
   - 第13章：虚拟文件系统（VFS缓存详解）

### 9.2 官方文档

1. **Linux内核文档 - Virtual File System**
   - URL: <https://www.kernel.org/doc/html/latest/filesystems/vfs.html>
   - Linux内核的VFS文档

2. **Linux man pages - dentry(7)**
   - URL: <https://man7.org/linux/man-pages/man7/dentry.7.html>
   - dentry的官方文档

### 9.3 在线资源

1. **Wikipedia - Virtual File System**
   - URL: <https://en.wikipedia.org/wiki/Virtual_file_system>
   - 提供VFS的详细说明
