# 02.02.02 MESI缓存一致性协议

## 概述

MESI（Modified、Exclusive、Shared、Invalid）是CPU缓存一致性协议，保证多核系统中缓存数据的一致性。理解MESI协议对于优化多线程Redis性能至关重要。

## MESI状态

### 状态定义

```c
// MESI状态定义
typedef enum {
    MESI_MODIFIED,    // 修改（M）：缓存行被修改，内存中的数据已过期
    MESI_EXCLUSIVE,   // 独占（E）：缓存行独占，内存中的数据是最新的
    MESI_SHARED,      // 共享（S）：缓存行被多个核心共享，内存中的数据是最新的
    MESI_INVALID,     // 无效（I）：缓存行无效，不能使用
} mesi_state_t;
```

### 状态转换

```
状态转换图：

I → E：读取未缓存的数据（Read Miss）
I → S：读取已缓存的数据（Read Miss，其他核心有）
E → S：其他核心读取独占数据（Read Hit）
S → E：其他核心失效共享数据（Invalidate）
E → M：写入独占数据（Write Hit）
S → M：写入共享数据（Write Hit，需要Invalidate其他核心）
M → S：其他核心读取修改数据（Read Hit，需要Write Back）
M → I：其他核心写入修改数据（Write Hit，需要Write Back + Invalidate）
```

## 协议实现

### 1. 读取操作

```c
// 读取操作
mesi_state_t cache_read(cache_line_t *line, uint64_t addr) {
    if (line->state == MESI_INVALID) {
        // 缓存未命中：从内存或其他核心读取
        if (other_cores_have(addr)) {
            // 其他核心有：状态变为Shared
            line->state = MESI_SHARED;
            line->data = read_from_other_core(addr);
        } else {
            // 其他核心没有：状态变为Exclusive
            line->state = MESI_EXCLUSIVE;
            line->data = read_from_memory(addr);
        }
    } else if (line->state == MESI_MODIFIED) {
        // 修改状态：直接返回
        return line->state;
    } else if (line->state == MESI_EXCLUSIVE) {
        // 独占状态：直接返回
        return line->state;
    } else if (line->state == MESI_SHARED) {
        // 共享状态：直接返回
        return line->state;
    }

    return line->state;
}
```

### 2. 写入操作

```c
// 写入操作
mesi_state_t cache_write(cache_line_t *line, uint64_t addr, void *data) {
    if (line->state == MESI_INVALID) {
        // 缓存未命中：读取并写入
        cache_read(line, addr);
        cache_write(line, addr, data);
    } else if (line->state == MESI_MODIFIED) {
        // 修改状态：直接写入
        line->data = data;
        return line->state;
    } else if (line->state == MESI_EXCLUSIVE) {
        // 独占状态：变为修改状态
        line->state = MESI_MODIFIED;
        line->data = data;
        return line->state;
    } else if (line->state == MESI_SHARED) {
        // 共享状态：需要Invalidate其他核心
        invalidate_other_cores(addr);
        line->state = MESI_MODIFIED;
        line->data = data;
        return line->state;
    }

    return line->state;
}
```

### 3. 失效操作

```c
// 失效操作（其他核心写入时）
void cache_invalidate(cache_line_t *line, uint64_t addr) {
    if (line->state == MESI_MODIFIED) {
        // 修改状态：需要Write Back
        write_back_to_memory(addr, line->data);
        line->state = MESI_INVALID;
    } else if (line->state == MESI_EXCLUSIVE) {
        // 独占状态：直接失效
        line->state = MESI_INVALID;
    } else if (line->state == MESI_SHARED) {
        // 共享状态：直接失效
        line->state = MESI_INVALID;
    }
}
```

## 性能影响

### 1. False Sharing（伪共享）

```c
// 伪共享问题
// 两个变量在同一缓存行，不同核心修改不同变量
struct {
    int var1;  // 核心1修改
    int var2;  // 核心2修改
    // 两个变量在同一缓存行（64字节）
} __attribute__((packed));

// 问题：核心1修改var1时，核心2的缓存行失效
// 解决：使用缓存行对齐
struct {
    int var1;
    char padding[60];  // 填充到64字节
    int var2;
} __attribute__((aligned(64)));
```

### 2. 缓存行乒乓

```c
// 缓存行乒乓（Cache Line Bouncing）
// 多个核心频繁修改同一缓存行

// 问题场景
int counter = 0;  // 多个核心频繁修改

// 解决：使用本地计数器
int local_counters[NUM_CORES];
// 定期汇总
```

## Redis优化

### 1. 数据结构对齐

```c
// Redis数据结构对齐
struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS;
    int refcount;
    void *ptr;
} __attribute__((aligned(64)));  // 对齐到缓存行
```

### 2. 减少伪共享

```c
// 减少伪共享
// 1. 数据结构对齐
// 2. 分离热点数据
// 3. 使用本地变量
```

### 3. 锁优化

```c
// 锁优化（减少缓存行竞争）
// 1. 使用细粒度锁
// 2. 使用无锁数据结构
// 3. 使用本地锁
```

## 性能测试

### 1. 伪共享测试

```c
// 伪共享性能测试
void test_false_sharing(void) {
    struct {
        int var1;
        int var2;
    } data;

    // 测试伪共享影响
    clock_t start = clock();
    for (int i = 0; i < 1000000; i++) {
        data.var1++;  // 核心1
        data.var2++;  // 核心2（伪共享）
    }
    clock_t end = clock();
    printf("False sharing time: %ld\n", end - start);
}
```

### 2. 缓存一致性开销

```bash
# 使用perf工具测试缓存一致性开销
perf stat -e cache-misses,cache-references ./redis-benchmark

# 分析缓存一致性协议开销
```

## 扩展阅读

- [CPU缓存与伪共享](../05-全栈分析/05.01-硬件层深度剖析/05.01.01-CPU缓存与伪共享.md)
- [L1/L2/L3缓存层次](./02.02.01-L1-L2-L3缓存层次.md)
- [NUMA架构影响](../05-全栈分析/05.01-硬件层深度剖析/05.01.02-NUMA架构影响.md)

## 权威参考

- **《计算机体系结构：量化研究方法》** - Hennessy & Patterson
- **《多核编程的艺术》** - Shavit & Herlihy
- **Intel架构文档** - <https://www.intel.com/content/www/us/en/developer/articles/technical/>
