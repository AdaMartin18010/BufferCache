# 02.02.03 Cache Line对齐优化

## 概述

Cache Line对齐优化是CPU缓存性能优化的重要技术，通过将数据结构对齐到缓存行边界（64字节），减少缓存缺失和伪共享问题，提升程序性能。

## Cache Line基础

### 缓存行大小

```c
// Cache Line大小（通常64字节）
#define CACHE_LINE_SIZE 64

// 不同架构的缓存行大小
// x86/x86_64: 64字节
// ARM: 32-128字节（通常64字节）
// PowerPC: 128字节
```

### 对齐原理

```c
// 数据结构对齐到缓存行
struct aligned_data {
    int data[16];  // 64字节，对齐到缓存行
} __attribute__((aligned(64)));

// 对齐的好处：
// 1. 减少缓存缺失
// 2. 避免伪共享
// 3. 提升访问性能
```

## 对齐优化

### 1. 数据结构对齐

```c
// 数据结构对齐
struct cache_aligned_counter {
    volatile long counter;
    char padding[CACHE_LINE_SIZE - sizeof(long)];  // 填充到64字节
} __attribute__((aligned(CACHE_LINE_SIZE)));

// 使用对齐的数据结构
struct cache_aligned_counter counters[NUM_CPUS];
```

### 2. 数组对齐

```c
// 数组对齐
#define ALIGN_TO_CACHE_LINE(size) \
    ((size + CACHE_LINE_SIZE - 1) & ~(CACHE_LINE_SIZE - 1))

// 对齐数组
int *aligned_array = aligned_alloc(CACHE_LINE_SIZE,
                                   ALIGN_TO_CACHE_LINE(array_size));
```

### 3. 内存分配对齐

```c
// 内存分配对齐
void *cache_aligned_malloc(size_t size) {
    void *ptr;
    posix_memalign(&ptr, CACHE_LINE_SIZE, size);
    return ptr;
}

// 使用对齐的内存
int *data = (int *)cache_aligned_malloc(1024 * sizeof(int));
```

## Redis中的应用

### 1. 数据结构对齐

```c
// Redis数据结构对齐
struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS;
    int refcount;
    void *ptr;
} __attribute__((aligned(64)));  // 对齐到缓存行
```

### 2. 热点数据分离

```c
// 热点数据分离（避免伪共享）
struct redisServer {
    // 冷数据
    char config_file[256];
    // ...

    // 热点数据（对齐到缓存行）
    struct {
        long long stat_keyspace_hits;
        long long stat_keyspace_misses;
        char padding[64 - 2 * sizeof(long long)];
    } __attribute__((aligned(64)));
};
```

### 3. 锁对齐

```c
// 锁对齐（减少伪共享）
struct aligned_mutex {
    pthread_mutex_t mutex;
    char padding[CACHE_LINE_SIZE - sizeof(pthread_mutex_t)];
} __attribute__((aligned(CACHE_LINE_SIZE)));
```

## 性能测试

### 1. 对齐vs非对齐

```c
// 对齐vs非对齐性能测试
void test_alignment_performance(void) {
    // 非对齐数据
    struct {
        int data[16];
    } unaligned_data;

    // 对齐数据
    struct {
        int data[16];
    } __attribute__((aligned(64))) aligned_data;

    // 测试非对齐访问
    clock_t start = clock();
    for (int i = 0; i < 1000000; i++) {
        unaligned_data.data[i % 16] = i;
    }
    clock_t unaligned_time = clock() - start;

    // 测试对齐访问
    start = clock();
    for (int i = 0; i < 1000000; i++) {
        aligned_data.data[i % 16] = i;
    }
    clock_t aligned_time = clock() - start;

    printf("Unaligned: %ld, Aligned: %ld, Improvement: %.2f%%\n",
           unaligned_time, aligned_time,
           (float)(unaligned_time - aligned_time) / unaligned_time * 100);
}
```

### 2. 缓存缺失测试

```bash
# 使用perf工具测试缓存缺失
perf stat -e cache-references,cache-misses ./test_program

# 分析对齐对缓存缺失的影响
```

## 最佳实践

### 1. 关键数据结构对齐

```c
// 关键数据结构对齐
// 1. 频繁访问的数据结构
// 2. 多线程共享的数据结构
// 3. 性能关键路径的数据结构
```

### 2. 避免过度对齐

```c
// 避免过度对齐
// 1. 只对齐关键数据结构
// 2. 考虑内存浪费
// 3. 平衡性能和内存使用
```

### 3. 编译器优化

```c
// 使用编译器属性
__attribute__((aligned(64)))

// 使用对齐宏
#define CACHE_ALIGNED __attribute__((aligned(64)))
```

## 扩展阅读

- [CPU缓存与伪共享](../05-全栈分析/05.01-硬件层深度剖析/05.01.01-CPU缓存与伪共享.md)
- [MESI缓存一致性协议](./02.02.02-MESI缓存一致性协议.md)
- [L1/L2/L3缓存层次](./02.02.01-L1-L2-L3缓存层次.md)

## 权威参考

- **《深入理解计算机系统》** - CMU
- **《计算机体系结构：量化研究方法》** - Hennessy & Patterson
- **Intel优化手册** - <https://www.intel.com/content/www/us/en/developer/articles/technical/>
