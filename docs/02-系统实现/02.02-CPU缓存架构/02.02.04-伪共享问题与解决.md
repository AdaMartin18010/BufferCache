# 02.02.04 伪共享问题与解决

## 概述

伪共享（False Sharing）是多核系统中的性能问题，当多个核心访问同一缓存行的不同数据时，会导致缓存行在核心间频繁无效化，严重影响性能。理解伪共享问题对于优化Redis多线程性能至关重要。

## 伪共享原理

### 问题场景

```c
// 伪共享问题示例
struct {
    int counter1;  // 核心1频繁修改
    int counter2;  // 核心2频繁修改
    // 两个变量在同一缓存行（64字节）
} counters;

// 问题：
// 1. 核心1修改counter1时，缓存行变为Modified
// 2. 核心2的缓存行失效（Invalid）
// 3. 核心2修改counter2时，需要重新加载缓存行
// 4. 导致缓存行在核心间频繁传递（Cache Line Bouncing）
```

### 性能影响

```python
# 伪共享性能影响
class FalseSharingImpact:
    def analyze(self):
        return {
            'cache_line_bouncing': {
                'description': '缓存行在核心间频繁传递',
                'impact': '严重性能下降',
            },
            'cache_misses': {
                'description': '缓存缺失率增加',
                'impact': '内存访问延迟增加',
            },
            'performance_degradation': {
                'description': '性能下降',
                'impact': '可能下降10-100倍',
            },
        }
```

## 检测伪共享

### 1. 性能分析工具

```bash
# 使用perf工具检测伪共享
perf c2c record ./redis-benchmark
perf c2c report

# 查看缓存行竞争
# 高竞争表示可能存在伪共享
```

### 2. 代码分析

```c
// 检查数据结构布局
struct problematic_struct {
    int var1;  // 可能与其他变量在同一缓存行
    int var2;
    // ...
};

// 使用offsetof检查偏移
#include <stddef.h>
printf("var1 offset: %zu\n", offsetof(struct problematic_struct, var1));
printf("var2 offset: %zu\n", offsetof(struct problematic_struct, var2));
```

### 3. 性能测试

```c
// 伪共享性能测试
void test_false_sharing(void) {
    struct {
        int counter1;
        int counter2;
    } shared_counters;

    // 测试伪共享场景
    clock_t start = clock();
    #pragma omp parallel
    {
        int tid = omp_get_thread_num();
        for (int i = 0; i < 1000000; i++) {
            if (tid == 0) {
                shared_counters.counter1++;
            } else {
                shared_counters.counter2++;
            }
        }
    }
    clock_t false_sharing_time = clock() - start;

    // 测试无伪共享场景（对齐到缓存行）
    struct {
        int counter1;
        char padding1[60];
        int counter2;
        char padding2[60];
    } __attribute__((aligned(64))) aligned_counters;

    start = clock();
    #pragma omp parallel
    {
        int tid = omp_get_thread_num();
        for (int i = 0; i < 1000000; i++) {
            if (tid == 0) {
                aligned_counters.counter1++;
            } else {
                aligned_counters.counter2++;
            }
        }
    }
    clock_t no_false_sharing_time = clock() - start;

    printf("False sharing: %ld, No false sharing: %ld, Improvement: %.2f%%\n",
           false_sharing_time, no_false_sharing_time,
           (float)(false_sharing_time - no_false_sharing_time) / false_sharing_time * 100);
}
```

## 解决方案

### 1. 缓存行对齐

```c
// 方案1：缓存行对齐
struct aligned_counters {
    int counter1;
    char padding[CACHE_LINE_SIZE - sizeof(int)];  // 填充到64字节
    int counter2;
    char padding2[CACHE_LINE_SIZE - sizeof(int)];
} __attribute__((aligned(CACHE_LINE_SIZE)));
```

### 2. 分离热点数据

```c
// 方案2：分离热点数据
struct hot_data {
    int counter1;
    // 其他热点数据
} __attribute__((aligned(64)));

struct cold_data {
    int counter2;
    // 其他冷数据
} __attribute__((aligned(64)));
```

### 3. 使用本地变量

```c
// 方案3：使用本地变量（减少共享）
void worker_thread(int thread_id) {
    int local_counter = 0;  // 本地变量

    for (int i = 0; i < 1000000; i++) {
        local_counter++;  // 本地操作
    }

    // 最后汇总
    atomic_fetch_add(&global_counter, local_counter);
}
```

### 4. 数组分离

```c
// 方案4：数组分离（每个核心一个元素）
#define CACHE_LINE_SIZE 64
#define PADDING (CACHE_LINE_SIZE / sizeof(int))

int counters[NUM_CORES * PADDING];  // 每个核心一个缓存行

// 访问
int get_counter(int core_id) {
    return counters[core_id * PADDING];
}
```

## Redis中的应用

### 1. 统计计数分离

```c
// Redis统计计数分离（避免伪共享）
struct redisServer {
    // 每个核心的统计（对齐到缓存行）
    struct {
        long long stat_keyspace_hits;
        long long stat_keyspace_misses;
        char padding[64 - 2 * sizeof(long long)];
    } __attribute__((aligned(64))) stats_per_core[MAX_CORES];
};
```

### 2. 锁对齐

```c
// Redis锁对齐（避免伪共享）
struct aligned_mutex {
    pthread_mutex_t mutex;
    char padding[CACHE_LINE_SIZE - sizeof(pthread_mutex_t)];
} __attribute__((aligned(CACHE_LINE_SIZE)));

struct aligned_mutex locks[NUM_LOCKS];
```

### 3. 内存分配对齐

```c
// Redis内存分配对齐
void *aligned_malloc(size_t size) {
    void *ptr;
    posix_memalign(&ptr, CACHE_LINE_SIZE, size);
    return ptr;
}
```

## 性能优化

### 1. 数据结构设计

```c
// 优化数据结构设计
// 1. 将频繁修改的字段分离
// 2. 使用缓存行对齐
// 3. 避免将热点数据放在一起
```

### 2. 访问模式优化

```c
// 优化访问模式
// 1. 减少共享数据的修改频率
// 2. 使用本地变量累积
// 3. 批量更新共享数据
```

### 3. 编译器优化

```c
// 使用编译器属性
__attribute__((aligned(64)))

// 使用对齐宏
#define CACHE_ALIGNED __attribute__((aligned(64)))
```

## 扩展阅读

- [CPU缓存与伪共享](../05-全栈分析/05.01-硬件层深度剖析/05.01.01-CPU缓存与伪共享.md)
- [MESI缓存一致性协议](./02.02.02-MESI缓存一致性协议.md)
- [Cache Line对齐优化](./02.02.03-Cache-Line对齐优化.md)

## 权威参考

- **《深入理解计算机系统》** - CMU
- **《多核编程的艺术》** - Shavit & Herlihy
- **Intel优化手册** - <https://www.intel.com/content/www/us/en/developer/articles/technical/>
