# 02.03.01 InnoDB Buffer Pool

## 概述

InnoDB Buffer Pool是MySQL InnoDB存储引擎的核心缓存机制，将表数据和索引缓存在内存中，大幅提升数据库性能。理解Buffer Pool机制对于优化数据库缓存性能至关重要。

## Buffer Pool原理

### 基本概念

```c
// Buffer Pool基本概念
// 1. 将磁盘页缓存在内存中
// 2. 使用LRU算法管理页面
// 3. 支持预读和刷新策略

struct buf_pool_t {
    ulint n_chunks;           // 块数量
    buf_chunk_t *chunks;      // 块数组
    buf_page_t *LRU;          // LRU链表
    buf_page_t *free;         // 空闲链表
    ulint curr_size;          // 当前大小
};
```

### 工作流程

```
读操作：
1. 检查Buffer Pool
2. 命中：直接返回
3. 未命中：从磁盘读取，加入Buffer Pool，返回

写操作：
1. 写入Buffer Pool（修改页面）
2. 标记页面为dirty
3. 后台刷新到磁盘（Checkpoint）
```

## LRU算法

### 传统LRU

```c
// 传统LRU实现
// 问题：全表扫描会污染Buffer Pool

void buf_LRU_add_block(buf_block_t *block) {
    // 添加到LRU头部
    UT_LIST_ADD_FIRST(LRU, buf_pool->LRU, block);
}
```

### 改进LRU（InnoDB）

```c
// InnoDB改进LRU
// 1. LRU分为young和old两部分
// 2. 新页面先加入old部分
// 3. 访问old页面后移到young部分

void buf_LRU_add_block(buf_block_t *block) {
    // 新页面加入old部分（LRU尾部）
    UT_LIST_ADD_LAST(LRU, buf_pool->LRU, block);

    // 如果old部分太大，移到young部分
    if (buf_pool->LRU_old != NULL) {
        buf_LRU_old_adjust_len();
    }
}
```

## 预读机制

### 1. 线性预读

```c
// 线性预读（Sequential Prefetch）
// 当顺序访问超过阈值时，预读后续页面

void buf_read_ahead_linear(ulint space, ulint offset) {
    // 检查顺序访问模式
    if (sequential_access_detected(space, offset)) {
        // 预读后续页面
        buf_read_pages(space, offset + 1, 64);
    }
}
```

### 2. 随机预读

```c
// 随机预读（Random Prefetch）
// 当检测到随机访问模式时，预读相邻页面

void buf_read_ahead_random(ulint space, ulint offset) {
    // 检查随机访问模式
    if (random_access_detected(space, offset)) {
        // 预读相邻页面
        buf_read_pages(space, offset - 32, 64);
    }
}
```

## 刷新策略

### 1. 后台刷新

```c
// 后台刷新（Background Flush）
// 定期刷新dirty页面到磁盘

void buf_flush_page_cleaner(void) {
    while (true) {
        // 刷新dirty页面
        buf_flush_batch(BUF_FLUSH_LRU);

        // 等待一段时间
        os_thread_sleep(1000);
    }
}
```

### 2. 检查点刷新

```c
// 检查点刷新（Checkpoint）
// 在检查点时刷新所有dirty页面

void buf_flush_sync_all_buf_pools(void) {
    // 刷新所有Buffer Pool的dirty页面
    for (ulint i = 0; i < srv_buf_pool_instances; i++) {
        buf_flush_batch(BUF_FLUSH_LIST, i);
    }
}
```

## 配置优化

### 1. Buffer Pool大小

```sql
-- 配置Buffer Pool大小（推荐：70-80%内存）
SET GLOBAL innodb_buffer_pool_size = 8589934592;  -- 8GB

-- 动态调整（MySQL 5.7+）
SET GLOBAL innodb_buffer_pool_size = 17179869184;  -- 16GB
```

### 2. Buffer Pool实例

```sql
-- 配置Buffer Pool实例数（减少锁竞争）
SET GLOBAL innodb_buffer_pool_instances = 8;
```

### 3. LRU参数

```sql
-- 配置LRU参数
SET GLOBAL innodb_old_blocks_pct = 37;      -- old部分比例
SET GLOBAL innodb_old_blocks_time = 1000;  -- old页面保护时间（ms）
```

## 性能监控

### 1. 命中率

```sql
-- 查看Buffer Pool命中率
SHOW STATUS LIKE 'Innodb_buffer_pool_read%';

-- 计算命中率
-- 命中率 = (1 - Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests) * 100
```

### 2. 页面统计

```sql
-- 查看Buffer Pool页面统计
SHOW STATUS LIKE 'Innodb_buffer_pool_pages%';

-- 关键指标：
-- Innodb_buffer_pool_pages_total: 总页面数
-- Innodb_buffer_pool_pages_free: 空闲页面数
-- Innodb_buffer_pool_pages_data: 数据页面数
-- Innodb_buffer_pool_pages_dirty: 脏页面数
```

### 3. 刷新统计

```sql
-- 查看刷新统计
SHOW STATUS LIKE 'Innodb_buffer_pool_write%';

-- 关键指标：
-- Innodb_buffer_pool_write_requests: 写入请求数
-- Innodb_buffer_pool_writes: 实际写入磁盘数
```

## Redis对比

### Buffer Pool vs Redis

| 维度 | InnoDB Buffer Pool | Redis |
|------|-------------------|-------|
| **用途** | 数据库页面缓存 | 键值缓存 |
| **算法** | 改进LRU | 近似LRU |
| **粒度** | 页面（16KB） | 对象 |
| **持久化** | 支持 | 支持 |
| **一致性** | 强一致性 | 最终一致性 |

## 扩展阅读

- [LRU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [内存分配与回收](../03-Redis组件/03.04-内存管理/03.04.01-内存分配与回收.md)
- [Linux Page Cache机制](./02.01.01-Linux-Page-Cache机制.md)

## 权威参考

- **《MySQL技术内幕：InnoDB存储引擎》** - 姜承尧
- **MySQL官方文档** - <https://dev.mysql.com/doc/>
- **InnoDB源码** - <https://github.com/mysql/mysql-server>
