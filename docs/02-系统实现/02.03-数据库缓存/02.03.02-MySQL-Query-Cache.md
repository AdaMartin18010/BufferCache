# 02.03.02 MySQL Query Cache

## 概述

MySQL Query Cache是MySQL的查询结果缓存机制，将SELECT查询的结果缓存在内存中，大幅提升重复查询的性能。理解Query Cache机制对于优化数据库缓存性能至关重要。

## Query Cache原理

### 基本概念

```c
// Query Cache基本概念
// 1. 缓存SELECT查询结果
// 2. 使用查询语句的哈希作为key
// 3. 表更新时自动失效

struct Query_cache {
    ulong query_cache_size;      // 缓存大小
    ulong query_cache_limit;     // 单个查询结果限制
    uint query_cache_type;        // 缓存类型（0=OFF, 1=ON, 2=DEMAND）
};
```

### 工作流程

```
查询流程：
1. 计算查询语句哈希
2. 检查Query Cache
3. 命中：直接返回结果
4. 未命中：执行查询，缓存结果，返回

更新流程：
1. 表数据更新（INSERT/UPDATE/DELETE）
2. 失效相关查询缓存
3. 继续执行更新操作
```

## 缓存管理

### 1. 查询缓存

```c
// 查询缓存
Query_cache_block *query_cache_store(THD *thd, const char *query,
                                     uint query_length,
                                     Query_result *result) {
    // 1. 计算查询哈希
    uint hash = calc_query_hash(query, query_length);

    // 2. 查找缓存
    Query_cache_block *block = find_block(hash);
    if (block) {
        // 命中：返回缓存结果
        return block;
    }

    // 3. 未命中：执行查询并缓存
    block = execute_and_cache(thd, query, result);
    return block;
}
```

### 2. 缓存失效

```c
// 缓存失效
void query_cache_invalidate_table(TABLE *table) {
    // 1. 查找相关查询缓存
    Query_cache_block *block = find_blocks_by_table(table);

    // 2. 失效缓存
    while (block) {
        block->type = Query_cache_block::FREE;
        block = block->next;
    }
}
```

## 配置优化

### 1. 启用Query Cache

```sql
-- 启用Query Cache
SET GLOBAL query_cache_type = 1;
SET GLOBAL query_cache_size = 67108864;  -- 64MB

-- 配置单个查询结果限制
SET GLOBAL query_cache_limit = 1048576;  -- 1MB
```

### 2. 按需缓存

```sql
-- 按需缓存（只缓存指定查询）
SET GLOBAL query_cache_type = 2;

-- 使用SQL_CACHE缓存查询
SELECT SQL_CACHE * FROM users WHERE id = 1;

-- 使用SQL_NO_CACHE不缓存查询
SELECT SQL_NO_CACHE * FROM users WHERE id = 1;
```

### 3. 性能调优

```sql
-- 监控Query Cache性能
SHOW STATUS LIKE 'Qcache%';

-- 关键指标：
-- Qcache_hits: 缓存命中次数
-- Qcache_inserts: 缓存插入次数
-- Qcache_not_cached: 未缓存查询次数
-- Qcache_queries_in_cache: 缓存中的查询数

-- 计算命中率
-- 命中率 = Qcache_hits / (Qcache_hits + Com_select) * 100
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **简单高效** | 实现简单，命中时性能极高 |
| **自动失效** | 表更新时自动失效相关缓存 |
| **内存占用** | 可配置缓存大小 |

### 劣势

| 特性 | 说明 |
|------|------|
| **粒度粗** | 表更新时失效所有相关缓存 |
| **内存竞争** | 与Buffer Pool竞争内存 |
| **维护开销** | 缓存失效和维护有开销 |

## 适用场景

### 优势场景

1. **读多写少**
   - 读操作远多于写操作
   - 查询结果相对稳定

2. **重复查询**
   - 大量重复查询
   - 查询结果较大

3. **简单查询**
   - 简单SELECT查询
   - 查询时间较短

### 不适用场景

1. **写多读少**
   - 写操作频繁
   - 缓存频繁失效

2. **复杂查询**
   - 复杂JOIN查询
   - 查询时间较长

3. **内存受限**
   - 内存紧张
   - Buffer Pool更重要

## Redis对比

### Query Cache vs Redis

| 维度 | MySQL Query Cache | Redis |
|------|------------------|-------|
| **粒度** | 查询结果 | 键值对 |
| **失效** | 表级失效 | 键级失效 |
| **灵活性** | 低 | 高 |
| **性能** | 高（命中时） | 高 |
| **适用场景** | 数据库查询缓存 | 通用缓存 |

## MySQL 8.0移除

```sql
-- MySQL 8.0移除了Query Cache
-- 原因：
-- 1. 维护开销大
-- 2. 粒度粗，失效频繁
-- 3. 与Buffer Pool竞争内存
-- 4. 性能提升有限

-- 替代方案：
-- 1. 使用应用层缓存（Redis）
-- 2. 使用ProxySQL查询缓存
-- 3. 优化查询和索引
```

## 扩展阅读

- [InnoDB Buffer Pool](./02.03.01-InnoDB-Buffer-Pool.md)
- [LRU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [Cache-Aside旁路缓存](../04-架构设计/04.01-缓存架构模式/04.01.01-Cache-Aside旁路缓存.md)

## 权威参考

- **《MySQL技术内幕：SQL编程》** - 姜承尧
- **MySQL官方文档** - <https://dev.mysql.com/doc/>
- **《高性能MySQL》** - Baron Schwartz
