# 02.03.03 PostgreSQL Shared Buffer

## 概述

PostgreSQL Shared Buffer是PostgreSQL数据库的核心缓存机制，将表数据和索引缓存在共享内存中，大幅提升数据库性能。理解Shared Buffer机制对于优化PostgreSQL缓存性能至关重要。

## Shared Buffer原理

### 基本概念

```c
// Shared Buffer基本概念
// 1. 将磁盘页缓存在共享内存中
// 2. 使用Clock Sweep算法管理页面
// 3. 支持预读和刷新策略

typedef struct BufferDesc {
    BufferTag tag;           // 页面标签（表+页号）
    int buf_id;              // 缓冲区ID
    int usage_count;         // 使用计数（Clock Sweep）
    unsigned flags;          // 标志位
    LWLock content_lock;     // 内容锁
} BufferDesc;
```

### 工作流程

```
读操作：
1. 检查Shared Buffer
2. 命中：直接返回
3. 未命中：从磁盘读取，加入Shared Buffer，返回

写操作：
1. 写入Shared Buffer（修改页面）
2. 标记页面为dirty
3. 后台刷新到磁盘（Checkpointer）
```

## Clock Sweep算法

### 算法原理

```c
// Clock Sweep算法（类似Clock算法）
// 1. 使用usage_count作为引用位
// 2. 扫描时递减usage_count
// 3. usage_count=0的页面可以淘汰

int clock_sweep(void) {
    static int next_victim = 0;

    while (true) {
        BufferDesc *buf = &BufferDescriptors[next_victim];

        if (buf->usage_count == 0) {
            // 可以淘汰
            return next_victim;
        } else {
            // 递减usage_count
            buf->usage_count--;
        }

        next_victim = (next_victim + 1) % NBuffers;
    }
}
```

### 与LRU对比

```python
# Clock Sweep vs LRU
class ClockSweepVsLRU:
    def compare(self):
        return {
            'clock_sweep': {
                'complexity': 'O(1)',
                'overhead': '低',
                'accuracy': '中等',
            },
            'lru': {
                'complexity': 'O(1)',
                'overhead': '中',
                'accuracy': '高',
            },
        }
```

## 配置优化

### 1. Shared Buffer大小

```sql
-- 配置Shared Buffer大小（推荐：25%内存）
-- postgresql.conf
shared_buffers = 2GB

-- 重启PostgreSQL
SELECT pg_reload_conf();
```

### 2. 预读配置

```sql
-- 配置预读参数
-- effective_io_concurrency: 并发I/O数
effective_io_concurrency = 200

-- random_page_cost: 随机页访问成本
random_page_cost = 1.1  # SSD场景
```

### 3. 后台写入配置

```sql
-- 配置后台写入
-- bgwriter_delay: 后台写入延迟（ms）
bgwriter_delay = 200

-- bgwriter_lru_maxpages: 每次写入最大页数
bgwriter_lru_maxpages = 100
```

## 性能监控

### 1. 命中率

```sql
-- 查看Shared Buffer命中率
SELECT
    sum(heap_blks_read) as heap_read,
    sum(heap_blks_hit) as heap_hit,
    sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) * 100 as hit_rate
FROM pg_statio_user_tables;

-- 目标：命中率 > 99%
```

### 2. 缓冲区统计

```sql
-- 查看缓冲区统计
SELECT * FROM pg_stat_bgwriter;

-- 关键指标：
-- buffers_checkpoint: 检查点写入
-- buffers_clean: 后台清理写入
-- buffers_backend: 后端进程写入
```

### 3. 页面统计

```sql
-- 查看页面统计
SELECT
    schemaname,
    tablename,
    heap_blks_read,
    heap_blks_hit,
    idx_blks_read,
    idx_blks_hit
FROM pg_statio_user_tables;
```

## Redis对比

### Shared Buffer vs Redis

| 维度 | PostgreSQL Shared Buffer | Redis |
|------|-------------------------|-------|
| **用途** | 数据库页面缓存 | 键值缓存 |
| **算法** | Clock Sweep | 近似LRU |
| **粒度** | 页面（8KB） | 对象 |
| **持久化** | WAL | RDB/AOF |
| **一致性** | 强一致性 | 最终一致性 |

## 优化策略

### 1. 大小调优

```python
# Shared Buffer大小调优
class SharedBufferTuning:
    def recommend_size(self, total_memory_gb):
        """推荐Shared Buffer大小"""
        # 推荐：25%内存
        recommended = total_memory_gb * 0.25

        # 最小：128MB
        # 最大：8GB（单机）
        return max(0.125, min(recommended, 8))
```

### 2. 预读优化

```sql
-- 预读优化（SSD场景）
effective_io_concurrency = 200
random_page_cost = 1.1
seq_page_cost = 1.0
```

### 3. 后台写入优化

```sql
-- 后台写入优化
bgwriter_delay = 200
bgwriter_lru_maxpages = 100
bgwriter_lru_multiplier = 2.0
```

## 扩展阅读

- [InnoDB Buffer Pool](./02.03.01-InnoDB-Buffer-Pool.md)
- [Clock时钟扫描算法](../01-理论基础/01.02-高级替换算法/01.02.06-Clock时钟扫描算法.md)
- [LRU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)

## 权威参考

- **《PostgreSQL即学即用》** - PostgreSQL经典教材
- **PostgreSQL官方文档** - <https://www.postgresql.org/docs/>
- **《PostgreSQL性能优化》** - PostgreSQL性能优化指南
