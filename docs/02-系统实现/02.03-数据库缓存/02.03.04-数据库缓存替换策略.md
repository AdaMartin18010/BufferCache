# 02.03.04 数据库缓存替换策略

## 概述

数据库缓存替换策略决定哪些页面应该保留在缓存中，哪些应该被淘汰。不同的替换策略适用于不同的访问模式，理解这些策略对于优化数据库缓存性能至关重要。

## 常见替换策略

### 1. LRU（Least Recently Used）

```c
// LRU实现（InnoDB改进版）
struct lru_list {
    struct page *young_head;  // 年轻页面（最近访问）
    struct page *old_head;    // 老页面（较久未访问）
    size_t young_size;
    size_t old_size;
};

// 访问页面
void lru_access_page(struct page *page) {
    if (page->age < OLD_BLOCK_TIME) {
        // 年轻页面：移到young头部
        move_to_young_head(page);
    } else {
        // 老页面：移到young头部
        move_to_young_head(page);
    }
}
```

### 2. Clock（时钟扫描）

```c
// Clock实现（PostgreSQL）
struct clock_buffer {
    struct page *pages;
    int clock_hand;  // 时钟指针
};

// Clock扫描
int clock_sweep(struct clock_buffer *buf) {
    while (true) {
        struct page *page = &buf->pages[buf->clock_hand];

        if (page->usage_count == 0) {
            // 可以淘汰
            return buf->clock_hand;
        } else {
            // 递减usage_count
            page->usage_count--;
        }

        buf->clock_hand = (buf->clock_hand + 1) % buf->num_pages;
    }
}
```

### 3. LFU（Least Frequently Used）

```c
// LFU实现
struct lfu_page {
    struct page *page;
    int frequency;  // 访问频率
    time_t last_access;
};

// 更新频率
void lfu_update(struct lfu_page *lfu_page) {
    lfu_page->frequency++;
    lfu_page->last_access = time(NULL);
}

// 选择淘汰页面（频率最低）
struct lfu_page *lfu_select_victim(struct lfu_list *list) {
    struct lfu_page *victim = NULL;
    int min_frequency = INT_MAX;

    for (struct lfu_page *p = list->head; p; p = p->next) {
        if (p->frequency < min_frequency) {
            min_frequency = p->frequency;
            victim = p;
        }
    }

    return victim;
}
```

## 策略对比

### 性能对比

| 策略 | 命中率 | 实现复杂度 | 内存开销 | 适用场景 |
|------|--------|-----------|---------|---------|
| **LRU** | 高 | 中 | 中 | 时间局部性强 |
| **Clock** | 中 | 低 | 低 | 简单场景 |
| **LFU** | 高 | 高 | 高 | 频率局部性强 |
| **FIFO** | 低 | 低 | 低 | 顺序访问 |

### 适用场景

```python
# 替换策略选择
class ReplacementStrategySelection:
    def recommend(self, access_pattern):
        """推荐替换策略"""
        if access_pattern == 'temporal_locality':
            return 'LRU'  # 时间局部性强
        elif access_pattern == 'frequency_locality':
            return 'LFU'  # 频率局部性强
        elif access_pattern == 'sequential':
            return 'FIFO'  # 顺序访问
        else:
            return 'Clock'  # 通用场景
```

## 数据库实现

### 1. InnoDB Buffer Pool

```c
// InnoDB使用改进LRU
// 1. 分为young和old两部分
// 2. 新页面先加入old部分
// 3. 访问old页面后移到young部分

void buf_LRU_add_block(buf_block_t *block) {
    // 新页面加入old部分
    UT_LIST_ADD_LAST(LRU, buf_pool->LRU, block);

    // 如果old部分太大，移到young部分
    if (buf_pool->LRU_old != NULL) {
        buf_LRU_old_adjust_len();
    }
}
```

### 2. PostgreSQL Shared Buffer

```c
// PostgreSQL使用Clock Sweep
int StrategyGetBuffer(void) {
    static int next_victim = 0;

    while (true) {
        BufferDesc *buf = &BufferDescriptors[next_victim];

        if (buf->usage_count == 0) {
            // 可以淘汰
            return next_victim;
        } else {
            // 递减usage_count
            buf->usage_count--;
        }

        next_victim = (next_victim + 1) % NBuffers;
    }
}
```

### 3. Oracle Buffer Cache

```c
// Oracle使用LRU
// 1. 维护LRU链表
// 2. 访问页面时移到LRU头部
// 3. 淘汰LRU尾部页面
```

## 优化策略

### 1. 预读优化

```c
// 预读优化（减少缓存缺失）
void prefetch_pages(int start_page, int num_pages) {
    for (int i = 0; i < num_pages; i++) {
        prefetch_page(start_page + i);
    }
}
```

### 2. 扫描优化

```c
// 扫描优化（避免污染缓存）
void sequential_scan(struct table *table) {
    // 使用FIFO或MRU策略
    // 避免LRU被顺序扫描污染
}
```

### 3. 热点数据保护

```c
// 热点数据保护
void protect_hot_pages(struct page_list *hot_pages) {
    // 标记热点页面，避免被淘汰
    for (struct page *p = hot_pages->head; p; p = p->next) {
        p->flags |= PAGE_HOT;
    }
}
```

## 性能监控

### 1. 命中率监控

```sql
-- InnoDB Buffer Pool命中率
SELECT
    (1 - (Innodb_buffer_pool_reads / Innodb_buffer_pool_read_requests)) * 100
    AS hit_rate
FROM (
    SELECT
        VARIABLE_VALUE AS Innodb_buffer_pool_reads
    FROM performance_schema.global_status
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_reads'
) AS reads,
(
    SELECT
        VARIABLE_VALUE AS Innodb_buffer_pool_read_requests
    FROM performance_schema.global_status
    WHERE VARIABLE_NAME = 'Innodb_buffer_pool_read_requests'
) AS requests;
```

### 2. 页面统计

```sql
-- PostgreSQL Shared Buffer统计
SELECT * FROM pg_stat_bgwriter;

-- 关键指标：
-- buffers_checkpoint: 检查点写入
-- buffers_clean: 后台清理
-- buffers_backend: 后端写入
```

## 扩展阅读

- [LRU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [LFU算法原理与实现](../01-理论基础/01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)
- [Clock时钟扫描算法](../01-理论基础/01.02-高级替换算法/01.02.06-Clock时钟扫描算法.md)
- [InnoDB Buffer Pool](./02.03.01-InnoDB-Buffer-Pool.md)
- [PostgreSQL Shared Buffer](./02.03.03-PostgreSQL-Shared-Buffer.md)

## 权威参考

- **《数据库系统实现》** - 数据库经典教材
- **《MySQL技术内幕：InnoDB存储引擎》** - 姜承尧
- **《PostgreSQL即学即用》** - PostgreSQL经典教材
