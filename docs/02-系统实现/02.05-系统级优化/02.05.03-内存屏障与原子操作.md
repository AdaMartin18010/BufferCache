# 02.05.03 内存屏障与原子操作

## 概述

内存屏障（Memory Barrier）和原子操作（Atomic Operations）是多线程编程中的关键同步机制，保证内存访问的顺序性和原子性。理解这些机制对于优化Redis多线程性能和保证数据一致性至关重要。

## 内存屏障

### 基本概念

```c
// 内存屏障基本概念
// 1. 保证内存访问的顺序性
// 2. 防止CPU和编译器重排序
// 3. 保证可见性

// 内存屏障类型
// 1. 读屏障（Read Barrier）：保证读操作顺序
// 2. 写屏障（Write Barrier）：保证写操作顺序
// 3. 全屏障（Full Barrier）：保证读写操作顺序
```

### 内存屏障类型

```c
// 编译器内存屏障
#define compiler_barrier() asm volatile("" ::: "memory")

// CPU内存屏障
#define mb()    asm volatile("mfence" ::: "memory")  // 全屏障
#define rmb()   asm volatile("lfence" ::: "memory")  // 读屏障
#define wmb()   asm volatile("sfence" ::: "memory")  // 写屏障

// C11内存屏障
#include <stdatomic.h>
atomic_thread_fence(memory_order_seq_cst);  // 顺序一致性
atomic_thread_fence(memory_order_acquire);  // 获取屏障
atomic_thread_fence(memory_order_release);  // 释放屏障
```

### 内存顺序

```c
// 内存顺序模型
typedef enum {
    memory_order_relaxed,    // 宽松顺序（无同步）
    memory_order_acquire,    // 获取顺序（读屏障）
    memory_order_release,    // 释放顺序（写屏障）
    memory_order_acq_rel,    // 获取-释放顺序
    memory_order_seq_cst,    // 顺序一致性（最强）
} memory_order;
```

## 原子操作

### 基本操作

```c
// 原子操作基本类型
#include <stdatomic.h>

atomic_int counter = ATOMIC_VAR_INIT(0);

// 原子加载
int value = atomic_load(&counter);

// 原子存储
atomic_store(&counter, 10);

// 原子交换
int old = atomic_exchange(&counter, 20);

// 原子比较交换（CAS）
int expected = 10;
if (atomic_compare_exchange_strong(&counter, &expected, 20)) {
    // 成功：counter从10变为20
} else {
    // 失败：counter不是10，expected更新为当前值
}
```

### 原子算术操作

```c
// 原子算术操作
atomic_int counter = ATOMIC_VAR_INIT(0);

// 原子加法
atomic_fetch_add(&counter, 1);  // counter++

// 原子减法
atomic_fetch_sub(&counter, 1);  // counter--

// 原子与
atomic_fetch_and(&counter, 0xFF);

// 原子或
atomic_fetch_or(&counter, 0x01);

// 原子异或
atomic_fetch_xor(&counter, 0xFF);
```

## Redis中的应用

### 1. 引用计数

```c
// Redis对象引用计数（原子操作）
typedef struct redisObject {
    atomic_int refcount;  // 原子引用计数
    // ...
} robj;

// 增加引用计数
void incrRefCount(robj *o) {
    atomic_fetch_add(&o->refcount, 1);
}

// 减少引用计数
void decrRefCount(robj *o) {
    if (atomic_fetch_sub(&o->refcount, 1) == 1) {
        // 引用计数为0，释放对象
        freeObject(o);
    }
}
```

### 2. 统计计数

```c
// Redis统计计数（原子操作）
atomic_long long stat_keyspace_hits;
atomic_long long stat_keyspace_misses;

// 增加命中计数
void updateStatsOnHit(void) {
    atomic_fetch_add(&stat_keyspace_hits, 1);
}

// 增加未命中计数
void updateStatsOnMiss(void) {
    atomic_fetch_add(&stat_keyspace_misses, 1);
}
```

### 3. 内存统计

```c
// Redis内存统计（原子操作）
atomic_size_t used_memory;

// 增加内存使用
void updateMemoryUsage(size_t bytes) {
    atomic_fetch_add(&used_memory, bytes);
}

// 减少内存使用
void decreaseMemoryUsage(size_t bytes) {
    atomic_fetch_sub(&used_memory, bytes);
}
```

## 性能优化

### 1. 减少内存屏障

```c
// 减少内存屏障开销
// 1. 使用relaxed顺序（如果不需要同步）
atomic_fetch_add_explicit(&counter, 1, memory_order_relaxed);

// 2. 批量操作
// 错误：多次原子操作
for (int i = 0; i < 1000; i++) {
    atomic_fetch_add(&counter, 1);
}

// 正确：批量操作
atomic_fetch_add(&counter, 1000);
```

### 2. 无锁数据结构

```c
// 无锁队列（Lock-Free Queue）
struct lockfree_queue {
    atomic_int head;
    atomic_int tail;
    void *buffer[QUEUE_SIZE];
};

// 入队（无锁）
int enqueue(struct lockfree_queue *q, void *item) {
    int tail = atomic_load(&q->tail);
    int next = (tail + 1) % QUEUE_SIZE;

    if (next == atomic_load(&q->head)) {
        return -1;  // 队列满
    }

    q->buffer[tail] = item;
    atomic_store(&q->tail, next);
    return 0;
}
```

### 3. 内存顺序优化

```c
// 使用合适的内存顺序
// 1. 读操作：acquire
int value = atomic_load_explicit(&counter, memory_order_acquire);

// 2. 写操作：release
atomic_store_explicit(&counter, 10, memory_order_release);

// 3. 读-修改-写：acq_rel
atomic_fetch_add_explicit(&counter, 1, memory_order_acq_rel);
```

## 性能测试

### 1. 原子操作性能

```c
// 原子操作性能测试
void test_atomic_performance(void) {
    atomic_int counter = ATOMIC_VAR_INIT(0);

    // 测试原子操作
    clock_t start = clock();
    for (int i = 0; i < 1000000; i++) {
        atomic_fetch_add(&counter, 1);
    }
    clock_t atomic_time = clock() - start;

    // 测试普通操作（加锁）
    int normal_counter = 0;
    pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    start = clock();
    for (int i = 0; i < 1000000; i++) {
        pthread_mutex_lock(&mutex);
        normal_counter++;
        pthread_mutex_unlock(&mutex);
    }
    clock_t mutex_time = clock() - start;

    printf("Atomic: %ld, Mutex: %ld, Improvement: %.2f%%\n",
           atomic_time, mutex_time,
           (float)(mutex_time - atomic_time) / mutex_time * 100);
}
```

### 2. 内存屏障开销

```c
// 内存屏障开销测试
void test_memory_barrier_overhead(void) {
    int data = 0;

    // 无屏障
    clock_t start = clock();
    for (int i = 0; i < 1000000; i++) {
        data = i;
    }
    clock_t no_barrier_time = clock() - start;

    // 有屏障
    start = clock();
    for (int i = 0; i < 1000000; i++) {
        data = i;
        mb();  // 内存屏障
    }
    clock_t barrier_time = clock() - start;

    printf("No barrier: %ld, Barrier: %ld, Overhead: %.2f%%\n",
           no_barrier_time, barrier_time,
           (float)(barrier_time - no_barrier_time) / no_barrier_time * 100);
}
```

## 最佳实践

### 1. 选择合适的同步机制

```c
// 同步机制选择
// 1. 简单计数器：原子操作
atomic_int counter;

// 2. 复杂数据结构：锁
pthread_mutex_t mutex;

// 3. 高性能场景：无锁数据结构
struct lockfree_queue queue;
```

### 2. 避免过度同步

```c
// 避免过度同步
// 1. 只在必要时使用内存屏障
// 2. 使用relaxed顺序（如果可能）
// 3. 批量操作减少同步次数
```

### 3. 正确使用内存顺序

```c
// 正确使用内存顺序
// 1. 生产者：release
atomic_store_explicit(&data, value, memory_order_release);

// 2. 消费者：acquire
int value = atomic_load_explicit(&data, memory_order_acquire);

// 3. 读-修改-写：acq_rel
atomic_fetch_add_explicit(&counter, 1, memory_order_acq_rel);
```

## 扩展阅读

- [NUMA架构优化](./02.05.01-NUMA架构优化.md)
- [MESI缓存一致性协议](../02.02-CPU缓存架构/02.02.02-MESI缓存一致性协议.md)
- [多IO线程控制流](../05-全栈分析/05.03-控制流分析/05.03.03-多IO线程控制流.md)

## 权威参考

- **《C++并发编程实战》** - Anthony Williams
- **《多核编程的艺术》** - Shavit & Herlihy
- **Linux内核文档** - <https://www.kernel.org/doc/Documentation/memory-barriers.txt>
