# 02.06.01 容错机制设计

## 目录

- [02.06.01 容错机制设计](#020601-容错机制设计)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 容错价值](#12-容错价值)
  - [2. 容错策略](#2-容错策略)
    - [2.1 熔断器模式](#21-熔断器模式)
    - [2.2 重试策略](#22-重试策略)
    - [2.3 降级策略](#23-降级策略)
    - [2.4 限流控制](#24-限流控制)
  - [3. 异常分类](#3-异常分类)
    - [3.1 网络异常](#31-网络异常)
    - [3.2 超时异常](#32-超时异常)
    - [3.3 数据异常](#33-数据异常)
    - [3.4 系统异常](#34-系统异常)
  - [4. 错误恢复](#4-错误恢复)
    - [4.1 自动恢复](#41-自动恢复)
    - [4.2 手动恢复](#42-手动恢复)
    - [4.3 数据恢复](#43-数据恢复)
  - [5. 实现示例](#5-实现示例)
    - [5.1 Python实现](#51-python实现)
    - [5.2 Java实现](#52-java实现)
    - [5.3 C#实现](#53-c实现)
    - [5.4 Golang实现](#54-golang实现)
    - [5.5 Rust实现](#55-rust实现)
    - [5.6 C/C++实现](#56-cc实现)
  - [6. 最佳实践](#6-最佳实践)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)
    - [8.1 学术论文](#81-学术论文)
    - [8.2 官方文档](#82-官方文档)
    - [8.3 经典书籍](#83-经典书籍)

---

## 1. 概述

### 1.1 定义与背景

**容错机制**是系统在出现故障时能够继续提供服务或优雅降级的能力。在缓存系统中，容错机制对于保证系统可用性和数据一致性至关重要。

**容错机制的目标**：

1. **防止级联故障**：避免单个故障引发整个系统崩溃
2. **快速恢复**：在故障发生后快速恢复正常服务
3. **优雅降级**：在部分功能不可用时提供降级服务
4. **数据保护**：确保数据不丢失、不损坏

### 1.2 容错价值

容错机制的价值：

1. **提高可用性**：减少系统不可用时间
2. **保护数据**：防止数据丢失和损坏
3. **用户体验**：提供更好的用户体验
4. **成本控制**：减少故障带来的损失

---

## 2. 容错策略

### 2.1 熔断器模式

**熔断器状态模型**：

熔断器有三种状态：

- **CLOSED**：正常状态，允许请求
- **OPEN**：熔断状态，拒绝请求
- **HALF_OPEN**：半开状态，尝试恢复

**状态转换条件**：

$$
S_{next} = \begin{cases}
\text{OPEN} & \text{if } N_{failures} \geq \theta_{threshold} \\
\text{HALF_OPEN} & \text{if } T_{elapsed} \geq T_{timeout} \\
\text{CLOSED} & \text{if } S_{current} = \text{HALF_OPEN} \text{ and } \text{success}
\end{cases}
$$

其中：

- $N_{failures}$：失败次数
- $\theta_{threshold}$：失败阈值
- $T_{elapsed}$：经过时间
- $T_{timeout}$：超时时间

**熔断器实现（Python）**：

```python
import time
from enum import Enum
from collections import deque
from threading import Lock
from typing import Callable, Any, Optional

class CircuitState(Enum):
    """熔断器状态"""
    CLOSED = "CLOSED"      # 关闭状态：正常服务
    OPEN = "OPEN"          # 打开状态：拒绝请求
    HALF_OPEN = "HALF_OPEN"  # 半开状态：尝试恢复

class CircuitBreakerError(Exception):
    """熔断器打开异常"""
    pass

class CircuitBreaker:
    """
    熔断器实现

    功能：
    - 监控请求失败率
    - 自动打开/关闭熔断器
    - 支持半开状态恢复
    """

    def __init__(
        self,
        failure_threshold: int = 5,
        timeout: float = 60.0,
        half_open_max_calls: int = 3,
        success_threshold: int = 2
    ):
        """
        初始化熔断器

        Args:
            failure_threshold: 失败阈值，超过此值打开熔断器
            timeout: 超时时间（秒），超时后进入半开状态
            half_open_max_calls: 半开状态最大尝试次数
            success_threshold: 半开状态成功阈值，达到此值关闭熔断器
        """
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.half_open_max_calls = half_open_max_calls
        self.success_threshold = success_threshold

        self.state = CircuitState.CLOSED
        self.failure_count = 0
        self.success_count = 0
        self.last_failure_time: Optional[float] = None
        self.half_open_calls = 0
        self.lock = Lock()

        # 记录请求历史
        self.request_history = deque(maxlen=1000)

    def call(self, func: Callable, *args, **kwargs) -> Any:
        """
        执行函数调用（带熔断保护）

        Args:
            func: 要执行的函数
            *args, **kwargs: 函数参数

        Returns:
            函数返回值

        Raises:
            CircuitBreakerError: 熔断器打开时抛出异常
        """
        with self.lock:
            # 检查状态
            if self.state == CircuitState.OPEN:
                # 检查是否超时，可以进入半开状态
                if self.last_failure_time and \
                   time.time() - self.last_failure_time >= self.timeout:
                    self.state = CircuitState.HALF_OPEN
                    self.half_open_calls = 0
                    self.success_count = 0
                else:
                    raise CircuitBreakerError(
                        f"Circuit breaker is OPEN. "
                        f"Last failure: {self.last_failure_time}"
                    )

            elif self.state == CircuitState.HALF_OPEN:
                if self.half_open_calls >= self.half_open_max_calls:
                    # 半开状态尝试次数用完
                    if self.success_count >= self.success_threshold:
                        # 成功次数达到阈值，关闭熔断器
                        self.state = CircuitState.CLOSED
                        self.failure_count = 0
                        self.success_count = 0
                        self.half_open_calls = 0
                    else:
                        # 失败，回到打开状态
                        self.state = CircuitState.OPEN
                        self.last_failure_time = time.time()
                        raise CircuitBreakerError("Circuit breaker is OPEN")

        # 执行函数
        try:
            result = func(*args, **kwargs)
            self._on_success()
            return result
        except Exception as e:
            self._on_failure()
            raise

    def _on_success(self):
        """成功回调"""
        with self.lock:
            self.request_history.append({
                'time': time.time(),
                'success': True
            })

            if self.state == CircuitState.HALF_OPEN:
                self.success_count += 1
                self.half_open_calls += 1
                # 如果半开状态成功次数达到阈值，关闭熔断器
                if self.success_count >= self.success_threshold:
                    self.state = CircuitState.CLOSED
                    self.failure_count = 0
                    self.success_count = 0
                    self.half_open_calls = 0
            elif self.state == CircuitState.CLOSED:
                # 重置失败计数
                self.failure_count = 0

    def _on_failure(self):
        """失败回调"""
        with self.lock:
            self.request_history.append({
                'time': time.time(),
                'success': False
            })

            self.failure_count += 1
            self.last_failure_time = time.time()

            if self.state == CircuitState.HALF_OPEN:
                self.half_open_calls += 1
                # 半开状态失败，回到打开状态
                if self.half_open_calls >= self.half_open_max_calls:
                    self.state = CircuitState.OPEN

            elif self.state == CircuitState.CLOSED:
                # 达到失败阈值，打开熔断器
                if self.failure_count >= self.failure_threshold:
                    self.state = CircuitState.OPEN

    def get_state(self) -> CircuitState:
        """获取当前状态"""
        return self.state

    def reset(self):
        """手动重置熔断器"""
        with self.lock:
            self.state = CircuitState.CLOSED
            self.failure_count = 0
            self.success_count = 0
            self.last_failure_time = None
            self.half_open_calls = 0

# 使用示例
def redis_get(key: str) -> str:
    """模拟Redis GET操作"""
    import random
    if random.random() < 0.3:  # 30%失败率
        raise ConnectionError("Redis connection failed")
    return f"value_{key}"

# 创建熔断器
circuit_breaker = CircuitBreaker(
    failure_threshold=5,
    timeout=60.0,
    half_open_max_calls=3,
    success_threshold=2
)

# 使用熔断器保护Redis调用
try:
    value = circuit_breaker.call(redis_get, "key1")
    print(f"Success: {value}")
except CircuitBreakerError as e:
    print(f"Circuit breaker opened: {e}")
except Exception as e:
    print(f"Error: {e}")
```

---

### 2.2 重试策略

**重试策略类型**：

1. **固定间隔重试**：每次重试间隔固定
2. **指数退避重试**：重试间隔指数增长
3. **随机抖动重试**：在指数退避基础上添加随机抖动

**指数退避公式**：

$$T_{retry} = T_{base} \times 2^{n-1} + \text{random}(0, J)$$

其中：

- $T_{base}$：基础间隔时间
- $n$：重试次数
- $J$：抖动范围

**重试策略实现（Python）**：

```python
import time
import random
from typing import Callable, Any, Optional, Type, Tuple
from functools import wraps

class RetryStrategy:
    """重试策略基类"""

    def get_delay(self, attempt: int) -> float:
        """计算重试延迟"""
        raise NotImplementedError

class FixedRetryStrategy(RetryStrategy):
    """固定间隔重试策略"""

    def __init__(self, delay: float = 1.0):
        self.delay = delay

    def get_delay(self, attempt: int) -> float:
        return self.delay

class ExponentialBackoffStrategy(RetryStrategy):
    """指数退避重试策略"""

    def __init__(self, base_delay: float = 1.0, max_delay: float = 60.0):
        self.base_delay = base_delay
        self.max_delay = max_delay

    def get_delay(self, attempt: int) -> float:
        delay = self.base_delay * (2 ** (attempt - 1))
        return min(delay, self.max_delay)

class JitterRetryStrategy(RetryStrategy):
    """随机抖动重试策略"""

    def __init__(
        self,
        base_delay: float = 1.0,
        max_delay: float = 60.0,
        jitter_range: float = 0.1
    ):
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.jitter_range = jitter_range

    def get_delay(self, attempt: int) -> float:
        base = self.base_delay * (2 ** (attempt - 1))
        delay = min(base, self.max_delay)
        jitter = delay * self.jitter_range * random.random()
        return delay + jitter

def retry(
    max_attempts: int = 3,
    strategy: RetryStrategy = None,
    exceptions: Tuple[Type[Exception], ...] = (Exception,),
    on_retry: Optional[Callable] = None
):
    """
    重试装饰器

    Args:
        max_attempts: 最大重试次数
        strategy: 重试策略
        exceptions: 需要重试的异常类型
        on_retry: 重试回调函数
    """
    if strategy is None:
        strategy = ExponentialBackoffStrategy()

    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            last_exception = None

            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e

                    if attempt < max_attempts:
                        delay = strategy.get_delay(attempt)
                        if on_retry:
                            on_retry(attempt, delay, e)
                        time.sleep(delay)
                    else:
                        # 最后一次重试失败
                        raise

            # 如果所有重试都失败，抛出最后一个异常
            if last_exception:
                raise last_exception

        return wrapper
    return decorator

# 使用示例
@retry(
    max_attempts=3,
    strategy=JitterRetryStrategy(base_delay=1.0, max_delay=10.0),
    exceptions=(ConnectionError, TimeoutError),
    on_retry=lambda attempt, delay, e: print(
        f"Retry {attempt} after {delay:.2f}s: {e}"
    )
)
def redis_get(key: str) -> str:
    """模拟Redis GET操作"""
    import random
    if random.random() < 0.5:  # 50%失败率
        raise ConnectionError("Redis connection failed")
    return f"value_{key}"

# 调用
try:
    value = redis_get("key1")
    print(f"Success: {value}")
except Exception as e:
    print(f"Failed after retries: {e}")
```

---

### 2.3 降级策略

**降级策略类型**：

1. **缓存降级**：使用本地缓存或默认值
2. **服务降级**：关闭非核心功能
3. **功能降级**：简化功能实现

**降级策略实现（Python）**：

```python
from typing import Callable, Any, Optional
from functools import wraps
import logging

logger = logging.getLogger(__name__)

class FallbackStrategy:
    """降级策略基类"""

    def fallback(self, *args, **kwargs) -> Any:
        """降级处理"""
        raise NotImplementedError

class CacheFallbackStrategy(FallbackStrategy):
    """缓存降级策略"""

    def __init__(self, cache: dict = None):
        self.cache = cache or {}

    def fallback(self, key: str, *args, **kwargs) -> Any:
        """从缓存获取"""
        return self.cache.get(key, None)

class DefaultValueFallbackStrategy(FallbackStrategy):
    """默认值降级策略"""

    def __init__(self, default_value: Any = None):
        self.default_value = default_value

    def fallback(self, *args, **kwargs) -> Any:
        """返回默认值"""
        return self.default_value

def fallback(strategy: FallbackStrategy):
    """
    降级装饰器

    Args:
        strategy: 降级策略
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs) -> Any:
            try:
                return func(*args, **kwargs)
            except Exception as e:
                logger.warning(f"Function {func.__name__} failed: {e}, using fallback")
                return strategy.fallback(*args, **kwargs)

        return wrapper
    return decorator

# 使用示例
local_cache = {}

@fallback(CacheFallbackStrategy(cache=local_cache))
def redis_get(key: str) -> str:
    """模拟Redis GET操作"""
    raise ConnectionError("Redis connection failed")

# 调用
value = redis_get("key1")  # 会使用缓存降级
```

---

### 2.4 限流控制

**限流算法**：

1. **令牌桶算法**：以固定速率生成令牌
2. **漏桶算法**：以固定速率处理请求
3. **滑动窗口算法**：统计时间窗口内的请求数

**令牌桶实现（Python）**：

```python
import time
from threading import Lock
from collections import deque

class TokenBucket:
    """
    令牌桶限流器

    功能：
    - 以固定速率生成令牌
    - 请求需要消耗令牌
    - 令牌不足时拒绝请求
    """

    def __init__(self, capacity: int, rate: float):
        """
        初始化令牌桶

        Args:
            capacity: 桶容量（最大令牌数）
            rate: 令牌生成速率（令牌/秒）
        """
        self.capacity = capacity
        self.rate = rate
        self.tokens = capacity
        self.last_update = time.time()
        self.lock = Lock()

    def acquire(self, tokens: int = 1) -> bool:
        """
        获取令牌

        Args:
            tokens: 需要的令牌数

        Returns:
            True: 获取成功
            False: 获取失败（令牌不足）
        """
        with self.lock:
            # 更新令牌数
            now = time.time()
            elapsed = now - self.last_update
            self.tokens = min(
                self.capacity,
                self.tokens + elapsed * self.rate
            )
            self.last_update = now

            # 检查是否有足够的令牌
            if self.tokens >= tokens:
                self.tokens -= tokens
                return True
            else:
                return False

    def get_available_tokens(self) -> float:
        """获取当前可用令牌数"""
        with self.lock:
            now = time.time()
            elapsed = now - self.last_update
            self.tokens = min(
                self.capacity,
                self.tokens + elapsed * self.rate
            )
            self.last_update = now
            return self.tokens

# 使用示例
rate_limiter = TokenBucket(capacity=100, rate=10.0)  # 每秒10个令牌

def rate_limited_request():
    """限流请求"""
    if rate_limiter.acquire():
        print("Request allowed")
        return True
    else:
        print("Request rate limited")
        return False

# 测试
for i in range(15):
    rate_limited_request()
    time.sleep(0.1)
```

---

## 3. 异常分类

### 3.1 网络异常

**网络异常类型**：

- **连接异常**：无法建立连接
- **超时异常**：连接或读取超时
- **协议异常**：协议错误

**处理策略**：

- 重试（可重试异常）
- 降级（使用本地缓存）
- 告警（记录日志）

### 3.2 超时异常

**超时异常类型**：

- **连接超时**：建立连接超时
- **读取超时**：读取数据超时
- **写入超时**：写入数据超时

**处理策略**：

- 重试（指数退避）
- 超时设置（合理设置超时时间）
- 监控（记录超时统计）

### 3.3 数据异常

**数据异常类型**：

- **数据格式错误**：数据格式不正确
- **数据缺失**：必需数据缺失
- **数据不一致**：数据版本不一致

**处理策略**：

- 验证（数据验证）
- 默认值（使用默认值）
- 告警（记录异常数据）

### 3.4 系统异常

**系统异常类型**：

- **内存不足**：系统内存不足
- **磁盘空间不足**：磁盘空间不足
- **资源耗尽**：系统资源耗尽

**处理策略**：

- 监控（资源监控）
- 告警（及时告警）
- 扩容（资源扩容）

---

## 4. 错误恢复

### 4.1 自动恢复

**自动恢复机制**：

- **重试机制**：自动重试失败的操作
- **故障转移**：自动切换到备用服务
- **健康检查**：定期检查服务健康状态

### 4.2 手动恢复

**手动恢复机制**：

- **手动切换**：手动切换到备用服务
- **数据修复**：手动修复数据问题
- **服务重启**：手动重启服务

### 4.3 数据恢复

**数据恢复机制**：

- **备份恢复**：从备份恢复数据
- **日志恢复**：从日志恢复数据
- **增量恢复**：增量恢复数据

---

## 5. 实现示例

### 5.1 Python实现

见上述代码示例。

### 5.2 Java实现

```java
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.time.Instant;

public class CircuitBreaker {
    private enum State { CLOSED, OPEN, HALF_OPEN }

    private volatile State state = State.CLOSED;
    private final int failureThreshold;
    private final long timeoutMs;
    private final AtomicInteger failureCount = new AtomicInteger(0);
    private final AtomicLong lastFailureTime = new AtomicLong(0);

    public CircuitBreaker(int failureThreshold, long timeoutMs) {
        this.failureThreshold = failureThreshold;
        this.timeoutMs = timeoutMs;
    }

    public <T> T execute(Supplier<T> operation) throws CircuitBreakerException {
        if (state == State.OPEN) {
            if (System.currentTimeMillis() - lastFailureTime.get() >= timeoutMs) {
                state = State.HALF_OPEN;
            } else {
                throw new CircuitBreakerException("Circuit breaker is OPEN");
            }
        }

        try {
            T result = operation.get();
            onSuccess();
            return result;
        } catch (Exception e) {
            onFailure();
            throw e;
        }
    }

    private void onSuccess() {
        failureCount.set(0);
        if (state == State.HALF_OPEN) {
            state = State.CLOSED;
        }
    }

    private void onFailure() {
        long currentTime = System.currentTimeMillis();
        lastFailureTime.set(currentTime);
        int failures = failureCount.incrementAndGet();

        if (failures >= failureThreshold) {
            state = State.OPEN;
        }
    }
}
```

### 5.3 C#实现

```csharp
using System;
using System.Threading;

public enum CircuitState
{
    Closed,
    Open,
    HalfOpen
}

public class CircuitBreaker
{
    private CircuitState state = CircuitState.Closed;
    private int failureCount = 0;
    private DateTime lastFailureTime;
    private readonly int failureThreshold;
    private readonly TimeSpan timeout;
    private readonly object lockObject = new object();

    public CircuitBreaker(int failureThreshold, TimeSpan timeout)
    {
        this.failureThreshold = failureThreshold;
        this.timeout = timeout;
    }

    public T Execute<T>(Func<T> operation)
    {
        lock (lockObject)
        {
            if (state == CircuitState.Open)
            {
                if (DateTime.UtcNow - lastFailureTime >= timeout)
                {
                    state = CircuitState.HalfOpen;
                }
                else
                {
                    throw new CircuitBreakerException("Circuit breaker is OPEN");
                }
            }
        }

        try
        {
            T result = operation();
            OnSuccess();
            return result;
        }
        catch (Exception e)
        {
            OnFailure();
            throw;
        }
    }

    private void OnSuccess()
    {
        lock (lockObject)
        {
            failureCount = 0;
            if (state == CircuitState.HalfOpen)
            {
                state = CircuitState.Closed;
            }
        }
    }

    private void OnFailure()
    {
        lock (lockObject)
        {
            lastFailureTime = DateTime.UtcNow;
            failureCount++;

            if (failureCount >= failureThreshold)
            {
                state = CircuitState.Open;
            }
        }
    }
}
```

---

### 5.4 Golang实现

**熔断器实现（Go）**：

```go
package main

import (
    "errors"
    "sync"
    "time"
)

type CircuitState int

const (
    Closed CircuitState = iota
    Open
    HalfOpen
)

type CircuitBreaker struct {
    failureThreshold int
    timeout          time.Duration
    state            CircuitState
    failureCount     int
    lastFailureTime  time.Time
    mutex            sync.RWMutex
}

func NewCircuitBreaker(failureThreshold int, timeout time.Duration) *CircuitBreaker {
    return &CircuitBreaker{
        failureThreshold: failureThreshold,
        timeout:          timeout,
        state:            Closed,
    }
}

func (cb *CircuitBreaker) Execute(operation func() error) error {
    cb.mutex.Lock()

    if cb.state == Open {
        if time.Since(cb.lastFailureTime) >= cb.timeout {
            cb.state = HalfOpen
            cb.failureCount = 0
        } else {
            cb.mutex.Unlock()
            return errors.New("circuit breaker is OPEN")
        }
    }

    cb.mutex.Unlock()

    err := operation()

    if err != nil {
        cb.onFailure()
        return err
    }

    cb.onSuccess()
    return nil
}

func (cb *CircuitBreaker) onSuccess() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()

    cb.failureCount = 0
    if cb.state == HalfOpen {
        cb.state = Closed
    }
}

func (cb *CircuitBreaker) onFailure() {
    cb.mutex.Lock()
    defer cb.mutex.Unlock()

    cb.failureCount++
    cb.lastFailureTime = time.Now()

    if cb.failureCount >= cb.failureThreshold {
        cb.state = Open
    }
}

func (cb *CircuitBreaker) GetState() CircuitState {
    cb.mutex.RLock()
    defer cb.mutex.RUnlock()
    return cb.state
}

// 使用示例
func main() {
    breaker := NewCircuitBreaker(5, 60*time.Second)

    err := breaker.Execute(func() error {
        // 模拟Redis操作
        return nil
    })

    if err != nil {
        // 处理错误
    }
}
```

**重试策略实现（Go）**：

```go
package main

import (
    "errors"
    "math"
    "time"
)

type RetryStrategy interface {
    GetDelay(attempt int) time.Duration
}

type ExponentialBackoffStrategy struct {
    BaseDelay time.Duration
    MaxDelay  time.Duration
}

func (s *ExponentialBackoffStrategy) GetDelay(attempt int) time.Duration {
    delay := time.Duration(math.Pow(2, float64(attempt-1))) * s.BaseDelay
    if delay > s.MaxDelay {
        return s.MaxDelay
    }
    return delay
}

func Retry(operation func() error, maxAttempts int, strategy RetryStrategy) error {
    var lastErr error

    for attempt := 1; attempt <= maxAttempts; attempt++ {
        err := operation()
        if err == nil {
            return nil
        }

        lastErr = err
        if attempt < maxAttempts {
            delay := strategy.GetDelay(attempt)
            time.Sleep(delay)
        }
    }

    return lastErr
}

// 使用示例
func main() {
    strategy := &ExponentialBackoffStrategy{
        BaseDelay: 1 * time.Second,
        MaxDelay:  60 * time.Second,
    }

    err := Retry(func() error {
        // 模拟Redis操作
        return errors.New("connection failed")
    }, 3, strategy)

    if err != nil {
        // 处理错误
    }
}
```

**令牌桶限流实现（Go）**：

```go
package main

import (
    "sync"
    "time"
)

type TokenBucket struct {
    capacity    int
    rate        float64
    tokens      float64
    lastUpdate  time.Time
    mutex       sync.Mutex
}

func NewTokenBucket(capacity int, rate float64) *TokenBucket {
    return &TokenBucket{
        capacity:   capacity,
        rate:       rate,
        tokens:     float64(capacity),
        lastUpdate: time.Now(),
    }
}

func (tb *TokenBucket) Acquire(tokens int) bool {
    tb.mutex.Lock()
    defer tb.mutex.Unlock()

    now := time.Now()
    elapsed := now.Sub(tb.lastUpdate).Seconds()
    tb.tokens = tb.tokens + elapsed*tb.rate

    if tb.tokens > float64(tb.capacity) {
        tb.tokens = float64(tb.capacity)
    }

    tb.lastUpdate = now

    if tb.tokens >= float64(tokens) {
        tb.tokens -= float64(tokens)
        return true
    }

    return false
}

// 使用示例
func main() {
    limiter := NewTokenBucket(100, 10.0) // 每秒10个令牌

    if limiter.Acquire(1) {
        // 请求允许
    } else {
        // 请求被限流
    }
}
```

---

### 5.5 Rust实现

**熔断器实现（Rust）**：

```rust
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};

#[derive(Debug, Clone, Copy, PartialEq)]
enum CircuitState {
    Closed,
    Open,
    HalfOpen,
}

pub struct CircuitBreaker {
    failure_threshold: usize,
    timeout: Duration,
    state: Arc<Mutex<CircuitState>>,
    failure_count: Arc<Mutex<usize>>,
    last_failure_time: Arc<Mutex<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(failure_threshold: usize, timeout: Duration) -> Self {
        Self {
            failure_threshold,
            timeout,
            state: Arc::new(Mutex::new(CircuitState::Closed)),
            failure_count: Arc::new(Mutex::new(0)),
            last_failure_time: Arc::new(Mutex::new(None)),
        }
    }

    pub fn execute<F, T, E>(&self, operation: F) -> Result<T, E>
    where
        F: FnOnce() -> Result<T, E>,
    {
        {
            let mut state = self.state.lock().unwrap();

            if *state == CircuitState::Open {
                if let Some(last_failure) = *self.last_failure_time.lock().unwrap() {
                    if last_failure.elapsed() >= self.timeout {
                        *state = CircuitState::HalfOpen;
                        *self.failure_count.lock().unwrap() = 0;
                    } else {
                        return Err(operation().unwrap_err());
                    }
                }
            }
        }

        match operation() {
            Ok(result) => {
                self.on_success();
                Ok(result)
            }
            Err(e) => {
                self.on_failure();
                Err(e)
            }
        }
    }

    fn on_success(&self) {
        let mut state = self.state.lock().unwrap();
        let mut failure_count = self.failure_count.lock().unwrap();

        *failure_count = 0;
        if *state == CircuitState::HalfOpen {
            *state = CircuitState::Closed;
        }
    }

    fn on_failure(&self) {
        let mut state = self.state.lock().unwrap();
        let mut failure_count = self.failure_count.lock().unwrap();
        let mut last_failure_time = self.last_failure_time.lock().unwrap();

        *failure_count += 1;
        *last_failure_time = Some(Instant::now());

        if *failure_count >= self.failure_threshold {
            *state = CircuitState::Open;
        }
    }
}

// 使用示例
fn main() {
    let breaker = CircuitBreaker::new(5, Duration::from_secs(60));

    let result = breaker.execute(|| {
        // 模拟Redis操作
        Ok::<String, String>("success".to_string())
    });

    match result {
        Ok(value) => println!("Success: {}", value),
        Err(e) => println!("Error: {}", e),
    }
}
```

**重试策略实现（Rust）**：

```rust
use std::time::Duration;
use std::thread;

pub trait RetryStrategy {
    fn get_delay(&self, attempt: usize) -> Duration;
}

pub struct ExponentialBackoffStrategy {
    base_delay: Duration,
    max_delay: Duration,
}

impl ExponentialBackoffStrategy {
    pub fn new(base_delay: Duration, max_delay: Duration) -> Self {
        Self {
            base_delay,
            max_delay,
        }
    }
}

impl RetryStrategy for ExponentialBackoffStrategy {
    fn get_delay(&self, attempt: usize) -> Duration {
        let delay_ms = self.base_delay.as_millis() as u64 * (1 << (attempt - 1));
        let delay = Duration::from_millis(delay_ms);

        if delay > self.max_delay {
            self.max_delay
        } else {
            delay
        }
    }
}

pub fn retry<F, T, E>(
    operation: F,
    max_attempts: usize,
    strategy: &dyn RetryStrategy,
) -> Result<T, E>
where
    F: Fn() -> Result<T, E>,
{
    let mut last_err = None;

    for attempt in 1..=max_attempts {
        match operation() {
            Ok(result) => return Ok(result),
            Err(e) => {
                last_err = Some(e);
                if attempt < max_attempts {
                    let delay = strategy.get_delay(attempt);
                    thread::sleep(delay);
                }
            }
        }
    }

    Err(last_err.unwrap())
}

// 使用示例
fn main() {
    let strategy = ExponentialBackoffStrategy::new(
        Duration::from_secs(1),
        Duration::from_secs(60),
    );

    let result = retry(
        || {
            // 模拟Redis操作
            Err::<String, String>("connection failed".to_string())
        },
        3,
        &strategy,
    );

    match result {
        Ok(value) => println!("Success: {}", value),
        Err(e) => println!("Error: {}", e),
    }
}
```

---

### 5.6 C/C++实现

**熔断器实现（C++）**：

```cpp
#include <mutex>
#include <chrono>
#include <stdexcept>

enum class CircuitState {
    Closed,
    Open,
    HalfOpen
};

class CircuitBreaker {
private:
    int failure_threshold_;
    std::chrono::seconds timeout_;
    CircuitState state_;
    int failure_count_;
    std::chrono::steady_clock::time_point last_failure_time_;
    std::mutex mutex_;

public:
    CircuitBreaker(int failure_threshold, std::chrono::seconds timeout)
        : failure_threshold_(failure_threshold)
        , timeout_(timeout)
        , state_(CircuitState::Closed)
        , failure_count_(0)
    {
    }

    template<typename Func>
    auto Execute(Func operation) -> decltype(operation()) {
        std::lock_guard<std::mutex> lock(mutex_);

        if (state_ == CircuitState::Open) {
            auto elapsed = std::chrono::steady_clock::now() - last_failure_time_;
            if (elapsed >= timeout_) {
                state_ = CircuitState::HalfOpen;
                failure_count_ = 0;
            } else {
                throw std::runtime_error("Circuit breaker is OPEN");
            }
        }

        mutex_.unlock();

        try {
            auto result = operation();
            OnSuccess();
            return result;
        } catch (...) {
            OnFailure();
            throw;
        }
    }

private:
    void OnSuccess() {
        std::lock_guard<std::mutex> lock(mutex_);
        failure_count_ = 0;
        if (state_ == CircuitState::HalfOpen) {
            state_ = CircuitState::Closed;
        }
    }

    void OnFailure() {
        std::lock_guard<std::mutex> lock(mutex_);
        failure_count_++;
        last_failure_time_ = std::chrono::steady_clock::now();

        if (failure_count_ >= failure_threshold_) {
            state_ = CircuitState::Open;
        }
    }
};

// 使用示例
#include <iostream>

int main() {
    CircuitBreaker breaker(5, std::chrono::seconds(60));

    try {
        auto result = breaker.Execute([]() -> int {
            // 模拟Redis操作
            return 42;
        });
        std::cout << "Success: " << result << std::endl;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

**令牌桶限流实现（C）**：

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <pthread.h>

typedef struct {
    int capacity;
    double rate;
    double tokens;
    time_t last_update;
    pthread_mutex_t mutex;
} TokenBucket;

TokenBucket* token_bucket_create(int capacity, double rate) {
    TokenBucket* tb = malloc(sizeof(TokenBucket));
    if (!tb) return NULL;

    tb->capacity = capacity;
    tb->rate = rate;
    tb->tokens = capacity;
    tb->last_update = time(NULL);
    pthread_mutex_init(&tb->mutex, NULL);

    return tb;
}

void token_bucket_destroy(TokenBucket* tb) {
    if (tb) {
        pthread_mutex_destroy(&tb->mutex);
        free(tb);
    }
}

int token_bucket_acquire(TokenBucket* tb, int tokens) {
    pthread_mutex_lock(&tb->mutex);

    time_t now = time(NULL);
    double elapsed = difftime(now, tb->last_update);
    tb->tokens += elapsed * tb->rate;

    if (tb->tokens > tb->capacity) {
        tb->tokens = tb->capacity;
    }

    tb->last_update = now;

    if (tb->tokens >= tokens) {
        tb->tokens -= tokens;
        pthread_mutex_unlock(&tb->mutex);
        return 1; // 成功
    }

    pthread_mutex_unlock(&tb->mutex);
    return 0; // 失败
}

// 使用示例
int main() {
    TokenBucket* limiter = token_bucket_create(100, 10.0); // 每秒10个令牌

    if (token_bucket_acquire(limiter, 1)) {
        printf("Request allowed\n");
    } else {
        printf("Request rate limited\n");
    }

    token_bucket_destroy(limiter);
    return 0;
}
```

---

## 6. 最佳实践

1. **合理设置阈值**：根据实际场景设置失败阈值和超时时间
2. **监控和告警**：监控熔断器状态，及时告警
3. **日志记录**：记录所有异常和恢复操作
4. **测试验证**：编写测试用例验证容错机制
5. **文档说明**：文档化容错策略和配置

---

## 7. 扩展阅读

- [异常处理模式](./02.06.02-异常处理模式.md)
- [程序设计示例](./02.06.03-程序设计示例.md)
- [故障传播分析](../../05-全栈分析/05.06-系统动态特征/05.06.03-故障传播分析.md)

---

## 8. 权威参考

### 8.1 学术论文

1. **"Circuit Breaker Pattern"** - Martin Fowler, 2014
   - URL: <https://martinfowler.com/bliki/CircuitBreaker.html>

### 8.2 官方文档

1. **"Resilience4j Documentation"** - Resilience4j
   - URL: <https://resilience4j.readme.io/>

### 8.3 经典书籍

1. **《Release It!》** - Michael Nygard, Pragmatic Bookshelf, 2018
   - ISBN: 978-1680502398
   - 内容: 生产环境软件设计，包括容错和可靠性设计

---

**文档版本**：v1.0
**最后更新**：2025-01
**文档状态**：✅ 完成
