# 02.06.02 异常处理模式

## 目录

- [02.06.02 异常处理模式](#020602-异常处理模式)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 异常处理价值](#12-异常处理价值)
  - [2. 异常分类](#2-异常分类)
    - [2.1 可重试异常](#21-可重试异常)
    - [2.2 不可重试异常](#22-不可重试异常)
    - [2.3 致命异常](#23-致命异常)
  - [3. 处理策略](#3-处理策略)
    - [3.1 重试策略](#31-重试策略)
    - [3.2 降级策略](#32-降级策略)
    - [3.3 告警策略](#33-告警策略)
    - [3.4 日志策略](#34-日志策略)
  - [4. 错误传播](#4-错误传播)
    - [4.1 异常链](#41-异常链)
    - [4.2 错误码](#42-错误码)
    - [4.3 错误消息](#43-错误消息)
  - [5. 实现示例](#5-实现示例)
    - [5.1 Python实现](#51-python实现)
    - [5.2 Java实现](#52-java实现)
    - [5.3 C#实现](#53-c实现)
    - [5.4 Golang实现](#54-golang实现)
    - [5.5 Rust实现](#55-rust实现)
    - [5.6 C/C++实现](#56-cc实现)
  - [6. 最佳实践](#6-最佳实践)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)

---

## 1. 概述

### 1.1 定义与背景

**异常处理**是程序在运行时遇到错误情况时的处理机制。在缓存系统中，异常处理对于保证系统稳定性和数据一致性至关重要。

**异常处理的目标**：

1. **快速恢复**：在异常发生后快速恢复正常服务
2. **错误隔离**：防止异常影响其他功能
3. **信息记录**：记录异常信息便于排查问题
4. **用户体验**：提供友好的错误提示

### 1.2 异常处理价值

异常处理的价值：

1. **提高稳定性**：减少程序崩溃
2. **便于调试**：记录异常信息便于排查
3. **用户体验**：提供友好的错误提示
4. **系统监控**：通过异常统计监控系统健康

---

## 2. 异常分类

### 2.1 可重试异常

**可重试异常特征**：

- **临时性**：异常是临时的，可能自动恢复
- **可恢复**：重试可能成功
- **无副作用**：重试不会产生副作用

**可重试异常类型**：

- **网络异常**：连接超时、网络中断
- **临时性错误**：服务暂时不可用
- **资源竞争**：资源暂时被占用

**处理策略**：

- **重试**：自动重试，使用指数退避
- **超时控制**：设置合理的超时时间
- **次数限制**：限制最大重试次数

**代码示例**：

```python
from typing import Type, Tuple
import time
import logging

logger = logging.getLogger(__name__)

class RetryableException(Exception):
    """可重试异常基类"""
    pass

class NetworkException(RetryableException):
    """网络异常"""
    pass

class TimeoutException(RetryableException):
    """超时异常"""
    pass

def retry_on_exception(
    max_attempts: int = 3,
    exceptions: Tuple[Type[Exception], ...] = (RetryableException,),
    base_delay: float = 1.0,
    max_delay: float = 60.0
):
    """
    异常重试装饰器

    Args:
        max_attempts: 最大重试次数
        exceptions: 需要重试的异常类型
        base_delay: 基础延迟时间（秒）
        max_delay: 最大延迟时间（秒）
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None

            for attempt in range(1, max_attempts + 1):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e

                    if attempt < max_attempts:
                        # 指数退避
                        delay = min(base_delay * (2 ** (attempt - 1)), max_delay)
                        logger.warning(
                            f"Attempt {attempt} failed: {e}. "
                            f"Retrying in {delay:.2f}s..."
                        )
                        time.sleep(delay)
                    else:
                        logger.error(f"All {max_attempts} attempts failed")
                        raise

            if last_exception:
                raise last_exception

        return wrapper
    return decorator

# 使用示例
@retry_on_exception(
    max_attempts=3,
    exceptions=(NetworkException, TimeoutException),
    base_delay=1.0,
    max_delay=10.0
)
def redis_get(key: str) -> str:
    """模拟Redis GET操作"""
    import random
    if random.random() < 0.5:
        raise NetworkException("Network connection failed")
    return f"value_{key}"
```

---

### 2.2 不可重试异常

**不可重试异常特征**：

- **永久性**：异常是永久的，不会自动恢复
- **不可恢复**：重试不会成功
- **有副作用**：重试可能产生副作用

**不可重试异常类型**：

- **参数错误**：参数格式错误、参数缺失
- **权限错误**：权限不足、认证失败
- **数据错误**：数据格式错误、数据不存在

**处理策略**：

- **立即失败**：不重试，立即返回错误
- **错误提示**：提供清晰的错误提示
- **日志记录**：记录错误信息

**代码示例**：

```python
class NonRetryableException(Exception):
    """不可重试异常基类"""
    pass

class ParameterException(NonRetryableException):
    """参数错误异常"""
    pass

class PermissionException(NonRetryableException):
    """权限错误异常"""
    pass

def validate_key(key: str) -> None:
    """验证key"""
    if not key:
        raise ParameterException("Key cannot be empty")
    if len(key) > 255:
        raise ParameterException("Key too long")

def redis_get(key: str) -> str:
    """Redis GET操作"""
    validate_key(key)

    # 模拟权限检查
    if key.startswith("admin:"):
        raise PermissionException("Access denied")

    return f"value_{key}"
```

---

### 2.3 致命异常

**致命异常特征**：

- **系统级错误**：系统级错误，无法恢复
- **需要人工干预**：需要人工干预才能恢复
- **影响范围大**：影响范围大，可能影响整个系统

**致命异常类型**：

- **内存溢出**：系统内存不足
- **磁盘空间不足**：磁盘空间不足
- **系统资源耗尽**：系统资源耗尽

**处理策略**：

- **立即告警**：立即发送告警
- **停止服务**：停止相关服务
- **记录日志**：详细记录错误信息
- **人工干预**：通知运维人员

**代码示例**：

```python
import logging
import sys

logger = logging.getLogger(__name__)

class FatalException(Exception):
    """致命异常基类"""
    pass

class OutOfMemoryException(FatalException):
    """内存溢出异常"""
    pass

class DiskFullException(FatalException):
    """磁盘空间不足异常"""
    pass

def handle_fatal_exception(e: FatalException):
    """处理致命异常"""
    logger.critical(f"Fatal error: {e}", exc_info=True)

    # 发送告警
    send_alert(f"Fatal error: {e}")

    # 停止服务
    sys.exit(1)

def send_alert(message: str):
    """发送告警"""
    # 实现告警逻辑
    print(f"ALERT: {message}")

# 使用示例
try:
    # 模拟内存溢出
    raise OutOfMemoryException("System out of memory")
except FatalException as e:
    handle_fatal_exception(e)
```

---

## 3. 处理策略

### 3.1 重试策略

见[容错机制设计](./02.06.01-容错机制设计.md#22-重试策略)。

### 3.2 降级策略

见[容错机制设计](./02.06.01-容错机制设计.md#23-降级策略)。

### 3.3 告警策略

**告警策略**：

- **实时告警**：异常发生时立即告警
- **阈值告警**：异常数量超过阈值时告警
- **聚合告警**：聚合多个异常后告警

**代码示例**：

```python
from collections import defaultdict
from datetime import datetime, timedelta
from typing import Dict, List

class AlertManager:
    """告警管理器"""

    def __init__(self, threshold: int = 10, window: int = 60):
        """
        初始化告警管理器

        Args:
            threshold: 告警阈值（异常数量）
            window: 时间窗口（秒）
        """
        self.threshold = threshold
        self.window = window
        self.errors: Dict[str, List[datetime]] = defaultdict(list)

    def record_error(self, error_type: str):
        """记录错误"""
        now = datetime.now()
        self.errors[error_type].append(now)

        # 清理过期记录
        cutoff = now - timedelta(seconds=self.window)
        self.errors[error_type] = [
            ts for ts in self.errors[error_type]
            if ts > cutoff
        ]

        # 检查是否需要告警
        if len(self.errors[error_type]) >= self.threshold:
            self.send_alert(error_type, len(self.errors[error_type]))

    def send_alert(self, error_type: str, count: int):
        """发送告警"""
        message = (
            f"Alert: {error_type} occurred {count} times "
            f"in the last {self.window} seconds"
        )
        print(f"ALERT: {message}")
        # 实现实际的告警逻辑（邮件、短信、钉钉等）

# 使用示例
alert_manager = AlertManager(threshold=10, window=60)

try:
    # 模拟操作
    pass
except Exception as e:
    alert_manager.record_error(type(e).__name__)
```

---

### 3.4 日志策略

**日志策略**：

- **分级日志**：根据异常级别记录日志
- **结构化日志**：使用结构化格式记录日志
- **日志聚合**：聚合日志便于分析

**代码示例**：

```python
import logging
import json
from datetime import datetime

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

class StructuredLogger:
    """结构化日志记录器"""

    @staticmethod
    def log_error(
        operation: str,
        error: Exception,
        context: dict = None
    ):
        """记录错误日志"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'operation': operation,
            'error_type': type(error).__name__,
            'error_message': str(error),
            'context': context or {}
        }
        logger.error(json.dumps(log_data))

    @staticmethod
    def log_warning(
        operation: str,
        message: str,
        context: dict = None
    ):
        """记录警告日志"""
        log_data = {
            'timestamp': datetime.utcnow().isoformat(),
            'operation': operation,
            'message': message,
            'context': context or {}
        }
        logger.warning(json.dumps(log_data))

# 使用示例
try:
    # 模拟操作
    result = redis_get("key1")
except Exception as e:
    StructuredLogger.log_error(
        operation="redis_get",
        error=e,
        context={'key': 'key1'}
    )
```

---

## 4. 错误传播

### 4.1 异常链

**异常链**：保留原始异常信息，形成异常链。

**代码示例**：

```python
class CacheException(Exception):
    """缓存异常基类"""
    pass

class RedisException(CacheException):
    """Redis异常"""
    def __init__(self, message: str, cause: Exception = None):
        super().__init__(message)
        self.cause = cause

def redis_get(key: str) -> str:
    """Redis GET操作"""
    try:
        # 模拟网络操作
        raise ConnectionError("Network error")
    except ConnectionError as e:
        raise RedisException(f"Failed to get key: {key}", cause=e) from e

# 使用示例
try:
    value = redis_get("key1")
except RedisException as e:
    print(f"Error: {e}")
    print(f"Cause: {e.cause}")
    print(f"Original: {e.__cause__}")
```

---

### 4.2 错误码

**错误码**：使用错误码标识错误类型。

**代码示例**：

```python
from enum import IntEnum

class ErrorCode(IntEnum):
    """错误码枚举"""
    SUCCESS = 0
    NETWORK_ERROR = 1001
    TIMEOUT_ERROR = 1002
    PERMISSION_ERROR = 2001
    PARAMETER_ERROR = 2002
    SYSTEM_ERROR = 3001

class CacheError(Exception):
    """缓存错误"""
    def __init__(self, code: ErrorCode, message: str):
        self.code = code
        self.message = message
        super().__init__(f"[{code}] {message}")

def redis_get(key: str) -> str:
    """Redis GET操作"""
    try:
        # 模拟操作
        raise ConnectionError("Network error")
    except ConnectionError as e:
        raise CacheError(
            ErrorCode.NETWORK_ERROR,
            f"Failed to get key: {key}"
        )

# 使用示例
try:
    value = redis_get("key1")
except CacheError as e:
    if e.code == ErrorCode.NETWORK_ERROR:
        # 处理网络错误
        print("Network error, retrying...")
    elif e.code == ErrorCode.PERMISSION_ERROR:
        # 处理权限错误
        print("Permission denied")
```

---

### 4.3 错误消息

**错误消息**：提供清晰的错误消息。

**代码示例**：

```python
class ErrorMessage:
    """错误消息模板"""

    NETWORK_ERROR = "Network connection failed. Please check your network."
    TIMEOUT_ERROR = "Operation timeout. Please try again later."
    PERMISSION_ERROR = "Permission denied. Please check your credentials."
    PARAMETER_ERROR = "Invalid parameter. Please check your input."

class CacheError(Exception):
    """缓存错误"""
    def __init__(self, code: ErrorCode, message: str, user_message: str = None):
        self.code = code
        self.message = message
        self.user_message = user_message or message
        super().__init__(self.user_message)

def redis_get(key: str) -> str:
    """Redis GET操作"""
    try:
        # 模拟操作
        raise ConnectionError("Network error")
    except ConnectionError as e:
        raise CacheError(
            ErrorCode.NETWORK_ERROR,
            f"Failed to get key: {key}",
            ErrorMessage.NETWORK_ERROR
        )

# 使用示例
try:
    value = redis_get("key1")
except CacheError as e:
    # 显示用户友好的错误消息
    print(f"Error: {e.user_message}")
    # 记录详细错误信息
    logger.error(f"Error code: {e.code}, Message: {e.message}")
```

---

## 5. 实现示例

### 5.1 Python实现

见上述代码示例。

### 5.2 Java实现

```java
public enum ErrorCode {
    SUCCESS(0),
    NETWORK_ERROR(1001),
    TIMEOUT_ERROR(1002),
    PERMISSION_ERROR(2001),
    PARAMETER_ERROR(2002),
    SYSTEM_ERROR(3001);

    private final int code;

    ErrorCode(int code) {
        this.code = code;
    }

    public int getCode() {
        return code;
    }
}

public class CacheException extends Exception {
    private final ErrorCode errorCode;
    private final String userMessage;

    public CacheException(ErrorCode errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.userMessage = message;
    }

    public ErrorCode getErrorCode() {
        return errorCode;
    }

    public String getUserMessage() {
        return userMessage;
    }
}
```

### 5.3 C#实现

```csharp
public enum ErrorCode
{
    Success = 0,
    NetworkError = 1001,
    TimeoutError = 1002,
    PermissionError = 2001,
    ParameterError = 2002,
    SystemError = 3001
}

public class CacheException : Exception
{
    public ErrorCode ErrorCode { get; }
    public string UserMessage { get; }

    public CacheException(ErrorCode errorCode, string message)
        : base(message)
    {
        ErrorCode = errorCode;
        UserMessage = message;
    }
}
```

---

### 5.4 Golang实现

**错误码和异常处理（Go）**：

```go
package main

import (
    "errors"
    "fmt"
)

type ErrorCode int

const (
    Success ErrorCode = iota
    NetworkError
    TimeoutError
    PermissionError
    ParameterError
    SystemError
)

type CacheError struct {
    Code        ErrorCode
    Message     string
    UserMessage string
    Cause       error
}

func (e *CacheError) Error() string {
    return fmt.Sprintf("[%d] %s", e.Code, e.Message)
}

func NewCacheError(code ErrorCode, message string, cause error) *CacheError {
    return &CacheError{
        Code:        code,
        Message:     message,
        UserMessage: message,
        Cause:       cause,
    }
}

// 使用示例
func redisGet(key string) (string, error) {
    if key == "" {
        return "", NewCacheError(ParameterError, "Key cannot be empty", nil)
    }

    // 模拟网络错误
    if key == "error" {
        return "", NewCacheError(
            NetworkError,
            "Network connection failed",
            errors.New("connection timeout"),
        )
    }

    return "value_" + key, nil
}

func main() {
    value, err := redisGet("key1")
    if err != nil {
        if cacheErr, ok := err.(*CacheError); ok {
            switch cacheErr.Code {
            case NetworkError:
                fmt.Println("Network error, retrying...")
            case ParameterError:
                fmt.Println("Invalid parameter")
            }
        }
        return
    }

    fmt.Println("Value:", value)
}
```

**错误包装和链式错误（Go）**：

```go
package main

import (
    "errors"
    "fmt"
)

func wrapError(operation string, err error) error {
    return fmt.Errorf("%s failed: %w", operation, err)
}

func redisGet(key string) (string, error) {
    if err := validateKey(key); err != nil {
        return "", wrapError("validateKey", err)
    }

    if err := connectRedis(); err != nil {
        return "", wrapError("connectRedis", err)
    }

    return "value_" + key, nil
}

func validateKey(key string) error {
    if key == "" {
        return errors.New("key cannot be empty")
    }
    return nil
}

func connectRedis() error {
    return errors.New("connection timeout")
}

func main() {
    value, err := redisGet("key1")
    if err != nil {
        fmt.Printf("Error: %v\n", err)

        // 检查原始错误
        if errors.Is(err, errors.New("connection timeout")) {
            fmt.Println("Connection timeout detected")
        }
    } else {
        fmt.Println("Value:", value)
    }
}
```

---

### 5.5 Rust实现

**错误类型定义（Rust）**：

```rust
use std::fmt;

#[derive(Debug, Clone)]
pub enum ErrorCode {
    Success,
    NetworkError,
    TimeoutError,
    PermissionError,
    ParameterError,
    SystemError,
}

#[derive(Debug)]
pub struct CacheError {
    pub code: ErrorCode,
    pub message: String,
    pub user_message: String,
    pub cause: Option<Box<dyn std::error::Error>>,
}

impl fmt::Display for CacheError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{:?}] {}", self.code, self.message)
    }
}

impl std::error::Error for CacheError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.cause.as_ref().map(|e| e.as_ref() as &dyn std::error::Error)
    }
}

impl CacheError {
    pub fn new(code: ErrorCode, message: String) -> Self {
        Self {
            code,
            user_message: message.clone(),
            message,
            cause: None,
        }
    }

    pub fn with_cause(code: ErrorCode, message: String, cause: Box<dyn std::error::Error>) -> Self {
        Self {
            code,
            user_message: message.clone(),
            message,
            cause: Some(cause),
        }
    }
}

// 使用示例
fn redis_get(key: &str) -> Result<String, CacheError> {
    if key.is_empty() {
        return Err(CacheError::new(
            ErrorCode::ParameterError,
            "Key cannot be empty".to_string(),
        ));
    }

    // 模拟网络错误
    if key == "error" {
        return Err(CacheError::with_cause(
            ErrorCode::NetworkError,
            "Network connection failed".to_string(),
            Box::new(std::io::Error::new(
                std::io::ErrorKind::TimedOut,
                "connection timeout",
            )),
        ));
    }

    Ok(format!("value_{}", key))
}

fn main() {
    match redis_get("key1") {
        Ok(value) => println!("Value: {}", value),
        Err(e) => {
            match e.code {
                ErrorCode::NetworkError => println!("Network error, retrying..."),
                ErrorCode::ParameterError => println!("Invalid parameter"),
                _ => println!("Error: {}", e),
            }
        }
    }
}
```

**Result类型和错误传播（Rust）**：

```rust
use std::io;

type Result<T> = std::result::Result<T, CacheError>;

fn redis_get(key: &str) -> Result<String> {
    validate_key(key)?;
    connect_redis()?;
    Ok(format!("value_{}", key))
}

fn validate_key(key: &str) -> Result<()> {
    if key.is_empty() {
        return Err(CacheError::new(
            ErrorCode::ParameterError,
            "Key cannot be empty".to_string(),
        ));
    }
    Ok(())
}

fn connect_redis() -> Result<()> {
    Err(CacheError::with_cause(
        ErrorCode::NetworkError,
        "Connection failed".to_string(),
        Box::new(io::Error::new(
            io::ErrorKind::TimedOut,
            "connection timeout",
        )),
    ))
}

fn main() {
    match redis_get("key1") {
        Ok(value) => println!("Success: {}", value),
        Err(e) => {
            eprintln!("Error: {}", e);
            if let Some(cause) = e.source() {
                eprintln!("Caused by: {}", cause);
            }
        }
    }
}
```

---

### 5.6 C/C++实现

**错误码定义（C）**：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

typedef enum {
    ERROR_SUCCESS = 0,
    ERROR_NETWORK = 1001,
    ERROR_TIMEOUT = 1002,
    ERROR_PERMISSION = 2001,
    ERROR_PARAMETER = 2002,
    ERROR_SYSTEM = 3001
} ErrorCode;

typedef struct {
    ErrorCode code;
    char* message;
    char* user_message;
    int errno_value;
} CacheError;

CacheError* cache_error_create(ErrorCode code, const char* message) {
    CacheError* err = malloc(sizeof(CacheError));
    if (!err) return NULL;

    err->code = code;
    err->message = strdup(message);
    err->user_message = strdup(message);
    err->errno_value = 0;

    return err;
}

void cache_error_destroy(CacheError* err) {
    if (err) {
        free(err->message);
        free(err->user_message);
        free(err);
    }
}

const char* cache_error_to_string(CacheError* err) {
    if (!err) return "Unknown error";
    return err->user_message;
}

// 使用示例
int redis_get(const char* key, char** value, CacheError** error) {
    if (!key || strlen(key) == 0) {
        *error = cache_error_create(ERROR_PARAMETER, "Key cannot be empty");
        return -1;
    }

    // 模拟网络错误
    if (strcmp(key, "error") == 0) {
        *error = cache_error_create(ERROR_NETWORK, "Network connection failed");
        return -1;
    }

    *value = malloc(strlen(key) + 7);
    sprintf(*value, "value_%s", key);
    return 0;
}

int main() {
    char* value = NULL;
    CacheError* error = NULL;

    if (redis_get("key1", &value, &error) == 0) {
        printf("Value: %s\n", value);
        free(value);
    } else {
        if (error) {
            switch (error->code) {
                case ERROR_NETWORK:
                    printf("Network error, retrying...\n");
                    break;
                case ERROR_PARAMETER:
                    printf("Invalid parameter\n");
                    break;
                default:
                    printf("Error: %s\n", cache_error_to_string(error));
            }
            cache_error_destroy(error);
        }
    }

    return 0;
}
```

**异常处理（C++）**：

```cpp
#include <stdexcept>
#include <string>
#include <iostream>

enum class ErrorCode {
    Success,
    NetworkError,
    TimeoutError,
    PermissionError,
    ParameterError,
    SystemError
};

class CacheException : public std::runtime_error {
private:
    ErrorCode code_;
    std::string user_message_;

public:
    CacheException(ErrorCode code, const std::string& message)
        : std::runtime_error(message)
        , code_(code)
        , user_message_(message)
    {
    }

    ErrorCode GetCode() const { return code_; }
    const std::string& GetUserMessage() const { return user_message_; }
};

std::string redis_get(const std::string& key) {
    if (key.empty()) {
        throw CacheException(
            ErrorCode::ParameterError,
            "Key cannot be empty"
        );
    }

    if (key == "error") {
        throw CacheException(
            ErrorCode::NetworkError,
            "Network connection failed"
        );
    }

    return "value_" + key;
}

int main() {
    try {
        std::string value = redis_get("key1");
        std::cout << "Value: " << value << std::endl;
    } catch (const CacheException& e) {
        switch (e.GetCode()) {
            case ErrorCode::NetworkError:
                std::cout << "Network error, retrying..." << std::endl;
                break;
            case ErrorCode::ParameterError:
                std::cout << "Invalid parameter" << std::endl;
                break;
            default:
                std::cerr << "Error: " << e.what() << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Unexpected error: " << e.what() << std::endl;
    }

    return 0;
}
```

---

## 6. 最佳实践

1. **异常分类**：根据异常类型选择合适的处理策略
2. **错误传播**：使用异常链保留原始异常信息
3. **日志记录**：记录详细的异常信息便于排查
4. **用户提示**：提供用户友好的错误提示
5. **监控告警**：监控异常统计，及时告警

---

## 7. 扩展阅读

- [容错机制设计](./02.06.01-容错机制设计.md)
- [程序设计示例](./02.06.03-程序设计示例.md)
- [故障传播分析](../../05-全栈分析/05.06-系统动态特征/05.06.03-故障传播分析.md)

---

## 8. 权威参考

### 8.1 学术论文

1. **"Exception Handling Best Practices"** - ACM Computing Surveys, 2010

### 8.2 官方文档

1. **"Python Exception Handling"** - Python Documentation
   - URL: <https://docs.python.org/3/tutorial/errors.html>

### 8.3 经典书籍

1. **《Effective Java》** - Joshua Bloch, Addison-Wesley, 2018
   - ISBN: 978-0134685991
   - 内容: Java异常处理最佳实践

---

**文档版本**：v1.0
**最后更新**：2025-01
**文档状态**：✅ 完成
