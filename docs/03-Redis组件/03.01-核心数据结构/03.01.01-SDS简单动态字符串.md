# 03.01.01 SDS简单动态字符串

## 目录

- [03.01.01 SDS简单动态字符串](#030101-sds简单动态字符串)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 设计目标](#12-设计目标)
    - [1.3 应用价值](#13-应用价值)
  - [2. 数据结构设计](#2-数据结构设计)
    - [2.1 结构体定义](#21-结构体定义)
    - [2.2 类型标记](#22-类型标记)
    - [2.3 内存布局分析](#23-内存布局分析)
  - [3. 核心特性](#3-核心特性)
    - [3.1 O(1)长度获取](#31-o1长度获取)
    - [3.2 二进制安全](#32-二进制安全)
    - [3.3 空间预分配策略](#33-空间预分配策略)
    - [3.4 惰性空间释放](#34-惰性空间释放)
  - [4. 性能分析](#4-性能分析)
    - [4.1 时间复杂度分析](#41-时间复杂度分析)
    - [4.2 空间复杂度分析](#42-空间复杂度分析)
    - [4.3 内存效率分析](#43-内存效率分析)
  - [5. 实现细节](#5-实现细节)
    - [5.1 扩容策略](#51-扩容策略)
    - [5.2 惰性空间释放](#52-惰性空间释放)
  - [6. Redis中的应用](#6-redis中的应用)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 程序设计分析](#8-程序设计分析)
    - [8.1 设计模式应用](#81-设计模式应用)
    - [8.2 代码结构分析](#82-代码结构分析)
    - [8.3 设计权衡](#83-设计权衡)
    - [8.4 可扩展性分析](#84-可扩展性分析)
  - [9. 扩展阅读](#9-扩展阅读)
  - [10. 权威参考](#10-权威参考)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 经典书籍](#102-经典书籍)
    - [10.3 在线资源](#103-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**SDS（Simple Dynamic String，简单动态字符串）**是Redis自定义的字符串实现，相比C字符串提供了更强大的功能和更好的性能。

**历史发展**：

- **2009年**：Redis 1.0引入SDS，解决C字符串的局限性
- **2012年**：Redis 2.6优化SDS实现，改进内存分配策略
- **2015年**：Redis 3.2引入多类型SDS（sdshdr5/8/16/32/64），大幅优化内存使用
- **2020年代**：SDS成为Redis核心数据结构，广泛应用于所有字符串操作

### 1.2 设计目标

SDS设计目标：解决C字符串的四个核心问题

1. **O(1)长度获取**：C字符串需要O(N)遍历
2. **二进制安全**：C字符串以'\0'结尾，无法存储二进制数据
3. **缓冲区溢出**：C字符串容易发生缓冲区溢出
4. **内存重分配**：频繁的内存分配/释放影响性能

### 1.3 应用价值

SDS在Redis中具有重要价值：

1. **字符串键值**：所有字符串键值都使用SDS存储
2. **命令参数**：Redis命令参数使用SDS存储
3. **AOF缓冲区**：AOF日志缓冲区使用SDS
4. **客户端缓冲区**：客户端输入输出缓冲区使用SDS
5. **内部数据结构**：哈希表、列表等内部也使用SDS

## 2. 数据结构设计

### 2.1 结构体定义

```c
// Redis 3.2之前的SDS结构
struct sdshdr {
    unsigned int len;        // 已使用长度
    unsigned int free;       // 剩余空间
    char buf[];              // 柔性数组，存储数据
};

// Redis 3.2+的优化结构（根据长度选择不同结构）
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags;     // 低3位存储类型，高5位存储长度
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;            // 已使用长度
    uint8_t alloc;          // 总分配空间（不包括header和'\0'）
    unsigned char flags;    // 类型标记
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc;
    unsigned char flags;
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len;
    uint64_t alloc;
    unsigned char flags;
    char buf[];
};
```

### 2.2 类型标记

### 2.3 内存布局分析

**内存布局对比**：

| 类型 | Header大小 | 最大长度 | 内存效率 |
|------|-----------|---------|---------|
| **sdshdr5** | 1字节 | 31字节 | 96.9% |
| **sdshdr8** | 3字节 | 255字节 | 98.8% |
| **sdshdr16** | 5字节 | 65535字节 | 99.2% |
| **sdshdr32** | 9字节 | 4GB | 99.8% |
| **sdshdr64** | 17字节 | 16EB | 99.9% |

**内存效率公式**：

$$\text{内存效率} = \frac{\text{数据大小}}{\text{总分配大小}} = \frac{len}{len + header + free}$$

其中：

- $len$：已使用长度
- $header$：头部大小（1-17字节）
- $free$：剩余空间

```c
#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4

// 根据字符串长度自动选择类型
static inline char sdsReqType(size_t string_size) {
    if (string_size < 1<<5)
        return SDS_TYPE_5;
    if (string_size < 1<<8)
        return SDS_TYPE_8;
    if (string_size < 1<<16)
        return SDS_TYPE_16;
    if (string_size < 1ll<<32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
}
```

## 3. 核心特性

### 3.1 O(1)长度获取

**时间复杂度证明**：

**定理 3.1**：SDS长度获取的时间复杂度为O(1)。

**证明**：

- SDS在header中存储长度信息
- 通过指针偏移直接访问header：$header = s - sizeof(sdshdr)$
- 读取header中的len字段：$len = header->len$
- 总操作数：2次内存访问 = O(1)

**对比C字符串**：

- C字符串需要遍历整个字符串直到'\0'
- 最坏情况：O(N)，其中N为字符串长度

```c
// C字符串：O(N)
size_t strlen(const char *s) {
    size_t len = 0;
    while (s[len] != '\0') len++;
    return len;
}

// SDS：O(1)
static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}
```

### 3.2 二进制安全

**二进制安全性证明**：

**定理 3.2**：SDS可以安全存储任意二进制数据，包括'\0'字符。

**证明**：

- SDS使用长度字段而非'\0'终止符
- 数据存储：$data[i], i \in [0, len-1]$
- 长度限制：由len字段决定，不受'\0'影响
- 因此可以存储包含'\0'的任意二进制数据

```c
// C字符串：无法存储包含'\0'的数据
char *str = "hello\0world";  // strlen(str) = 5，丢失数据

// SDS：可以存储任意二进制数据
sds s = sdsnewlen("hello\0world", 11);  // 完整保存11字节
size_t len = sdslen(s);  // len = 11
```

### 3.3 空间预分配策略

**预分配策略分析**：

**策略1**：小于1MB时，双倍扩容
$$newlen = len \times 2$$

**策略2**：大于1MB时，每次增加1MB
$$newlen = len + 1MB$$

**空间复杂度分析**：

**定理 3.3**：SDS预分配策略的摊销时间复杂度为O(1)。

**证明**：

使用摊还分析（Amortized Analysis）：

假设进行$n$次追加操作，每次追加1字节：

- **第1次**：分配2字节，复制1字节，成本=3
- **第2次**：无需分配，成本=1
- **第3次**：分配4字节，复制2字节，成本=6
- **第4次**：无需分配，成本=1
- ...

总成本：$T(n) = O(n)$
摊销成本：$T(n)/n = O(1)$

因此，每次操作的摊销时间复杂度为O(1)。

### 3.4 惰性空间释放

**惰性释放策略**：

当字符串缩短时，SDS不会立即释放多余空间，而是保留在free字段中，以便后续扩展时复用。

**优势**：

- 减少内存分配次数
- 提高后续操作性能
- 降低内存碎片

## 4. 性能分析

### 4.1 时间复杂度分析

| 操作 | C字符串 | SDS | 改进 |
|------|---------|-----|------|
| **长度获取** | O(N) | O(1) | 显著提升 |
| **追加** | O(N) | O(1)摊销 | 显著提升 |
| **连接** | O(N+M) | O(M)摊销 | 提升 |
| **比较** | O(N) | O(N) | 相同 |

### 4.2 空间复杂度分析

**空间开销**：

- **C字符串**：$N + 1$字节（N字节数据 + 1字节'\0'）
- **SDS**：$header + N + free + 1$字节
  - header：1-17字节（取决于类型）
  - free：预分配空间
  - 1字节：'\0'终止符（兼容C函数）

**空间效率**：

对于短字符串（<32字节），SDS的空间效率：
$$\text{效率} = \frac{N}{header + N + free + 1} \approx 70-90\%$$

对于长字符串（>1KB），SDS的空间效率：
$$\text{效率} = \frac{N}{header + N + free + 1} \approx 95-99\%$$

### 4.3 内存效率分析

**多类型SDS的内存优化**：

Redis 3.2+根据字符串长度自动选择最优类型：

| 长度范围 | 使用类型 | Header大小 | 节省内存 |
|---------|---------|-----------|---------|
| 0-31字节 | sdshdr5 | 1字节 | 最多节省15字节 |
| 32-255字节 | sdshdr8 | 3字节 | 最多节省13字节 |
| 256-65535字节 | sdshdr16 | 5字节 | 最多节省11字节 |

**内存节省公式**：

$$\text{节省} = (old\_header - new\_header) \times \text{字符串数量}$$

对于大量短字符串，内存节省可达30-50%。

## 5. 实现细节

### 5.1 扩容策略

```c
// 扩容策略
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    size_t avail = sdsavail(s);
    size_t len, newlen;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;

    // 如果剩余空间足够，直接返回
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s - sdsHdrSize(oldtype);
    newlen = (len + addlen);

    // 预分配策略
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;  // 小于1MB，双倍扩容
    else
        newlen += SDS_MAX_PREALLOC;  // 大于1MB，每次增加1MB

    type = sdsReqType(newlen);

    // 如果类型不变，使用realloc
    if (type == oldtype) {
        newsh = s_realloc(sh, sdsHdrSize(type) + newlen + 1);
        if (newsh == NULL) return NULL;
        s = (char*)newsh + sdsHdrSize(type);
    } else {
        // 类型变化，需要重新分配
        newsh = s_malloc(sdsHdrSize(type) + newlen + 1);
        if (newsh == NULL) return NULL;
        memcpy((char*)newsh + sdsHdrSize(type), s, len + 1);
        s_free(sh);
        s = (char*)newsh + sdsHdrSize(type);
        s[-1] = type;
        sdssetlen(s, len);
    }

    sdssetalloc(s, newlen);
    return s;
}
```

**预分配策略**：

- `len < 1MB`：分配 `len * 2` 空间
- `len >= 1MB`：分配 `len + 1MB` 空间

**优势**：减少内存重分配次数，提升性能。

### 5.2 惰性空间释放

```c
// 缩短字符串时不立即释放内存
sds sdstrim(sds s, const char *cset) {
    char *start, *end, *sp, *ep;
    size_t len;

    sp = start = s;
    ep = end = s + sdslen(s) - 1;

    // 从两端删除指定字符
    while(sp <= end && strchr(cset, *sp)) sp++;
    while(ep > sp && strchr(cset, *ep)) ep--;

    len = (sp > ep) ? 0 : ((ep-sp)+1);

    if (s != sp) memmove(s, sp, len);
    s[len] = '\0';
    sdssetlen(s, len);

    // 不立即释放内存，保留在free字段中供后续使用
    return s;
}
```

**惰性释放的优势**：

**定理 5.1**：惰性空间释放策略的摊销时间复杂度为O(1)。

**证明**：

- 释放操作：O(1)（仅更新len字段）
- 后续扩展：O(1)摊销（复用free空间）
- 总摊销成本：O(1)

## 6. Redis中的应用

SDS在Redis中的应用：

1. **字符串键值**：所有字符串键值都使用SDS存储
2. **命令参数**：Redis命令参数使用SDS存储
3. **AOF缓冲区**：AOF日志缓冲区使用SDS
4. **客户端缓冲区**：客户端输入输出缓冲区使用SDS

## 7. 适用场景

### 7.1 优势场景

1. **频繁长度查询**：需要O(1)长度获取的场景
2. **二进制数据**：需要存储图片、视频等二进制数据
3. **动态字符串**：需要频繁追加、修改的字符串
4. **内存优化**：大量短字符串需要优化内存使用

### 7.2 不适用场景

1. **静态字符串**：字符串长度固定且不变化
2. **内存极度受限**：无法接受header开销的场景

## 8. 程序设计分析

### 8.1 设计模式应用

**使用的设计模式**：

1. **适配器模式**：SDS适配C字符串接口，提供兼容性
2. **策略模式**：不同类型SDS（sdshdr5/8/16/32/64）作为不同策略
3. **享元模式**：共享字符串常量，减少内存占用

**策略模式实现**：

```c
// SDS类型策略
typedef enum {
    SDS_TYPE_5 = 0,
    SDS_TYPE_8 = 1,
    SDS_TYPE_16 = 2,
    SDS_TYPE_32 = 3,
    SDS_TYPE_64 = 4
} sds_type_t;

// 根据长度选择类型
sds_type_t sds_select_type(size_t len) {
    if (len < 1 << 5) return SDS_TYPE_5;
    if (len < 1 << 8) return SDS_TYPE_8;
    if (len < 1 << 16) return SDS_TYPE_16;
    if (len < 1 << 32) return SDS_TYPE_32;
    return SDS_TYPE_64;
}
```

### 8.2 代码结构分析

**代码组织**：

1. **类型层**：sdshdr5/8/16/32/64结构定义
2. **操作层**：SDS核心操作（创建、追加、释放）
3. **工具层**：辅助函数（类型转换、内存管理）

**模块化设计**：

- **高内聚**：SDS相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的SDS类型

### 8.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 内存** | 多类型SDS | 平衡性能和内存使用 |
| **简单 vs 复杂** | 多类型设计 | 优化内存使用 |
| **通用 vs 专用** | 通用字符串实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{memory} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（O(1)长度获取）
- $C_{memory}$：内存成本（header开销，多类型优化）
- $C_{complexity}$：复杂度成本（多类型实现，复杂度较高）

### 8.4 可扩展性分析

**扩展点**：

1. **新SDS类型**：可扩展为其他大小的SDS类型
2. **新操作**：可扩展为其他字符串操作
3. **压缩SDS**：可扩展为压缩字符串实现

**扩展性设计**：

```c
// 可扩展的SDS接口
typedef struct sds {
    void *header;  // 指向不同类型的header
    char *buf;    // 字符串缓冲区
    size_t len;   // 字符串长度
    size_t free;  // 剩余空间
} sds;
```

**可维护性**：

- **代码清晰**：SDS逻辑清晰，易于理解
- **易于调试**：SDS状态易于监控和调试
- **测试友好**：SDS行为易于测试和验证

## 9. 扩展阅读

- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 10. 权威参考

### 10.1 官方文档

1. **Redis源码 - sds.h/sds.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/sds.h>
   - URL: <https://github.com/redis/redis/blob/unstable/src/sds.c>
   - 版本: Redis 3.2+
   - SDS的完整实现源码

2. **Redis官方文档 - Strings**
   - URL: <https://redis.io/docs/data-types/strings/>
   - 版本: Redis 7.0+
   - Redis字符串类型的官方文档

### 10.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第2章：简单动态字符串（详细分析SDS设计）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第1章：Redis基础数据结构（SDS详解）

### 10.3 在线资源

1. **Wikipedia - Dynamic String**
   - URL: <https://en.wikipedia.org/wiki/Dynamic_string>
   - 提供动态字符串的通用说明

2. **Redis源码分析 - SDS**
   - URL: <https://github.com/antirez/redis>
   - Redis官方GitHub仓库，包含SDS的完整实现和注释
