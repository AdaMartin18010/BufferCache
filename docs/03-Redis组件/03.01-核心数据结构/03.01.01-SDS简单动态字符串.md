# 03.01.01 SDS简单动态字符串

## 概述

SDS（Simple Dynamic String，简单动态字符串）是Redis自定义的字符串实现，相比C字符串提供了更强大的功能和更好的性能。

## 设计目标

### 解决的问题

1. **O(1)长度获取**：C字符串需要O(N)遍历
2. **二进制安全**：C字符串以'\0'结尾，无法存储二进制数据
3. **缓冲区溢出**：C字符串容易发生缓冲区溢出
4. **内存重分配**：频繁的内存分配/释放影响性能

## 数据结构设计

### 结构体定义

```c
// Redis 3.2之前的SDS结构
struct sdshdr {
    unsigned int len;        // 已使用长度
    unsigned int free;       // 剩余空间
    char buf[];              // 柔性数组，存储数据
};

// Redis 3.2+的优化结构（根据长度选择不同结构）
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags;     // 低3位存储类型，高5位存储长度
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;            // 已使用长度
    uint8_t alloc;          // 总分配空间（不包括header和'\0'）
    unsigned char flags;    // 类型标记
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len;
    uint16_t alloc;
    unsigned char flags;
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len;
    uint32_t alloc;
    unsigned char flags;
    char buf[];
};

struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len;
    uint64_t alloc;
    unsigned char flags;
    char buf[];
};
```

### 类型标记

```c
#define SDS_TYPE_5  0
#define SDS_TYPE_8  1
#define SDS_TYPE_16 2
#define SDS_TYPE_32 3
#define SDS_TYPE_64 4

// 根据字符串长度自动选择类型
static inline char sdsReqType(size_t string_size) {
    if (string_size < 1<<5)
        return SDS_TYPE_5;
    if (string_size < 1<<8)
        return SDS_TYPE_8;
    if (string_size < 1<<16)
        return SDS_TYPE_16;
    if (string_size < 1ll<<32)
        return SDS_TYPE_32;
    return SDS_TYPE_64;
}
```

## 核心特性

### 1. O(1)长度获取

```c
// C字符串：O(N)
size_t strlen(const char *s) {
    size_t len = 0;
    while (s[len] != '\0') len++;
    return len;
}

// SDS：O(1)
static inline size_t sdslen(const sds s) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            return SDS_TYPE_5_LEN(flags);
        case SDS_TYPE_8:
            return SDS_HDR(8,s)->len;
        case SDS_TYPE_16:
            return SDS_HDR(16,s)->len;
        case SDS_TYPE_32:
            return SDS_HDR(32,s)->len;
        case SDS_TYPE_64:
            return SDS_HDR(64,s)->len;
    }
    return 0;
}
```

### 2. 二进制安全

```c
// C字符串：无法存储包含'\0'的数据
char *str = "hello\0world";  // strlen(str) = 5，丢失数据

// SDS：可以存储任意二进制数据
sds s = sdsnewlen("hello\0world", 11);  // 完整保存11字节
size_t len = sdslen(s);  // len = 11
```

### 3. 空间预分配策略

```c
// 扩容策略
sds sdsMakeRoomFor(sds s, size_t addlen) {
    void *sh, *newsh;
    size_t avail = sdsavail(s);
    size_t len, newlen;
    char type, oldtype = s[-1] & SDS_TYPE_MASK;
    int hdrlen;

    // 如果剩余空间足够，直接返回
    if (avail >= addlen) return s;

    len = sdslen(s);
    sh = (char*)s - sdsHdrSize(oldtype);
    newlen = (len + addlen);

    // 预分配策略
    if (newlen < SDS_MAX_PREALLOC)
        newlen *= 2;  // 小于1MB，双倍扩容
    else
        newlen += SDS_MAX_PREALLOC;  // 大于1MB，每次增加1MB

    type = sdsReqType(newlen);

    // 如果类型不变，使用realloc
    if (type == oldtype) {
        newsh = s_realloc(sh, sdsHdrSize(type) + newlen + 1);
        if (newsh == NULL) return NULL;
        s = (char*)newsh + sdsHdrSize(type);
    } else {
        // 类型变化，需要重新分配
        newsh = s_malloc(sdsHdrSize(type) + newlen + 1);
        if (newsh == NULL) return NULL;
        memcpy((char*)newsh + sdsHdrSize(type), s, len + 1);
        s_free(sh);
        s = (char*)newsh + sdsHdrSize(type);
        s[-1] = type;
        sdssetlen(s, len);
    }

    sdssetalloc(s, newlen);
    return s;
}
```

**预分配策略**：

- `len < 1MB`：分配 `len * 2` 空间
- `len >= 1MB`：分配 `len + 1MB` 空间

**优势**：减少内存重分配次数，提升性能。

### 4. 惰性空间释放

```c
// 缩短字符串时不立即释放内存
sds sdstrim(sds s, const char *cset) {
    char *start, *end, *sp, *ep;
    size_t len;

    sp = start = s;
    ep = end = s + sdslen(s) - 1;

    // 从两端删除指定字符
    while(sp <= end && strchr(cset, *sp)) sp++;
    while(ep > sp && strchr(cset, *ep)) ep--;

    len = (sp > ep) ? 0 : ((ep-sp)+1);

    if (s != sp) memmove(s, sp, len);
    s[len] = '\0';
    sdssetlen(s, len);

    // 不立即释放内存，保留在free字段中供后续使用
    return s;
}
```

## 性能对比

| 操作 | C字符串 | SDS | 性能提升 |
|------|---------|-----|----------|
| 长度获取 | O(N) | O(1) | **N倍** |
| 追加操作 | O(N) | O(1) | **N倍** |
| 二进制安全 | ❌ | ✅ | - |
| 缓冲区溢出 | 易发生 | 安全 | - |

## 内存优化

### 内存对齐优化

```c
// 使用__attribute__ ((__packed__))避免内存对齐
// 减少内存占用
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len;      // 1字节
    uint8_t alloc;    // 1字节
    unsigned char flags;  // 1字节
    char buf[];       // 柔性数组
};
// 总计：3字节header + 数据
```

### 类型选择优化

```c
// 根据字符串长度选择最小类型
// 短字符串：sdshdr8（3字节header）
// 长字符串：sdshdr64（17字节header）
// 内存节省：小字符串节省14字节/个
```

## 使用示例

### 基本操作

```c
// 创建SDS
sds s = sdsnew("hello");
printf("Length: %zu\n", sdslen(s));  // 5

// 追加字符串
s = sdscat(s, " world");
printf("Length: %zu\n", sdslen(s));  // 11

// 追加格式化字符串
s = sdscatprintf(s, " %d", 2025);
printf("Length: %zu\n", sdslen(s));  // 16

// 释放SDS
sdsfree(s);
```

### 二进制数据操作

```c
// 创建二进制安全的SDS
sds s = sdsnewlen("hello\0world", 11);
printf("Length: %zu\n", sdslen(s));  // 11（包含'\0'）

// 可以存储图片、视频等二进制数据
unsigned char *image_data = read_image_file("image.jpg");
sds image_sds = sdsnewlen(image_data, image_size);
```

## 与C字符串兼容

```c
// SDS以'\0'结尾，兼容C字符串函数
sds s = sdsnew("hello");
printf("%s\n", s);  // 可以直接使用printf

// 但SDS长度通过len字段获取，不依赖'\0'
size_t len = sdslen(s);  // O(1)
```

## 扩展阅读

- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **SDS设计文档** - Redis官方文档
