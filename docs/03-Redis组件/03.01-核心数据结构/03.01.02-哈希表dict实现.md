# 03.01.02 哈希表dict实现

## 概述

Redis的哈希表（dict）是核心数据结构之一，用于实现Hash类型和整个Redis数据库的键空间。采用链地址法解决冲突，支持渐进式rehash。

## 数据结构设计

### 哈希表结构

```c
// 哈希表节点
typedef struct dictEntry {
    void *key;              // 键
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;                    // 值
    struct dictEntry *next; // 指向下一个节点（冲突链表）
} dictEntry;

// 哈希表
typedef struct dictht {
    dictEntry **table;      // 哈希表数组
    unsigned long size;     // 哈希表大小（2的幂）
    unsigned long sizemask; // 掩码，等于size-1
    unsigned long used;     // 已使用节点数
} dictht;

// 字典
typedef struct dict {
    dictType *type;         // 类型特定函数
    void *privdata;         // 私有数据
    dictht ht[2];           // 两个哈希表（用于rehash）
    long rehashidx;         // rehash索引，-1表示未进行rehash
    int iterators;          // 迭代器数量
} dict;
```

### 哈希表类型

```c
// 字典类型函数
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);        // 哈希函数
    void *(*keyDup)(void *privdata, const void *key); // 键复制
    void *(*valDup)(void *privdata, const void *obj); // 值复制
    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 键比较
    void (*keyDestructor)(void *privdata, void *key); // 键销毁
    void (*valDestructor)(void *privdata, void *obj); // 值销毁
} dictType;
```

## 哈希函数

### MurmurHash2

Redis默认使用MurmurHash2算法：

```c
uint64_t dictGenHashFunction(const void *key, int len) {
    // MurmurHash2实现
    uint32_t seed = 5381;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;

    uint32_t h = seed ^ len;
    const unsigned char *data = (const unsigned char *)key;

    while (len >= 4) {
        uint32_t k = *(uint32_t*)data;

        k *= m;
        k ^= k >> r;
        k *= m;

        h *= m;
        h ^= k;

        data += 4;
        len -= 4;
    }

    switch(len) {
        case 3: h ^= data[2] << 16;
        case 2: h ^= data[1] << 8;
        case 1: h ^= data[0];
                h *= m;
    }

    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;

    return h;
}
```

**优势**：
- 分布均匀，碰撞率低
- 性能高，适合字符串键
- 对输入顺序敏感

### SipHash（Redis 3.2+）

对于小字符串，Redis使用SipHash防止哈希碰撞攻击：

```c
uint64_t siphash(const uint8_t *in, const size_t inlen,
                 const uint8_t *k) {
    // SipHash实现
    // 防止哈希碰撞攻击
}
```

## 冲突解决

### 链地址法

```c
// 插入操作
int dictAdd(dict *d, void *key, void *val) {
    dictEntry *entry = dictAddRaw(d, key, NULL);
    if (!entry) return DICT_ERR;

    dictSetVal(d, entry, val);
    return DICT_OK;
}

dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing) {
    int index;
    dictEntry *entry;
    dictht *ht;

    // 如果正在rehash，执行一步rehash
    if (dictIsRehashing(d)) _dictRehashStep(d);

    // 计算索引
    if ((index = _dictKeyIndex(d, key, dictHashKey(d, key), existing)) == -1)
        return NULL;

    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
    entry = zmalloc(sizeof(*entry));

    // 插入到链表头部
    entry->next = ht->table[index];
    ht->table[index] = entry;
    ht->used++;

    dictSetKey(d, entry, key);
    return entry;
}
```

## 渐进式Rehash

### 设计目的

避免集中式rehash导致的性能抖动，将O(N)的rehash操作分散到N次操作中。

### 实现机制

```c
// 渐进式rehash
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10;  // 最大空桶访问次数

    if (!dictIsRehashing(d)) return 0;

    while (n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        // 跳过空桶
        while (d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }

        de = d->ht[0].table[d->rehashidx];

        // 迁移该桶的所有节点
        while (de) {
            uint64_t h;
            nextde = de->next;

            // 计算新索引
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;

            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }

        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    // 检查是否完成rehash
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    return 1;
}

// 每次操作执行一步rehash
static void _dictRehashStep(dict *d) {
    if (d->iterators == 0) {
        dictRehash(d, 1);
    }
}
```

### 性能证明

详见：[证明图网-渐进式Rehash性能证明](../../00-项目总览/证明图网-核心机制证明.md#4-渐进式rehash性能证明)

## 扩容与缩容

### 扩容条件

```c
// 检查是否需要扩容
static int _dictExpandIfNeeded(dict *d) {
    if (dictIsRehashing(d)) return DICT_OK;

    // 如果哈希表为空，初始化为4
    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    // 负载因子 >= 1 且允许resize，或者负载因子 >= 5（强制resize）
    if (d->ht[0].used >= d->ht[0].size &&
        (dict_can_resize ||
         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio)) {
        return dictExpand(d, d->ht[0].used * 2);
    }

    return DICT_OK;
}
```

### 缩容条件

```c
// 检查是否需要缩容
static int _dictShrinkIfNeeded(dict *d) {
    if (dictIsRehashing(d) || d->ht[0].used == 0) return DICT_OK;

    // 负载因子 < 0.1 时缩容
    if (d->ht[0].size > DICT_HT_INITIAL_SIZE &&
        d->ht[0].used * 100 / d->ht[0].size < HASHTABLE_MIN_FILL) {
        return dictResize(d);
    }

    return DICT_OK;
}
```

## 负载因子控制

### 负载因子定义

$$\text{负载因子} = \frac{\text{已使用节点数}}{\text{哈希表大小}}$$

### 控制策略

| 负载因子 | 操作 | 说明 |
|----------|------|------|
| ≥ 1.0 | 扩容 | 触发扩容，新大小为2倍 |
| ≥ 5.0 | 强制扩容 | 即使不允许resize也强制扩容 |
| < 0.1 | 缩容 | 缩容到最小容量 |

### 性能影响

- **负载因子高**：冲突增多，链表变长，查询变慢
- **负载因子低**：内存浪费，但查询快
- **平衡点**：负载因子1.0是较好的平衡点

## 性能分析

### 时间复杂度

| 操作 | 平均 | 最坏 | 说明 |
|------|------|------|------|
| 查找 | O(1) | O(N) | 平均O(1)，最坏O(N)（所有key冲突） |
| 插入 | O(1) | O(N) | 平均O(1)，最坏O(N) |
| 删除 | O(1) | O(N) | 平均O(1)，最坏O(N) |
| Rehash | O(N) | O(N) | 渐进式分散到N次操作 |

### 空间复杂度

- **哈希表本身**：O(N)
- **冲突链表**：平均O(1)额外空间
- **Rehash期间**：O(2N)（两个哈希表）

## 优化策略

### 1. 预分配大小

```c
// 预估大小，避免频繁扩容
dict *d = dictCreate(&dictTypeHeapStrings, NULL);
dictExpand(d, estimated_size);
```

### 2. 批量操作

```c
// 批量插入，减少rehash次数
for (int i = 0; i < count; i++) {
    dictAdd(d, keys[i], vals[i]);
    // 每次操作可能触发rehash
}
```

### 3. 避免在迭代时rehash

```c
// 迭代时禁止rehash
dictIterator *iter = dictGetIterator(d);
dictEntry *de;
while ((de = dictNext(iter)) != NULL) {
    // 迭代过程中不会rehash
    process(de);
}
dictReleaseIterator(iter);
```

## 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [渐进式Rehash性能证明](../../00-项目总览/证明图网-核心机制证明.md#4-渐进式rehash性能证明)
- [Redis内存管理](../03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **《算法导论》** - MIT Press（哈希表章节）
