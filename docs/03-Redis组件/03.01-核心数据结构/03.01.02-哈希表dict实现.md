# 03.01.02 哈希表dict实现

## 目录

- [03.01.02 哈希表dict实现](#030102-哈希表dict实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 数据结构设计](#2-数据结构设计)
    - [2.1 哈希表结构](#21-哈希表结构)
    - [2.2 哈希表类型](#22-哈希表类型)
  - [3. 哈希函数](#3-哈希函数)
    - [3.1 MurmurHash2](#31-murmurhash2)
    - [3.2 哈希函数性能分析](#32-哈希函数性能分析)
    - [3.3 SipHash（Redis 3.2+）](#33-siphashredis-32)
  - [4. 核心操作](#4-核心操作)
    - [4.1 查找操作](#41-查找操作)
    - [4.2 插入操作](#42-插入操作)
    - [4.3 删除操作](#43-删除操作)
  - [5. 渐进式Rehash](#5-渐进式rehash)
    - [5.1 Rehash原理](#51-rehash原理)
    - [5.2 Rehash流程](#52-rehash流程)
    - [5.3 性能分析](#53-性能分析)
  - [6. 性能优化](#6-性能优化)
    - [6.1 负载因子控制](#61-负载因子控制)
    - [6.2 优化策略](#62-优化策略)
      - [6.2.1 预分配大小](#621-预分配大小)
      - [6.2.2 批量操作](#622-批量操作)
      - [6.2.3 避免在迭代时rehash](#623-避免在迭代时rehash)
  - [7. Redis中的应用](#7-redis中的应用)
    - [缩容条件](#缩容条件)
  - [8. 程序设计分析](#8-程序设计分析)
    - [8.1 设计模式应用](#81-设计模式应用)
    - [8.2 代码结构分析](#82-代码结构分析)
    - [8.3 设计权衡](#83-设计权衡)
    - [8.4 可扩展性分析](#84-可扩展性分析)
  - [9. 扩展阅读](#9-扩展阅读)
  - [10. 权威参考](#10-权威参考)
    - [10.1 学术论文](#101-学术论文)
    - [10.2 官方文档](#102-官方文档)
    - [10.3 经典书籍](#103-经典书籍)
    - [10.4 在线资源](#104-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**dict（字典）**是Redis的核心数据结构之一，用于实现Hash类型和整个Redis数据库的键空间。采用链地址法解决冲突，支持渐进式rehash。

**版本信息**：

- **适用版本**：Redis 1.0+
- **文档基于版本**：Redis 7.2
- **最后更新**：2025-01

**历史发展**：

- **2009年**：Redis 1.0引入dict，使用链地址法
- **2010年**：Redis 2.0引入渐进式rehash，避免阻塞
- **2012年**：Redis 2.6优化rehash策略，提升性能
- **2015年**：Redis 3.2优化哈希函数，使用MurmurHash2
- **2020年代**：dict成为Redis最核心的数据结构
- **2023年**：Redis 7.2优化dict性能和内存使用

### 1.2 应用价值

dict在Redis中具有重要价值：

1. **键空间管理**：整个Redis数据库的键值对存储
2. **Hash类型**：Redis Hash数据类型的底层实现
3. **集合实现**：Set和Sorted Set的部分实现
4. **内部索引**：过期键、阻塞键等内部索引

## 2. 数据结构设计

### 2.1 哈希表结构

```c
// 哈希表节点
typedef struct dictEntry {
    void *key;              // 键
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;                    // 值
    struct dictEntry *next; // 指向下一个节点（冲突链表）
} dictEntry;

// 哈希表
typedef struct dictht {
    dictEntry **table;      // 哈希表数组
    unsigned long size;     // 哈希表大小（2的幂）
    unsigned long sizemask; // 掩码，等于size-1
    unsigned long used;     // 已使用节点数
} dictht;

// 字典
typedef struct dict {
    dictType *type;         // 类型特定函数
    void *privdata;         // 私有数据
    dictht ht[2];           // 两个哈希表（用于rehash）
    long rehashidx;         // rehash索引，-1表示未进行rehash
    int iterators;          // 迭代器数量
} dict;
```

### 2.2 哈希表类型

```c
// 字典类型函数
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);        // 哈希函数
    void *(*keyDup)(void *privdata, const void *key); // 键复制
    void *(*valDup)(void *privdata, const void *obj); // 值复制
    int (*keyCompare)(void *privdata, const void *key1, const void *key2); // 键比较
    void (*keyDestructor)(void *privdata, void *key); // 键销毁
    void (*valDestructor)(void *privdata, void *obj); // 值销毁
} dictType;
```

## 3. 哈希函数

### 3.1 MurmurHash2

Redis默认使用MurmurHash2算法：

```c
uint64_t dictGenHashFunction(const void *key, int len) {
    // MurmurHash2实现
    uint32_t seed = 5381;
    const uint32_t m = 0x5bd1e995;
    const int r = 24;

    uint32_t h = seed ^ len;
    const unsigned char *data = (const unsigned char *)key;

    while (len >= 4) {
        uint32_t k = *(uint32_t*)data;

        k *= m;
        k ^= k >> r;
        k *= m;

        h *= m;
        h ^= k;

        data += 4;
        len -= 4;
    }

    switch(len) {
        case 3: h ^= data[2] << 16;
        case 2: h ^= data[1] << 8;
        case 1: h ^= data[0];
                h *= m;
    }

    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;

    return h;
}
```

**优势**：

- 分布均匀，碰撞率低
- 性能高，适合字符串键
- 对输入顺序敏感

### 3.2 哈希函数性能分析

**MurmurHash2性能**：

| 指标 | 值 |
|------|-----|
| **吞吐量** | ~1.5 GB/s |
| **碰撞率** | < 0.001% |
| **时间复杂度** | O(N)，N为键长度 |

**定理 3.1**：MurmurHash2的哈希分布近似均匀。

**证明**：

- MurmurHash2使用混合运算（乘法、异或、位移）
- 对于随机输入，输出分布接近均匀分布
- 碰撞概率：$P(\text{碰撞}) \approx \frac{1}{2^{32}}$（32位哈希）

### 3.3 SipHash（Redis 3.2+）

对于小字符串，Redis使用SipHash防止哈希碰撞攻击：

对于小字符串，Redis使用SipHash防止哈希碰撞攻击：

```c
uint64_t siphash(const uint8_t *in, const size_t inlen,
                 const uint8_t *k) {
    // SipHash实现
    // 防止哈希碰撞攻击
}
```

## 4. 核心操作

### 4.1 查找操作

```c
// 查找操作
dictEntry *dictFind(dict *d, const void *key) {
    dictEntry *he;
    unsigned int h, idx, table;

    if (d->ht[0].used + d->ht[1].used == 0) return NULL;

    // 如果正在rehash，执行一步rehash
    if (dictIsRehashing(d)) _dictRehashStep(d);

    // 计算哈希值
    h = dictHashKey(d, key);

    // 在两个表中查找
    for (table = 0; table <= 1; table++) {
        idx = h & d->ht[table].sizemask;
        he = d->ht[table].table[idx];

        while(he) {
            if (key==he->key || dictCompareKeys(d, key, he->key))
                return he;
            he = he->next;
        }

        if (!dictIsRehashing(d)) break;
    }

    return NULL;
}
```

**时间复杂度分析**：

**定理 4.1**：dict查找操作的平均时间复杂度为O(1)。

**证明**：

- 哈希表平均负载因子：$\alpha = n/m$，其中$n$为元素数，$m$为桶数
- 平均链长：$E[L] = \alpha$
- 当$\alpha < 1$时，$E[L] < 1$，平均查找时间为O(1)
- Redis控制负载因子$\alpha < 0.75$，保证O(1)性能

### 4.2 插入操作

**冲突解决：链地址法**

```c
// 插入操作
int dictAdd(dict *d, void *key, void *val) {
    dictEntry *entry = dictAddRaw(d, key, NULL);
    if (!entry) return DICT_ERR;

    dictSetVal(d, entry, val);
    return DICT_OK;
}

dictEntry *dictAddRaw(dict *d, void *key, dictEntry **existing) {
    int index;
    dictEntry *entry;
    dictht *ht;

    // 如果正在rehash，执行一步rehash
    if (dictIsRehashing(d)) _dictRehashStep(d);

    // 计算索引
    if ((index = _dictKeyIndex(d, key, dictHashKey(d, key), existing)) == -1)
        return NULL;

    ht = dictIsRehashing(d) ? &d->ht[1] : &d->ht[0];
    entry = zmalloc(sizeof(*entry));

    // 插入到链表头部
    entry->next = ht->table[index];
    ht->table[index] = entry;
    ht->used++;

    dictSetKey(d, entry, key);
    return entry;
}
```

**时间复杂度分析**：

**定理 4.2**：dict插入操作的平均时间复杂度为O(1)。

**证明**：

- 哈希计算：O(1)
- 链表插入：O(1)（插入到头部）
- Rehash摊销：O(1)（渐进式rehash）
- 总时间复杂度：O(1)

### 4.3 删除操作

```c
// 删除操作
int dictDelete(dict *d, const void *key) {
    return dictGenericDelete(d, key, 0) ? DICT_OK : DICT_ERR;
}

int dictGenericDelete(dict *d, const void *key, int nofree) {
    dictEntry *he, *prevHe;
    unsigned int h, idx, table;

    if (d->ht[0].used == 0 && d->ht[1].used == 0) return NULL;

    if (dictIsRehashing(d)) _dictRehashStep(d);

    h = dictHashKey(d, key);

    for (table = 0; table <= 1; table++) {
        idx = h & d->ht[table].sizemask;
        he = d->ht[table].table[idx];
        prevHe = NULL;

        while(he) {
            if (key==he->key || dictCompareKeys(d, key, he->key)) {
                // 从链表中删除
                if (prevHe)
                    prevHe->next = he->next;
                else
                    d->ht[table].table[idx] = he->next;

                if (!nofree) {
                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                    zfree(he);
                }
                d->ht[table].used--;
                return he;
            }
            prevHe = he;
            he = he->next;
        }

        if (!dictIsRehashing(d)) break;
    }

    return NULL;
}
```

## 5. 渐进式Rehash

### 5.1 Rehash原理

**设计目的**：避免集中式rehash导致的性能抖动，将O(N)的rehash操作分散到N次操作中。

**核心思想**：

- 维护两个哈希表ht[0]和ht[1]
- 逐步将ht[0]的数据迁移到ht[1]
- 每次操作迁移1个桶，避免集中阻塞

### 5.2 Rehash流程

**Rehash触发条件**：

1. **负载因子过高**：$\alpha = \frac{used}{size} > 1$，触发扩容rehash
2. **负载因子过低**：$\alpha = \frac{used}{size} < 0.1$，触发缩容rehash

**Rehash步骤**：

1. **分配新表**：为ht[1]分配空间（通常为ht[0]的2倍或1/2）
2. **设置rehashidx**：$rehashidx = 0$，开始rehash
3. **渐进式迁移**：每次操作迁移1个桶
4. **完成rehash**：$rehashidx = -1$，交换ht[0]和ht[1]

### 5.3 性能分析

**渐进式Rehash性能证明**：

**定理 5.1**：渐进式Rehash的摊销时间复杂度为O(1)。

**证明**：

使用摊还分析：

假设哈希表有$n$个元素，需要$n$次操作完成rehash：

- **每次操作**：迁移1个桶，成本=O(1)
- **总成本**：$T(n) = O(n)$
- **摊销成本**：$T(n)/n = O(1)$

因此，渐进式Rehash的摊销时间复杂度为O(1)。

**对比集中式Rehash**：

| 指标 | 集中式Rehash | 渐进式Rehash |
|------|-------------|-------------|
| **单次延迟** | O(N) | O(1) |
| **总时间** | O(N) | O(N) |
| **用户体验** | 阻塞N毫秒 | 无感知 |

**结论**：渐进式Rehash在保持相同总时间的同时，消除了单次操作的阻塞，大幅提升了用户体验。

```c
// 渐进式rehash
int dictRehash(dict *d, int n) {
    int empty_visits = n * 10;  // 最大空桶访问次数

    if (!dictIsRehashing(d)) return 0;

    while (n-- && d->ht[0].used != 0) {
        dictEntry *de, *nextde;

        // 跳过空桶
        while (d->ht[0].table[d->rehashidx] == NULL) {
            d->rehashidx++;
            if (--empty_visits == 0) return 1;
        }

        de = d->ht[0].table[d->rehashidx];

        // 迁移该桶的所有节点
        while (de) {
            uint64_t h;
            nextde = de->next;

            // 计算新索引
            h = dictHashKey(d, de->key) & d->ht[1].sizemask;
            de->next = d->ht[1].table[h];
            d->ht[1].table[h] = de;

            d->ht[0].used--;
            d->ht[1].used++;
            de = nextde;
        }

        d->ht[0].table[d->rehashidx] = NULL;
        d->rehashidx++;
    }

    // 检查是否完成rehash
    if (d->ht[0].used == 0) {
        zfree(d->ht[0].table);
        d->ht[0] = d->ht[1];
        _dictReset(&d->ht[1]);
        d->rehashidx = -1;
        return 0;
    }

    return 1;
}

// 每次操作执行一步rehash
static void _dictRehashStep(dict *d) {
    if (d->iterators == 0) {
        dictRehash(d, 1);
    }
}
```

## 6. 性能优化

### 6.1 负载因子控制

**负载因子定义**：

$$\text{负载因子} = \frac{\text{已使用节点数}}{\text{哈希表大小}} = \frac{used}{size}$$

**控制策略**：

| 负载因子 | 操作 | 说明 |
|----------|------|------|
| ≥ 1.0 | 扩容 | 触发扩容，新大小为2倍 |
| ≥ 5.0 | 强制扩容 | 即使不允许resize也强制扩容 |
| < 0.1 | 缩容 | 缩容到最小容量 |

**性能影响**：

- **负载因子高**：冲突增多，链表变长，查询变慢
- **负载因子低**：内存浪费，但查询快
- **平衡点**：负载因子1.0是较好的平衡点

### 6.2 优化策略

#### 6.2.1 预分配大小

```c
// 预估大小，避免频繁扩容
dict *d = dictCreate(&dictTypeHeapStrings, NULL);
dictExpand(d, estimated_size);
```

#### 6.2.2 批量操作

```c
// 批量插入，减少rehash次数
for (int i = 0; i < count; i++) {
    dictAdd(d, keys[i], vals[i]);
    // 每次操作可能触发rehash
}
```

#### 6.2.3 避免在迭代时rehash

```c
// 迭代时禁止rehash
dictIterator *iter = dictGetIterator(d);
dictEntry *de;
while ((de = dictNext(iter)) != NULL) {
    // 迭代过程中不会rehash
    process(de);
}
dictReleaseIterator(iter);
```

## 7. Redis中的应用

dict在Redis中的应用：

1. **键空间管理**：整个Redis数据库的键值对存储
2. **Hash类型**：Redis Hash数据类型的底层实现
3. **集合实现**：Set和Sorted Set的部分实现
4. **内部索引**：过期键、阻塞键等内部索引

```c
// 检查是否需要扩容
static int _dictExpandIfNeeded(dict *d) {
    if (dictIsRehashing(d)) return DICT_OK;

    // 如果哈希表为空，初始化为4
    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    // 负载因子 >= 1 且允许resize，或者负载因子 >= 5（强制resize）
    if (d->ht[0].used >= d->ht[0].size &&
        (dict_can_resize ||
         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio)) {
        return dictExpand(d, d->ht[0].used * 2);
    }

    return DICT_OK;
}
```

### 缩容条件

```c
// 检查是否需要缩容
static int _dictShrinkIfNeeded(dict *d) {
    if (dictIsRehashing(d) || d->ht[0].used == 0) return DICT_OK;

    // 负载因子 < 0.1 时缩容
    if (d->ht[0].size > DICT_HT_INITIAL_SIZE &&
        d->ht[0].used * 100 / d->ht[0].size < HASHTABLE_MIN_FILL) {
        return dictResize(d);
    }

    return DICT_OK;
}
```

## 8. 程序设计分析

### 8.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：不同哈希函数作为不同策略（MurmurHash2、SipHash）
2. **状态模式**：Rehash状态（正常、rehashing）
3. **迭代器模式**：支持安全迭代，避免rehash影响

**策略模式实现**：

```c
// 哈希函数策略接口
typedef uint64_t (*dictHashFunction)(const void *key);

// 不同哈希函数策略
dictHashFunction hash_functions[] = {
    dictGenHashFunction,      // MurmurHash2
    siphash,                  // SipHash
    // ...
};
```

### 8.2 代码结构分析

**代码组织**：

1. **数据结构层**：dict、dictht、dictEntry结构定义
2. **操作层**：dict核心操作（查找、插入、删除）
3. **Rehash层**：渐进式Rehash实现

**模块化设计**：

- **高内聚**：dict相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的哈希函数和Rehash策略

### 8.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 内存** | 渐进式Rehash | 平衡性能和内存使用 |
| **简单 vs 复杂** | 双哈希表设计 | 支持渐进式Rehash |
| **通用 vs 专用** | 通用哈希表实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{memory} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（O(1)平均访问）
- $C_{memory}$：内存成本（双哈希表，渐进式Rehash）
- $C_{complexity}$：复杂度成本（渐进式Rehash，复杂度较高）

### 8.4 可扩展性分析

**扩展点**：

1. **新哈希函数**：可扩展为其他哈希函数
2. **新Rehash策略**：可扩展为其他Rehash策略
3. **并发支持**：可扩展为并发安全的dict实现

**扩展性设计**：

```c
// 可扩展的dict接口
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(void *privdata, const void *key);
    void *(*valDup)(void *privdata, const void *obj);
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void *privdata, void *key);
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

**可维护性**：

- **代码清晰**：dict逻辑清晰，易于理解
- **易于调试**：Rehash状态易于监控和调试
- **测试友好**：dict行为易于测试和验证

## 9. 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [渐进式Rehash性能证明](../../00-项目总览/证明图网-核心机制证明.md#4-渐进式rehash性能证明)
- [哈希算法实现](../../05-全栈分析/05.05-算法层实现/05.05.04-哈希算法实现.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 10. 权威参考

### 10.1 学术论文

1. **"MurmurHash: An Extremely Fast Non-Cryptographic Hash Function"** - Austin Appleby, 2008
   - MurmurHash2算法的原始论文
   - URL: <https://sites.google.com/site/murmurhash/>
   - 详细描述了MurmurHash2的设计和性能

2. **"SipHash: a fast short-input PRF"** - Jean-Philippe Aumasson, Daniel J. Bernstein, INDOCRYPT, 2012
   - SipHash算法的原始论文
   - DOI: 10.1007/978-3-642-34931-7_28
   - 防止哈希碰撞攻击的哈希函数

3. **"Hash Tables"** - Donald Knuth, The Art of Computer Programming, Volume 3, 1998
   - 哈希表的经典理论分析
   - ISBN: 978-0201896855
   - 详细分析了链地址法和开放地址法

### 10.2 官方文档

1. **Redis源码 - dict.h/dict.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/dict.h>
   - URL: <https://github.com/redis/redis/blob/unstable/src/dict.c>
   - 版本: Redis 2.0+
   - dict的完整实现源码

2. **Redis官方文档 - Hashes**
   - URL: <https://redis.io/docs/data-types/hashes/>
   - 版本: Redis 7.0+
   - Redis Hash类型的官方文档

### 10.3 经典书籍

1. **《算法导论（第3版）》** - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
   - 出版社: MIT Press
   - ISBN: 978-0262033848
   - 第11章：散列表（详细分析哈希表理论和实现）

2. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第4章：字典（详细分析Redis dict实现）

3. **《数据结构与算法分析：C语言描述》** - Mark Allen Weiss
   - 出版社: 机械工业出版社
   - ISBN: 978-7111407010
   - 第5章：散列（哈希表实现和分析）

### 10.4 在线资源

1. **Wikipedia - Hash Table**
   - URL: <https://en.wikipedia.org/wiki/Hash_table>
   - 提供哈希表的详细说明和历史背景

2. **GeeksforGeeks - Hash Table**
   - URL: <https://www.geeksforgeeks.org/hashing-data-structure/>
   - 提供哈希表的实现示例和复杂度分析
