# 03.01.03 列表quicklist实现

## 概述

quicklist是Redis 3.2引入的列表数据结构，结合了双向链表和ziplist的优点，既支持O(1)的头部/尾部操作，又通过ziplist压缩节省内存。

## 设计目标

### 解决的问题

1. **内存优化**：使用ziplist压缩小列表
2. **性能保证**：保持O(1)的头部/尾部操作
3. **灵活性**：支持任意长度的列表

### 设计思路

quicklist = 双向链表 + ziplist节点

```
quicklist
├── head (quicklistNode)
│   └── ziplist [entry1, entry2, ...]
├── quicklistNode
│   └── ziplist [entry3, entry4, ...]
└── tail (quicklistNode)
    └── ziplist [entry5, entry6, ...]
```

## 数据结构设计

### quicklistNode结构

```c
// quicklist节点
typedef struct quicklistNode {
    struct quicklistNode *prev;  // 前驱节点
    struct quicklistNode *next;  // 后继节点
    unsigned char *zl;           // ziplist指针
    unsigned int sz;              // ziplist字节数
    unsigned int count : 16;      // ziplist元素数
    unsigned int encoding : 2;    // 编码：RAW=1, ZIPLIST=2
    unsigned int container : 2;   // 容器：NONE=1, ZIPLIST=2
    unsigned int recompress : 1;  // 是否被压缩
    unsigned int attempted_compress : 1; // 是否尝试压缩
    unsigned int extra : 10;      // 扩展字段
} quicklistNode;

// quicklist结构
typedef struct quicklist {
    quicklistNode *head;          // 头节点
    quicklistNode *tail;          // 尾节点
    unsigned long count;          // 总元素数
    unsigned long len;            // 节点数
    int fill : 16;               // 每个节点最大元素数
    unsigned int compress : 16;   // 压缩深度（两端不压缩的节点数）
} quicklist;
```

### 配置参数

```c
// fill参数：控制每个ziplist的最大元素数
// -1: 4KB
// -2: 8KB
// -3: 16KB
// -4: 32KB
// -5: 64KB
// 正数: 最大元素数

// compress参数：压缩深度
// 0: 不压缩
// 1: 两端各1个节点不压缩
// 2: 两端各2个节点不压缩
```

## 核心操作

### 1. 头部插入

```c
// 头部插入
int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist->head;

    // 检查头节点是否可以插入
    if (likely(_quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
        quicklist->head->zl = ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);
        quicklistNodeUpdateSz(quicklist->head);
    } else {
        // 创建新节点
        quicklistNode *node = quicklistCreateNode();
        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
    }

    quicklist->count++;
    quicklist->head->count++;
    return 1;
}
```

**时间复杂度**：O(1)

### 2. 尾部插入

```c
// 尾部插入
int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist->tail;

    // 检查尾节点是否可以插入
    if (likely(_quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {
        quicklist->tail->zl = ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);
        quicklistNodeUpdateSz(quicklist->tail);
    } else {
        // 创建新节点
        quicklistNode *node = quicklistCreateNode();
        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    }

    quicklist->count++;
    quicklist->tail->count++;
    return 1;
}
```

**时间复杂度**：O(1)

### 3. 中间插入

```c
// 中间插入
int quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
                        void *value, const size_t sz) {
    quicklistNode *node = entry->node;

    // 如果节点可以插入
    if (likely(_quicklistNodeAllowInsert(node, quicklist->fill, sz))) {
        node->zl = ziplistInsert(node->zl, entry->zi, value, sz);
        quicklistNodeUpdateSz(node);
        quicklist->count++;
        return 1;
    } else {
        // 节点已满，需要分裂
        quicklistNode *new_node = quicklistCreateNode();
        new_node->zl = ziplistInsert(node->zl, entry->zi, value, sz);
        quicklistNodeUpdateSz(new_node);

        _quicklistInsertNodeAfter(quicklist, node, new_node);
        quicklist->count++;
        return 1;
    }
}
```

**时间复杂度**：O(N)（需要定位插入位置）

### 4. 查找操作

```c
// 查找元素
quicklistEntry *quicklistIndex(quicklist *quicklist, const long long idx) {
    quicklistNode *n;
    unsigned long long accum = 0;
    unsigned long long index;
    int forward = idx < 0 ? 0 : 1; // 负数从尾部开始

    index = forward ? idx : (-idx) - 1;

    if (index < quicklist->count) {
        if (forward) {
            n = quicklist->head;
            while (n && accum <= index) {
                if ((accum + n->count) > index) {
                    break;
                } else {
                    accum += n->count;
                    n = n->next;
                }
            }
        } else {
            n = quicklist->tail;
            while (n && accum <= index) {
                if ((accum + n->count) > index) {
                    break;
                } else {
                    accum += n->count;
                    n = n->prev;
                }
            }
        }

        // 在ziplist中查找
        quicklistEntry entry;
        entry.node = n;
        entry.offset = index - accum;
        entry.zi = ziplistIndex(n->zl, entry.offset);
        return &entry;
    }

    return NULL;
}
```

**时间复杂度**：O(N)（最坏情况需要遍历所有节点）

## 压缩机制

### LZF压缩

```c
// 压缩节点
int quicklistCompressNode(quicklistNode *node) {
    if (node->attempted_compress == 1) {
        return 0;
    }

    if (node->sz < MIN_COMPRESS_BYTES) {
        return 0;
    }

    quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);

    if ((lzf->sz = lzf_compress(node->zl, node->sz, lzf->compressed,
                                 node->sz)) == 0) {
        zfree(lzf);
        return 0;
    }

    lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
    zfree(node->zl);
    node->zl = (unsigned char *)lzf;
    node->encoding = QUICKLIST_NODE_ENCODING_LZF;
    node->recompress = 0;
    return 1;
}

// 解压节点
int quicklistDecompressNode(quicklistNode *node) {
    if (node->encoding != QUICKLIST_NODE_ENCODING_LZF) {
        return 0;
    }

    quicklistLZF *lzf = (quicklistLZF *)node->zl;
    size_t len = lzf_decompress(lzf->compressed, lzf->sz,
                                node->zl, node->sz);
    if (len == 0) {
        return 0;
    }

    node->zl = zrealloc(node->zl, len);
    node->sz = len;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    node->recompress = 0;
    return 1;
}
```

### 压缩策略

```c
// 压缩深度控制
void quicklistCompress(quicklist *ql, quicklistNode *node) {
    if (ql->compress == 0) return;

    quicklistNode *forward = node;
    quicklistNode *reverse = node;
    int depth = 0;
    int in_depth = 0;

    while (depth++ < ql->compress) {
        if (forward->recompress == 0) {
            quicklistCompressNode(forward);
        }
        if (reverse->recompress == 0) {
            quicklistCompressNode(reverse);
        }

        if (forward->next == NULL || reverse->prev == NULL) {
            break;
        }

        forward = forward->next;
        reverse = reverse->prev;
    }
}
```

**压缩深度**：

- `compress=0`：不压缩
- `compress=1`：两端各1个节点不压缩
- `compress=2`：两端各2个节点不压缩

## 性能优化

### 1. 节点分裂

```c
// 节点过大时分裂
int quicklistSplitNode(quicklistNode *node, int offset) {
    if (offset == 0) {
        return 0;
    }

    // 创建新节点
    quicklistNode *new_node = quicklistCreateNode();

    // 分裂ziplist
    new_node->zl = ziplistSplit(node->zl, offset);
    new_node->count = ziplistLen(new_node->zl);
    quicklistNodeUpdateSz(new_node);

    node->count = offset;
    quicklistNodeUpdateSz(node);

    return 1;
}
```

### 2. 节点合并

```c
// 节点过小时合并
int quicklistMergeNodes(quicklistNode *center) {
    quicklistNode *prev = center->prev;
    quicklistNode *next = center->next;

    // 尝试与前一个节点合并
    if (prev && prev->count + center->count < quicklist->fill) {
        prev->zl = ziplistMerge(prev->zl, center->zl);
        prev->count += center->count;
        quicklistNodeUpdateSz(prev);
        _quicklistDelNode(quicklist, center);
        return 1;
    }

    // 尝试与后一个节点合并
    if (next && center->count + next->count < quicklist->fill) {
        center->zl = ziplistMerge(center->zl, next->zl);
        center->count += next->count;
        quicklistNodeUpdateSz(center);
        _quicklistDelNode(quicklist, next);
        return 1;
    }

    return 0;
}
```

## 内存优化效果

### 对比分析

| 场景 | 传统链表 | quicklist | 内存节省 |
|------|----------|-----------|----------|
| **小列表（10元素）** | 240字节 | 120字节 | **50%** |
| **中等列表（100元素）** | 2400字节 | 800字节 | **67%** |
| **大列表（1000元素）** | 24000字节 | 6000字节 | **75%** |

### 压缩效果

```c
// 压缩前后对比
// 原始ziplist：1000字节
// LZF压缩后：300字节（压缩率70%）
// 内存节省：70%
```

## 配置优化

### 生产环境配置

```conf
# List配置（Redis 3.2+）
list-max-ziplist-size -2        # 每个节点最大8KB
list-compress-depth 1           # 两端各1个节点不压缩

# 调优建议
# 小对象场景：增大fill（-1或-2）
# 大对象场景：减小fill（-4或-5）
# 内存优先：增大compress深度
# 性能优先：减小compress深度
```

## 与旧版本对比

### Redis 3.2前（ziplist/linkedlist）

```c
// Redis 3.2前：根据大小选择编码
if (list->length < list_max_ziplist_entries &&
    all_values_small(list)) {
    // 使用ziplist
    encoding = OBJ_ENCODING_ZIPLIST;
} else {
    // 使用linkedlist
    encoding = OBJ_ENCODING_LINKEDLIST;
}
```

**问题**：

- 小列表和大列表性能差异大
- 无法平衡内存和性能

### Redis 3.2+（quicklist）

```c
// Redis 3.2+：统一使用quicklist
encoding = OBJ_ENCODING_QUICKLIST;
```

**优势**：

- 统一的数据结构
- 自动平衡内存和性能
- 支持压缩

## 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis 3.2 Release Notes** - quicklist引入说明
