# 03.01.03 列表quicklist实现

## 目录

- [03.01.03 列表quicklist实现](#030103-列表quicklist实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 设计目标](#2-设计目标)
    - [2.1 解决的问题](#21-解决的问题)
    - [2.2 设计思路](#22-设计思路)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数据结构设计](#3-数据结构设计)
    - [3.1 quicklistNode结构](#31-quicklistnode结构)
    - [3.2 quicklist结构](#32-quicklist结构)
    - [3.3 配置参数](#33-配置参数)
  - [4. 核心操作](#4-核心操作)
    - [4.1 头部插入](#41-头部插入)
    - [4.2 尾部插入](#42-尾部插入)
    - [4.3 中间插入](#43-中间插入)
    - [4.4 删除操作](#44-删除操作)
  - [压缩机制](#压缩机制)
    - [LZF压缩](#lzf压缩)
    - [压缩策略](#压缩策略)
  - [5. 性能分析](#5-性能分析)
    - [5.1 时间复杂度分析](#51-时间复杂度分析)
    - [5.2 空间复杂度分析](#52-空间复杂度分析)
    - [5.3 内存效率分析](#53-内存效率分析)
  - [6. 适用场景](#6-适用场景)
    - [6.1 优势场景](#61-优势场景)
    - [6.2 不适用场景](#62-不适用场景)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 经典书籍](#82-经典书籍)
    - [8.3 在线资源](#83-在线资源)
    - [1. 节点分裂](#1-节点分裂)
    - [2. 节点合并](#2-节点合并)
  - [内存优化效果](#内存优化效果)
    - [对比分析](#对比分析)
    - [压缩效果](#压缩效果)
  - [配置优化](#配置优化)
    - [生产环境配置](#生产环境配置)
  - [与旧版本对比](#与旧版本对比)
    - [Redis 3.2前（ziplist/linkedlist）](#redis-32前ziplistlinkedlist)
    - [Redis 3.2+（quicklist）](#redis-32quicklist)
  - [扩展阅读](#扩展阅读)
  - [权威参考](#权威参考)

---

## 1. 概述

### 1.1 定义与历史背景

**quicklist**是Redis 3.2引入的列表数据结构，结合了双向链表和ziplist的优点，既支持O(1)的头部/尾部操作，又通过ziplist压缩节省内存。

**历史发展**：

- **2012年**：Redis 2.4使用双向链表实现列表
- **2015年**：Redis 3.2引入quicklist，结合链表和ziplist
- **2016年**：Redis 3.2优化quicklist压缩机制
- **2020年代**：quicklist成为Redis列表的标准实现

### 1.2 应用价值

quicklist在Redis中具有重要价值：

1. **内存优化**：使用ziplist压缩小列表，节省内存
2. **性能保证**：保持O(1)的头部/尾部操作
3. **灵活性**：支持任意长度的列表
4. **平衡性能**：在内存和性能之间取得平衡

## 2. 设计目标

### 2.1 解决的问题

1. **内存优化**：使用ziplist压缩小列表
2. **性能保证**：保持O(1)的头部/尾部操作
3. **灵活性**：支持任意长度的列表

### 2.2 设计思路

quicklist = 双向链表 + ziplist节点

**设计权衡**：

- **双向链表**：O(1)的头部/尾部操作，但内存开销大
- **ziplist**：内存紧凑，但插入/删除需要O(N)
- **quicklist**：结合两者优点，平衡性能和内存

### 2.3 形式化定义

设列表长度为$n$，quicklist结构：

$$Quicklist = \{Node_1, Node_2, ..., Node_k\}$$

其中每个节点$Node_i$包含一个ziplist：

$$Node_i = \{entry_{i,1}, entry_{i,2}, ..., entry_{i,m_i}\}$$

约束条件：

- $\sum_{i=1}^{k} m_i = n$（总元素数）
- $|Node_i| \leq fill$（每个节点元素数不超过fill）
- $k = \lceil \frac{n}{fill} \rceil$（节点数）

```
quicklist
├── head (quicklistNode)
│   └── ziplist [entry1, entry2, ...]
├── quicklistNode
│   └── ziplist [entry3, entry4, ...]
└── tail (quicklistNode)
    └── ziplist [entry5, entry6, ...]
```

## 3. 数据结构设计

### 3.1 quicklistNode结构

```c
// quicklist节点
typedef struct quicklistNode {
    struct quicklistNode *prev;  // 前驱节点
    struct quicklistNode *next;  // 后继节点
    unsigned char *zl;           // ziplist指针
    unsigned int sz;              // ziplist字节数
    unsigned int count : 16;      // ziplist元素数
    unsigned int encoding : 2;    // 编码：RAW=1, ZIPLIST=2
    unsigned int container : 2;   // 容器：NONE=1, ZIPLIST=2
    unsigned int recompress : 1;  // 是否被压缩
    unsigned int attempted_compress : 1; // 是否尝试压缩
    unsigned int extra : 10;      // 扩展字段
} quicklistNode;

// quicklist结构
typedef struct quicklist {
    quicklistNode *head;          // 头节点
    quicklistNode *tail;          // 尾节点
    unsigned long count;          // 总元素数
    unsigned long len;            // 节点数
    int fill : 16;               // 每个节点最大元素数
    unsigned int compress : 16;   // 压缩深度（两端不压缩的节点数）
} quicklist;
```

### 3.2 quicklist结构

**quicklist结构**已在上面定义。

### 3.3 配置参数

```c
// fill参数：控制每个ziplist的最大元素数
// -1: 4KB
// -2: 8KB
// -3: 16KB
// -4: 32KB
// -5: 64KB
// 正数: 最大元素数

// compress参数：压缩深度
// 0: 不压缩
// 1: 两端各1个节点不压缩
// 2: 两端各2个节点不压缩
```

## 4. 核心操作

### 4.1 头部插入

```c
// 头部插入
int quicklistPushHead(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_head = quicklist->head;

    // 检查头节点是否可以插入
    if (likely(_quicklistNodeAllowInsert(quicklist->head, quicklist->fill, sz))) {
        quicklist->head->zl = ziplistPush(quicklist->head->zl, value, sz, ZIPLIST_HEAD);
        quicklistNodeUpdateSz(quicklist->head);
    } else {
        // 创建新节点
        quicklistNode *node = quicklistCreateNode();
        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeBefore(quicklist, quicklist->head, node);
    }

    quicklist->count++;
    quicklist->head->count++;
    return 1;
}
```

**时间复杂度**：O(1)

**定理 4.1**：quicklist头部插入的时间复杂度为O(1)。

**证明**：

- 检查头节点是否可以插入：O(1)
- 如果可以插入：ziplist头部插入O(1)
- 如果不可插入：创建新节点O(1)，插入到链表头部O(1)
- 总时间复杂度：O(1)

### 4.2 尾部插入

```c
// 尾部插入
int quicklistPushTail(quicklist *quicklist, void *value, size_t sz) {
    quicklistNode *orig_tail = quicklist->tail;

    // 检查尾节点是否可以插入
    if (likely(_quicklistNodeAllowInsert(quicklist->tail, quicklist->fill, sz))) {
        quicklist->tail->zl = ziplistPush(quicklist->tail->zl, value, sz, ZIPLIST_TAIL);
        quicklistNodeUpdateSz(quicklist->tail);
    } else {
        // 创建新节点
        quicklistNode *node = quicklistCreateNode();
        node->zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_TAIL);

        quicklistNodeUpdateSz(node);
        _quicklistInsertNodeAfter(quicklist, quicklist->tail, node);
    }

    quicklist->count++;
    quicklist->tail->count++;
    return 1;
}
```

**时间复杂度**：O(1)

**定理 4.2**：quicklist尾部插入的时间复杂度为O(1)。

**证明**：与头部插入类似，时间复杂度为O(1)。

### 4.3 中间插入

```c
// 中间插入
int quicklistInsertAfter(quicklist *quicklist, quicklistEntry *entry,
                        void *value, const size_t sz) {
    quicklistNode *node = entry->node;

    // 如果节点可以插入
    if (likely(_quicklistNodeAllowInsert(node, quicklist->fill, sz))) {
        node->zl = ziplistInsert(node->zl, entry->zi, value, sz);
        quicklistNodeUpdateSz(node);
        quicklist->count++;
        return 1;
    } else {
        // 节点已满，需要分裂
        quicklistNode *new_node = quicklistCreateNode();
        new_node->zl = ziplistInsert(node->zl, entry->zi, value, sz);
        quicklistNodeUpdateSz(new_node);

        _quicklistInsertNodeAfter(quicklist, node, new_node);
        quicklist->count++;
        return 1;
    }
}
```

**时间复杂度**：O(N)（需要定位插入位置）

**定理 4.3**：quicklist中间插入的时间复杂度为O(N)，其中N为列表长度。

**证明**：

- 定位插入位置：O(N)（需要遍历节点）
- 插入操作：O(M)，M为节点内元素数
- 总时间复杂度：O(N)

### 4.4 删除操作

```c
// 查找元素
quicklistEntry *quicklistIndex(quicklist *quicklist, const long long idx) {
    quicklistNode *n;
    unsigned long long accum = 0;
    unsigned long long index;
    int forward = idx < 0 ? 0 : 1; // 负数从尾部开始

    index = forward ? idx : (-idx) - 1;

    if (index < quicklist->count) {
        if (forward) {
            n = quicklist->head;
            while (n && accum <= index) {
                if ((accum + n->count) > index) {
                    break;
                } else {
                    accum += n->count;
                    n = n->next;
                }
            }
        } else {
            n = quicklist->tail;
            while (n && accum <= index) {
                if ((accum + n->count) > index) {
                    break;
                } else {
                    accum += n->count;
                    n = n->prev;
                }
            }
        }

        // 在ziplist中查找
        quicklistEntry entry;
        entry.node = n;
        entry.offset = index - accum;
        entry.zi = ziplistIndex(n->zl, entry.offset);
        return &entry;
    }

    return NULL;
}
```

**时间复杂度**：O(N)（最坏情况需要遍历所有节点）

## 压缩机制

### LZF压缩

```c
// 压缩节点
int quicklistCompressNode(quicklistNode *node) {
    if (node->attempted_compress == 1) {
        return 0;
    }

    if (node->sz < MIN_COMPRESS_BYTES) {
        return 0;
    }

    quicklistLZF *lzf = zmalloc(sizeof(*lzf) + node->sz);

    if ((lzf->sz = lzf_compress(node->zl, node->sz, lzf->compressed,
                                 node->sz)) == 0) {
        zfree(lzf);
        return 0;
    }

    lzf = zrealloc(lzf, sizeof(*lzf) + lzf->sz);
    zfree(node->zl);
    node->zl = (unsigned char *)lzf;
    node->encoding = QUICKLIST_NODE_ENCODING_LZF;
    node->recompress = 0;
    return 1;
}

// 解压节点
int quicklistDecompressNode(quicklistNode *node) {
    if (node->encoding != QUICKLIST_NODE_ENCODING_LZF) {
        return 0;
    }

    quicklistLZF *lzf = (quicklistLZF *)node->zl;
    size_t len = lzf_decompress(lzf->compressed, lzf->sz,
                                node->zl, node->sz);
    if (len == 0) {
        return 0;
    }

    node->zl = zrealloc(node->zl, len);
    node->sz = len;
    node->encoding = QUICKLIST_NODE_ENCODING_RAW;
    node->recompress = 0;
    return 1;
}
```

### 压缩策略

```c
// 压缩深度控制
void quicklistCompress(quicklist *ql, quicklistNode *node) {
    if (ql->compress == 0) return;

    quicklistNode *forward = node;
    quicklistNode *reverse = node;
    int depth = 0;
    int in_depth = 0;

    while (depth++ < ql->compress) {
        if (forward->recompress == 0) {
            quicklistCompressNode(forward);
        }
        if (reverse->recompress == 0) {
            quicklistCompressNode(reverse);
        }

        if (forward->next == NULL || reverse->prev == NULL) {
            break;
        }

        forward = forward->next;
        reverse = reverse->prev;
    }
}
```

**压缩深度**：

- `compress=0`：不压缩
- `compress=1`：两端各1个节点不压缩
- `compress=2`：两端各2个节点不压缩

## 5. 性能分析

### 5.1 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **头部插入** | O(1) | 直接插入头节点 |
| **尾部插入** | O(1) | 直接插入尾节点 |
| **中间插入** | O(N) | 需要定位插入位置 |
| **查找** | O(N) | 需要遍历节点 |
| **删除** | O(N) | 需要定位删除位置 |

**定理 5.1**：quicklist头部/尾部操作的时间复杂度为O(1)。

**证明**：

- 头部/尾部操作直接访问头/尾节点
- ziplist头部/尾部插入为O(1)
- 总时间复杂度：O(1)

### 5.2 空间复杂度分析

**空间开销**：

$$S_{quicklist} = S_{header} + \sum_{i=1}^{k} S_{node_i}$$

其中：

- $S_{header}$：quicklist头部大小（约24字节）
- $S_{node_i}$：第i个节点大小（约32字节 + ziplist大小）
- $k$：节点数，$k = \lceil \frac{n}{fill} \rceil$

**内存效率**：

$$\text{效率} = \frac{\text{数据大小}}{\text{总分配大小}} = \frac{n \times s_{entry}}{S_{quicklist}}$$

其中$s_{entry}$为每个元素的大小。

### 5.3 内存效率分析

**内存优化效果对比**：

| 场景 | 传统链表 | quicklist | 内存节省 |
|------|----------|-----------|----------|
| **小列表（10元素）** | 240字节 | 120字节 | **50%** |
| **中等列表（100元素）** | 2400字节 | 800字节 | **67%** |
| **大列表（1000元素）** | 24000字节 | 6000字节 | **75%** |

**定理 5.2**：quicklist相比传统链表可以节省50-75%的内存。

**证明**：

- 传统链表：每个节点24字节（指针）+ 数据大小
- quicklist：每个节点32字节 + ziplist（压缩存储）
- 对于小元素，ziplist压缩率可达70-80%
- 内存节省：$\frac{S_{linkedlist} - S_{quicklist}}{S_{linkedlist}} \approx 50-75\%$

## 6. 适用场景

### 6.1 优势场景

1. **中等长度列表**：100-10000个元素
2. **频繁头部/尾部操作**：LPUSH、RPUSH等操作
3. **内存敏感场景**：需要节省内存

### 6.2 不适用场景

1. **超长列表**：>10000个元素，建议使用其他数据结构
2. **频繁中间操作**：需要O(N)时间复杂度

## 7. 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 8. 权威参考

### 8.1 官方文档

1. **Redis源码 - quicklist.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/quicklist.c>
   - 版本: Redis 3.2+
   - quicklist的完整实现源码

2. **Redis 3.2 Release Notes**
   - URL: <https://raw.githubusercontent.com/antirez/redis/3.2/00-RELEASENOTES>
   - Redis 3.2版本说明，包含quicklist的引入说明

### 8.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第5章：列表（详细分析quicklist实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第1章：Redis基础数据结构（quicklist详解）

### 8.3 在线资源

1. **Redis官方文档 - Lists**
   - URL: <https://redis.io/docs/data-types/lists/>
   - Redis列表类型的官方文档

### 1. 节点分裂

```c
// 节点过大时分裂
int quicklistSplitNode(quicklistNode *node, int offset) {
    if (offset == 0) {
        return 0;
    }

    // 创建新节点
    quicklistNode *new_node = quicklistCreateNode();

    // 分裂ziplist
    new_node->zl = ziplistSplit(node->zl, offset);
    new_node->count = ziplistLen(new_node->zl);
    quicklistNodeUpdateSz(new_node);

    node->count = offset;
    quicklistNodeUpdateSz(node);

    return 1;
}
```

### 2. 节点合并

```c
// 节点过小时合并
int quicklistMergeNodes(quicklistNode *center) {
    quicklistNode *prev = center->prev;
    quicklistNode *next = center->next;

    // 尝试与前一个节点合并
    if (prev && prev->count + center->count < quicklist->fill) {
        prev->zl = ziplistMerge(prev->zl, center->zl);
        prev->count += center->count;
        quicklistNodeUpdateSz(prev);
        _quicklistDelNode(quicklist, center);
        return 1;
    }

    // 尝试与后一个节点合并
    if (next && center->count + next->count < quicklist->fill) {
        center->zl = ziplistMerge(center->zl, next->zl);
        center->count += next->count;
        quicklistNodeUpdateSz(center);
        _quicklistDelNode(quicklist, next);
        return 1;
    }

    return 0;
}
```

## 内存优化效果

### 对比分析

| 场景 | 传统链表 | quicklist | 内存节省 |
|------|----------|-----------|----------|
| **小列表（10元素）** | 240字节 | 120字节 | **50%** |
| **中等列表（100元素）** | 2400字节 | 800字节 | **67%** |
| **大列表（1000元素）** | 24000字节 | 6000字节 | **75%** |

### 压缩效果

```c
// 压缩前后对比
// 原始ziplist：1000字节
// LZF压缩后：300字节（压缩率70%）
// 内存节省：70%
```

## 配置优化

### 生产环境配置

```conf
# List配置（Redis 3.2+）
list-max-ziplist-size -2        # 每个节点最大8KB
list-compress-depth 1           # 两端各1个节点不压缩

# 调优建议
# 小对象场景：增大fill（-1或-2）
# 大对象场景：减小fill（-4或-5）
# 内存优先：增大compress深度
# 性能优先：减小compress深度
```

## 与旧版本对比

### Redis 3.2前（ziplist/linkedlist）

```c
// Redis 3.2前：根据大小选择编码
if (list->length < list_max_ziplist_entries &&
    all_values_small(list)) {
    // 使用ziplist
    encoding = OBJ_ENCODING_ZIPLIST;
} else {
    // 使用linkedlist
    encoding = OBJ_ENCODING_LINKEDLIST;
}
```

**问题**：

- 小列表和大列表性能差异大
- 无法平衡内存和性能

### Redis 3.2+（quicklist）

```c
// Redis 3.2+：统一使用quicklist
encoding = OBJ_ENCODING_QUICKLIST;
```

**优势**：

- 统一的数据结构
- 自动平衡内存和性能
- 支持压缩

## 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis 3.2 Release Notes** - quicklist引入说明
