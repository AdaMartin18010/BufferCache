# 03.01.04 集合intset实现

## 概述

intset（整数集合）是Redis用于存储小整数集合的紧凑型数据结构，当集合只包含整数且元素数量较少时，使用intset可以大幅节省内存。

## 设计目标

### 适用场景

- **元素类型**：只包含整数
- **元素数量**：小于`set_max_intset_entries`（默认512）
- **内存优化**：相比hashtable节省50-80%内存

### 编码转换

```c
// 当集合满足以下条件时，使用intset编码
if (set->length < server.set_max_intset_entries &&
    all_elements_are_integers(set)) {
    encoding = OBJ_ENCODING_INTSET;
} else {
    encoding = OBJ_ENCODING_HT;  // 转换为hashtable
}
```

## 数据结构设计

### intset结构

```c
// intset.h
typedef struct intset {
    uint32_t encoding;  // 编码类型：INTSET_ENC_INT16/32/64
    uint32_t length;   // 元素数量
    int8_t contents[]; // 柔性数组，存储实际数据
} intset;

// 编码类型
#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))
```

### 内存布局

```
┌─────────────┬─────────────┬─────────────────────┐
│  encoding   │   length    │      contents[]      │
│  (4字节)    │   (4字节)   │    (变长数组)        │
└─────────────┴─────────────┴─────────────────────┘
```

## 核心操作

### 1. 查找操作

```c
// 查找元素（二分查找）
uint8_t intsetFind(intset *is, int64_t value) {
    uint8_t valenc = _intsetValueEncoding(value);
    return valenc <= intrev32ifbe(is->encoding) &&
           _intsetSearch(is, value, NULL);
}

// 二分查找实现
static uint8_t _intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is->length) - 1, mid = -1;
    int64_t cur = -1;

    // 空集合
    if (intrev32ifbe(is->length) == 0) {
        if (pos) *pos = 0;
        return 0;
    } else {
        // 检查是否超出范围
        if (value > _intsetGet(is, intrev32ifbe(is->length) - 1)) {
            if (pos) *pos = intrev32ifbe(is->length);
            return 0;
        } else if (value < _intsetGet(is, 0)) {
            if (pos) *pos = 0;
            return 0;
        }
    }

    // 二分查找
    while (max >= min) {
        mid = ((unsigned int)min + (unsigned int)max) >> 1;
        cur = _intsetGet(is, mid);
        if (value > cur) {
            min = mid + 1;
        } else if (value < cur) {
            max = mid - 1;
        } else {
            break;
        }
    }

    if (value == cur) {
        if (pos) *pos = mid;
        return 1;
    } else {
        if (pos) *pos = min;
        return 0;
    }
}
```

**时间复杂度**：O(logN)

### 2. 插入操作

```c
// 插入元素
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;

    if (success) *success = 1;

    // 检查是否需要升级编码
    if (valenc > intrev32ifbe(is->encoding)) {
        return intsetUpgradeAndAdd(is, value);
    } else {
        // 查找插入位置
        if (_intsetSearch(is, value, &pos)) {
            if (success) *success = 0;
            return is;
        }

        // 扩容
        is = intsetResize(is, intrev32ifbe(is->length) + 1);

        // 移动元素
        if (pos < intrev32ifbe(is->length))
            intsetMoveTail(is, pos, pos + 1);
    }

    // 插入新元素
    _intsetSet(is, pos, value);
    is->length = intrev32ifbe(intrev32ifbe(is->length) + 1);
    return is;
}
```

**时间复杂度**：O(N)（需要移动元素）

### 3. 删除操作

```c
// 删除元素
intset *intsetRemove(intset *is, int64_t value, int *success) {
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;

    if (success) *success = 0;

    if (valenc <= intrev32ifbe(is->encoding) &&
        _intsetSearch(is, value, &pos)) {
        uint32_t len = intrev32ifbe(is->length);

        if (success) *success = 1;

        // 移动元素
        if (pos < (len - 1))
            intsetMoveTail(is, pos + 1, pos);

        // 缩容
        is = intsetResize(is, len - 1);
        is->length = intrev32ifbe(len - 1);
    }
    return is;
}
```

**时间复杂度**：O(N)

### 4. 编码升级

```c
// 升级编码（只升级，不降级）
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    uint8_t curenc = intrev32ifbe(is->encoding);
    uint8_t newenc = _intsetValueEncoding(value);
    int length = intrev32ifbe(is->length);
    int prepend = value < 0 ? 1 : 0;

    // 设置新编码
    is->encoding = intrev32ifbe(newenc);

    // 扩容
    is = intsetResize(is, length + 1);

    // 从后往前移动元素，避免覆盖
    while (length--)
        _intsetSet(is, length + prepend, _intsetGetEncoded(is, length, curenc));

    // 插入新元素
    if (prepend)
        _intsetSet(is, 0, value);
    else
        _intsetSet(is, intrev32ifbe(is->length), value);

    is->length = intrev32ifbe(intrev32ifbe(is->length) + 1);
    return is;
}
```

**特点**：

- 只升级，不降级（节省CPU）
- 升级后所有元素都使用新编码

## 辅助函数

### 获取元素

```c
// 根据索引获取元素
static int64_t _intsetGet(intset *is, int pos) {
    return _intsetGetEncoded(is, pos, intrev32ifbe(is->encoding));
}

static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {
    int64_t v64;
    int32_t v32;
    int16_t v16;

    if (enc == INTSET_ENC_INT64) {
        memcpy(&v64, ((int64_t *)is->contents) + pos, sizeof(v64));
        memrev64ifbe(&v64);
        return v64;
    } else if (enc == INTSET_ENC_INT32) {
        memcpy(&v32, ((int32_t *)is->contents) + pos, sizeof(v32));
        memrev32ifbe(&v32);
        return v32;
    } else {
        memcpy(&v16, ((int16_t *)is->contents) + pos, sizeof(v16));
        memrev16ifbe(&v16);
        return v16;
    }
}
```

### 设置元素

```c
// 设置元素值
static void _intsetSet(intset *is, int pos, int64_t value) {
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        ((int64_t *)is->contents)[pos] = value;
        memrev64ifbe(((int64_t *)is->contents) + pos);
    } else if (encoding == INTSET_ENC_INT32) {
        ((int32_t *)is->contents)[pos] = (int32_t)value;
        memrev32ifbe(((int32_t *)is->contents) + pos);
    } else {
        ((int16_t *)is->contents)[pos] = (int16_t)value;
        memrev16ifbe(((int16_t *)is->contents) + pos);
    }
}
```

### 移动元素

```c
// 移动元素（用于插入/删除）
static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {
    void *src, *dst;
    uint32_t bytes = intrev32ifbe(is->length) - from;
    uint32_t encoding = intrev32ifbe(is->encoding);

    if (encoding == INTSET_ENC_INT64) {
        src = (int64_t *)is->contents + from;
        dst = (int64_t *)is->contents + to;
        bytes *= sizeof(int64_t);
    } else if (encoding == INTSET_ENC_INT32) {
        src = (int32_t *)is->contents + from;
        dst = (int32_t *)is->contents + to;
        bytes *= sizeof(int32_t);
    } else {
        src = (int16_t *)is->contents + from;
        dst = (int16_t *)is->contents + to;
        bytes *= sizeof(int16_t);
    }
    memmove(dst, src, bytes);
}
```

## 内存优化效果

### 对比分析

| 场景 | hashtable | intset | 内存节省 |
|------|-----------|--------|----------|
| **10个整数** | 320字节 | 64字节 | **80%** |
| **100个整数** | 3200字节 | 400字节 | **87.5%** |
| **500个整数** | 16000字节 | 2000字节 | **87.5%** |

### 编码选择

```c
// int16: -32768 到 32767
// int32: -2147483648 到 2147483647
// int64: -9223372036854775808 到 9223372036854775807

// 示例：
// 集合 {1, 2, 3}: 使用int16编码
// 集合 {1, 2, 100000}: 升级到int32编码
// 集合 {1, 2, 10000000000}: 升级到int64编码
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **内存节省** | 节省50-80%内存 |
| **有序存储** | 元素有序，支持范围查询 |
| **紧凑存储** | 连续内存布局，缓存友好 |

### 劣势

| 特性 | 说明 |
|------|------|
| **插入慢** | O(N)时间复杂度 |
| **删除慢** | O(N)时间复杂度 |
| **类型限制** | 只能存储整数 |

## 配置优化

### 生产环境配置

```conf
# Set配置
set-max-intset-entries 512  # 最大元素数

# 调优建议
# 小集合场景：增大阈值，更多使用intset
# 大集合场景：减小阈值，避免性能问题
# 内存优先：增大阈值，节省内存
# 性能优先：减小阈值，提升性能
```

## 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/optimization/>
