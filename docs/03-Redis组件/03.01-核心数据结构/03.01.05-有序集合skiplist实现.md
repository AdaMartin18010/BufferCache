# 03.01.05 有序集合skiplist实现

## 概述

Redis的有序集合（Sorted Set）使用跳表（SkipList）和哈希表（dict）两种数据结构协同实现，既支持O(logN)的范围查询，又支持O(1)的精确查找。

## 设计目标

### 需求分析

1. **范围查询**：支持按分数范围查询（ZRANGE）
2. **精确查找**：支持O(1)的key查找
3. **有序遍历**：支持有序遍历所有元素
4. **内存优化**：平衡性能和内存占用

### 双数据结构协同

```c
// 有序集合结构
typedef struct zset {
    dict *dict;          // 哈希表：key -> score（O(1)查找）
    zskiplist *zsl;      // 跳表：按score排序（O(logN)范围查询）
} zset;
```

**设计优势**：
- 两种结构共享相同的数据对象（robj）
- 仅增加指针开销，内存占用增加有限
- 同时获得O(1)查找和O(logN)范围查询

## 跳表数据结构

### 节点结构

```c
// 跳表节点
typedef struct zskiplistNode {
    sds ele;                    // 元素值（SDS）
    double score;               // 分数
    struct zskiplistNode *backward; // 后退指针（用于反向遍历）
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前向指针
        unsigned long span;            // 跨度（用于排名）
    } level[];                  // 柔性数组，层数随机
} zskiplistNode;

// 跳表结构
typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头尾节点
    unsigned long length;        // 节点数量
    int level;                  // 最大层数
} zskiplist;
```

### 层数随机生成

```c
// 随机生成层数
int zslRandomLevel(void) {
    int level = 1;
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}

// ZSKIPLIST_P = 0.25
// 期望层数 = 1/(1-P) = 1/(1-0.25) = 1.33层
```

**概率分布**：
- 1层：75%
- 2层：18.75%
- 3层：4.69%
- 4层及以上：1.56%

## 核心操作

### 1. 查找操作

```c
// 查找节点（按score和ele）
zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;
    int i;

    // 如果范围无效，返回NULL
    if (!zslIsInRange(zsl, range)) return NULL;

    x = zsl->header;
    // 从最高层开始查找
    for (i = zsl->level-1; i >= 0; i--) {
        // 找到小于range.min的最大节点
        while (x->level[i].forward &&
               zslValueLteMax(x->level[i].forward->score, range))
            x = x->level[i].forward;
    }

    // x是小于range.min的最大节点，下一个就是范围内的第一个
    x = x->level[0].forward;
    serverAssert(x != NULL);

    // 检查是否在范围内
    if (!zslValueGteMin(x->score, range)) return NULL;
    return x;
}
```

**时间复杂度**：O(logN)

### 2. 插入操作

```c
// 插入节点
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;

    // 从最高层开始查找插入位置
    for (i = zsl->level-1; i >= 0; i--) {
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];

        while (x->level[i].forward &&
               (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                 sdscmp(x->level[i].forward->ele, ele) < 0))) {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    // 随机生成层数
    level = zslRandomLevel();
    if (level > zsl->level) {
        // 新层需要初始化
        for (i = zsl->level; i < level; i++) {
            rank[i] = 0;
            update[i] = zsl->header;
            update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
    }

    // 创建新节点
    x = zslCreateNode(level, score, ele);
    for (i = 0; i < level; i++) {
        // 更新前向指针
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;

        // 更新跨度
        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }

    // 更新未触及层的跨度
    for (i = level; i < zsl->level; i++) {
        update[i]->level[i].span++;
    }

    // 更新后退指针
    x->backward = (update[0] == zsl->header) ? NULL : update[0];
    if (x->level[0].forward)
        x->level[0].forward->backward = x;
    else
        zsl->tail = x;

    zsl->length++;
    return x;
}
```

**时间复杂度**：O(logN)

### 3. 删除操作

```c
// 删除节点
int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    x = zsl->header;
    // 查找要删除的节点
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
               (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                 sdscmp(x->level[i].forward->ele, ele) < 0)))
            x = x->level[i].forward;
        update[i] = x;
    }

    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele, ele) == 0) {
        // 找到要删除的节点
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    return 0; // 未找到
}
```

**时间复杂度**：O(logN)

## 范围查询

### ZRANGE实现

```c
// 范围查询
unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    unsigned long rank = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
               (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                 sdscmp(x->level[i].forward->ele, ele) <= 0))) {
            rank += x->level[i].span;
            x = x->level[i].forward;
        }

        if (x->ele && sdscmp(x->ele, ele) == 0) {
            return rank;
        }
    }
    return 0;
}
```

**时间复杂度**：O(logN + k)，k为返回的元素数量

## 复杂度证明

### 时间复杂度分析

**搜索路径长度**：

从最高层开始，每层跳过P比例的节点，期望搜索路径长度：

$$E[\text{路径长度}] = \sum_{i=0}^{L-1} \frac{1}{P^i} = \frac{1-P^L}{1-P} \approx \frac{1}{1-P} = \frac{1}{0.75} \approx 1.33$$

当L = log_{1/P}(N)时：

$$E[\text{路径长度}] = O(\log_{1/P} N) = O(\log N)$$

**结论**：跳表的查找、插入、删除操作都是O(logN)时间复杂度。

### 空间复杂度分析

**平均指针数**：

每个节点的平均层数 = 1/(1-P) = 1.33

**空间占用**：
- 每个节点：1.33个指针 + 数据
- 总空间：O(N)

## 与平衡树对比

| **指标** | **跳表** | **红黑树** | **结论** |
|----------|----------|------------|----------|
| **实现难度** | 简单 | 复杂 | 跳表胜 |
| **范围查询** | O(logN + k) | O(logN + k) | 平局 |
| **插入/删除** | O(logN) | O(logN) | 平局 |
| **内存开销** | 1.33倍 | 1倍 | 红黑树优 |
| **并发性** | 更易无锁化 | 锁粒度粗 | 跳表胜 |
| **代码量** | ~200行 | ~500行 | 跳表胜 |

**Redis选择跳表的原因**：
1. 实现简单，易于维护
2. 范围查询友好
3. 未来易于并行化（虽然Redis未利用）

## 编码转换

### ziplist编码

当有序集合满足以下条件时，使用ziplist编码：

```c
// 转换条件
if (zset->length < server.zset_max_ziplist_entries &&
    sdslen(ele) < server.zset_max_ziplist_value) {
    // 使用ziplist编码
    return OBJ_ENCODING_ZIPLIST;
} else {
    // 使用skiplist编码
    return OBJ_ENCODING_SKIPLIST;
}
```

**默认阈值**：
- `zset_max_ziplist_entries 128`：最大元素数
- `zset_max_ziplist_value 64`：最大元素长度

### 编码转换

```c
// ziplist转skiplist
void zsetConvert(robj *zobj, int encoding) {
    zset *zs;
    zskiplistNode *node;
    sds ele;
    double score;

    if (zobj->encoding == encoding) return;

    zs = zobj->ptr;
    zobj->ptr = zsetCreate();
    zobj->encoding = encoding;

    // 遍历ziplist，插入到skiplist
    unsigned char *zl = zs->zsl->header;
    unsigned char *eptr, *sptr;
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;

    eptr = ziplistIndex(zl, 0);
    serverAssert(eptr != NULL);
    sptr = ziplistNext(zl, eptr);
    serverAssert(sptr != NULL);

    while (eptr != NULL) {
        // 读取元素和分数
        vstr = ziplistGet(eptr, &vlen, &vlong);
        serverAssert(vstr != NULL);
        ele = sdsnewlen(vstr, vlen);

        score = zzlGetScore(sptr);

        // 插入到新结构
        zsetAdd(zobj->ptr, score, ele, NULL);

        zzlNext(zl, &eptr, &sptr);
    }

    zsetFree(zs);
}
```

## 性能优化

### 1. 跨度优化

跨度（span）用于快速计算排名，避免遍历：

```c
// 使用跨度计算排名
unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    unsigned long rank = 0;
    // 使用span累加，而不是遍历
    rank += x->level[i].span;
}
```

### 2. 批量操作

```c
// 批量插入优化
void zslBatchInsert(zskiplist *zsl, double *scores, sds *eles, int count) {
    // 预分配节点
    // 批量更新指针
    // 减少内存分配次数
}
```

## 扩展阅读

- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **跳表论文** - "Skip Lists: A Probabilistic Alternative to Balanced Trees"
