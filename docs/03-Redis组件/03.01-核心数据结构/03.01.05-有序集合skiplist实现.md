# 03.01.05 有序集合skiplist实现

## 目录

- [03.01.05 有序集合skiplist实现](#030105-有序集合skiplist实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 设计目标](#2-设计目标)
    - [2.1 需求分析](#21-需求分析)
    - [2.2 双数据结构协同](#22-双数据结构协同)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 跳表数据结构](#3-跳表数据结构)
    - [3.1 节点结构](#31-节点结构)
    - [3.2 层数随机生成](#32-层数随机生成)
    - [3.3 跳表性质](#33-跳表性质)
  - [4. 核心操作](#4-核心操作)
    - [4.1 查找操作](#41-查找操作)
    - [4.2 插入操作](#42-插入操作)
    - [4.3 删除操作](#43-删除操作)
    - [4.4 范围查询](#44-范围查询)
  - [5. 性能分析](#5-性能分析)
    - [5.1 时间复杂度分析](#51-时间复杂度分析)
    - [5.2 空间复杂度分析](#52-空间复杂度分析)
    - [5.3 跳表性能证明](#53-跳表性能证明)
  - [6. 适用场景](#6-适用场景)
    - [6.1 优势场景](#61-优势场景)
    - [6.2 不适用场景](#62-不适用场景)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 学术论文](#91-学术论文)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 经典书籍](#93-经典书籍)
    - [9.4 在线资源](#94-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**跳表（SkipList）**是Redis有序集合的核心数据结构，使用跳表和哈希表两种数据结构协同实现，既支持O(logN)的范围查询，又支持O(1)的精确查找。

**历史发展**：

- **1990年**：William Pugh提出跳表算法
- **2009年**：Redis 1.0使用跳表实现有序集合
- **2012年**：Redis 2.6优化跳表实现
- **2020年代**：跳表成为Redis有序集合的标准实现

### 1.2 应用价值

跳表在Redis中具有重要价值：

1. **范围查询**：支持O(logN)的范围查询（ZRANGE）
2. **精确查找**：结合哈希表实现O(1)的精确查找
3. **有序遍历**：支持有序遍历所有元素
4. **平衡性能**：在性能和内存之间取得平衡

## 2. 设计目标

### 2.1 需求分析

1. **范围查询**：支持按分数范围查询（ZRANGE）
2. **精确查找**：支持O(1)的key查找
3. **有序遍历**：支持有序遍历所有元素
4. **内存优化**：平衡性能和内存占用

### 2.2 双数据结构协同

```c
// 有序集合结构
typedef struct zset {
    dict *dict;          // 哈希表：key -> score（O(1)查找）
    zskiplist *zsl;      // 跳表：按score排序（O(logN)范围查询）
} zset;
```

**设计优势**：

- 两种结构共享相同的数据对象（robj）
- 仅增加指针开销，内存占用增加有限
- 同时获得O(1)查找和O(logN)范围查询

### 2.3 形式化定义

设有序集合为$S = \{(k_1, s_1), (k_2, s_2), ..., (k_n, s_n)\}$，其中$k_i$为键，$s_i$为分数。

**跳表结构**：

$$SkipList = (header, tail, length, level)$$

其中：

- $header$：头节点（不存储数据）
- $tail$：尾节点
- $length$：元素数量
- $level$：最大层数

**跳表节点**：

$$Node = (key, score, backward, level[])$$

其中$level[]$为层数组，每层包含前向指针和跨度。

## 3. 跳表数据结构

### 3.1 节点结构

```c
// 跳表节点
typedef struct zskiplistNode {
    sds ele;                    // 元素值（SDS）
    double score;               // 分数
    struct zskiplistNode *backward; // 后退指针（用于反向遍历）
    struct zskiplistLevel {
        struct zskiplistNode *forward; // 前向指针
        unsigned long span;            // 跨度（用于排名）
    } level[];                  // 柔性数组，层数随机
} zskiplistNode;

// 跳表结构
typedef struct zskiplist {
    struct zskiplistNode *header, *tail; // 头尾节点
    unsigned long length;        // 节点数量
    int level;                  // 最大层数
} zskiplist;
```

### 3.2 层数随机生成

**层数生成算法**：

$$P(level = i) = p^{i-1} \times (1-p)$$

其中$p = 0.25$（ZSKIPLIST_P）。

**期望层数**：

$$E[level] = \frac{1}{1-p} = \frac{1}{1-0.25} = \frac{4}{3} \approx 1.33$$

**定理 3.1**：跳表的期望层数为$\frac{1}{1-p}$，其中$p$为层数增长概率。

**证明**：

- 第$i$层的概率：$P(level \geq i) = p^{i-1}$
- 期望层数：$E[level] = \sum_{i=1}^{\infty} P(level \geq i) = \sum_{i=1}^{\infty} p^{i-1} = \frac{1}{1-p}$

### 3.3 跳表性质

**跳表性质**：

1. **有序性**：节点按分数有序排列
2. **多层结构**：高层节点稀疏，低层节点密集
3. **随机性**：层数随机生成，保证平衡性

```c
// 随机生成层数
int zslRandomLevel(void) {
    int level = 1;
    while ((random()&0xFFFF) < (ZSKIPLIST_P * 0xFFFF))
        level += 1;
    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;
}

// ZSKIPLIST_P = 0.25
// 期望层数 = 1/(1-P) = 1/(1-0.25) = 1.33层
```

**概率分布**：

- 1层：75%
- 2层：18.75%
- 3层：4.69%
- 4层及以上：1.56%

## 4. 核心操作

### 4.1 查找操作

```c
// 查找节点（按score和ele）
zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {
    zskiplistNode *x;
    int i;

    // 如果范围无效，返回NULL
    if (!zslIsInRange(zsl, range)) return NULL;

    x = zsl->header;
    // 从最高层开始查找
    for (i = zsl->level-1; i >= 0; i--) {
        // 找到小于range.min的最大节点
        while (x->level[i].forward &&
               zslValueLteMax(x->level[i].forward->score, range))
            x = x->level[i].forward;
    }

    // x是小于range.min的最大节点，下一个就是范围内的第一个
    x = x->level[0].forward;
    serverAssert(x != NULL);

    // 检查是否在范围内
    if (!zslValueGteMin(x->score, range)) return NULL;
    return x;
}
```

**时间复杂度**：O(logN)

**定理 4.1**：跳表查找操作的时间复杂度为O(logN)。

**证明**：

- 跳表查找从最高层开始，逐层下降
- 每层跳过约$\frac{1}{p}$个节点（$p = 0.25$，跳过4个节点）
- 查找路径长度：$L = \log_{\frac{1}{p}} N = \log_4 N = O(\log N)$

### 4.2 插入操作

```c
// 插入节点
zskiplistNode *zslInsert(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    unsigned int rank[ZSKIPLIST_MAXLEVEL];
    int i, level;

    serverAssert(!isnan(score));
    x = zsl->header;

    // 从最高层开始查找插入位置
    for (i = zsl->level-1; i >= 0; i--) {
        rank[i] = i == (zsl->level-1) ? 0 : rank[i+1];

        while (x->level[i].forward &&
               (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                 sdscmp(x->level[i].forward->ele, ele) < 0))) {
            rank[i] += x->level[i].span;
            x = x->level[i].forward;
        }
        update[i] = x;
    }

    // 随机生成层数
    level = zslRandomLevel();
    if (level > zsl->level) {
        // 新层需要初始化
        for (i = zsl->level; i < level; i++) {
            rank[i] = 0;
            update[i] = zsl->header;
            update[i]->level[i].span = zsl->length;
        }
        zsl->level = level;
    }

    // 创建新节点
    x = zslCreateNode(level, score, ele);
    for (i = 0; i < level; i++) {
        // 更新前向指针
        x->level[i].forward = update[i]->level[i].forward;
        update[i]->level[i].forward = x;

        // 更新跨度
        x->level[i].span = update[i]->level[i].span - (rank[0] - rank[i]);
        update[i]->level[i].span = (rank[0] - rank[i]) + 1;
    }

    // 更新未触及层的跨度
    for (i = level; i < zsl->level; i++) {
        update[i]->level[i].span++;
    }

    // 更新后退指针
    x->backward = (update[0] == zsl->header) ? NULL : update[0];
    if (x->level[0].forward)
        x->level[0].forward->backward = x;
    else
        zsl->tail = x;

    zsl->length++;
    return x;
}
```

**时间复杂度**：O(logN)

**定理 4.2**：跳表插入操作的时间复杂度为O(logN)。

**证明**：

- 查找插入位置：O(logN)
- 更新指针：O(level)，其中level为节点层数
- 期望层数：$E[level] = \frac{1}{1-p} \approx 1.33$
- 总时间复杂度：O(logN)

### 4.3 删除操作

```c
// 删除节点
int zslDelete(zskiplist *zsl, double score, sds ele, zskiplistNode **node) {
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;
    int i;

    x = zsl->header;
    // 查找要删除的节点
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
               (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                 sdscmp(x->level[i].forward->ele, ele) < 0)))
            x = x->level[i].forward;
        update[i] = x;
    }

    x = x->level[0].forward;
    if (x && score == x->score && sdscmp(x->ele, ele) == 0) {
        // 找到要删除的节点
        zslDeleteNode(zsl, x, update);
        if (!node)
            zslFreeNode(x);
        else
            *node = x;
        return 1;
    }
    return 0; // 未找到
}
```

**时间复杂度**：O(logN)

**定理 4.3**：跳表删除操作的时间复杂度为O(logN)。

**证明**：与插入操作类似，时间复杂度为O(logN)。

### 4.4 范围查询

**ZRANGE实现**:

```c
// 范围查询
unsigned long zslGetRank(zskiplist *zsl, double score, sds ele) {
    zskiplistNode *x;
    unsigned long rank = 0;
    int i;

    x = zsl->header;
    for (i = zsl->level-1; i >= 0; i--) {
        while (x->level[i].forward &&
               (x->level[i].forward->score < score ||
                (x->level[i].forward->score == score &&
                 sdscmp(x->level[i].forward->ele, ele) <= 0))) {
            rank += x->level[i].span;
            x = x->level[i].forward;
        }

        if (x->ele && sdscmp(x->ele, ele) == 0) {
            return rank;
        }
    }
    return 0;
}
```

**时间复杂度**：O(logN + k)，k为返回的元素数量

**定理 4.4**：跳表范围查询的时间复杂度为O(logN + k)，其中k为返回的元素数量。

**证明**：

- 定位范围起点：O(logN)
- 遍历k个元素：O(k)
- 总时间复杂度：O(logN + k)

## 5. 性能分析

### 5.1 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **查找** | O(logN) | 跳表查找 |
| **插入** | O(logN) | 跳表插入 |
| **删除** | O(logN) | 跳表删除 |
| **范围查询** | O(logN + k) | k为返回元素数 |

### 5.2 空间复杂度分析

**空间开销**：

$$S_{skiplist} = S_{header} + \sum_{i=1}^{n} S_{node_i}$$

其中：

- $S_{header}$：跳表头部大小（约24字节）
- $S_{node_i}$：第i个节点大小（约24字节 + level数 × 16字节）
- 期望层数：$E[level] = \frac{1}{1-p} \approx 1.33$

**平均空间开销**：

$$E[S_{node}] = 24 + 1.33 \times 16 \approx 45\text{字节}$$

### 5.3 跳表性能证明

**定理 5.1**：跳表的查找、插入、删除操作的时间复杂度为O(logN)。

**证明**：

**搜索路径长度分析**：

从最高层开始，每层跳过约$\frac{1}{p}$个节点（$p = 0.25$，跳过4个节点）。

期望搜索路径长度：

$$E[\text{路径长度}] = \sum_{i=0}^{L-1} \frac{1}{p^i} = \frac{1-p^L}{1-p}$$

当$L = \log_{\frac{1}{p}} N$时：

$$E[\text{路径长度}] = O(\log_{\frac{1}{p}} N) = O(\log N)$$

因此，跳表的查找、插入、删除操作都是O(logN)时间复杂度。

**定理 5.2**：跳表的空间复杂度为O(N)。

**证明**：

- 每个节点的期望层数：$E[level] = \frac{1}{1-p} \approx 1.33$
- 每个节点的平均空间：$E[S_{node}] = O(1)$
- 总空间：$S_{total} = n \times E[S_{node}] = O(N)$

## 6. 适用场景

### 6.1 优势场景

1. **范围查询**：需要频繁进行范围查询的场景
2. **有序需求**：需要有序存储和遍历的场景
3. **实现简单**：需要简单实现的有序数据结构

### 6.2 不适用场景

1. **内存极度受限**：跳表需要额外的指针开销
2. **只读场景**：不需要动态更新的场景

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **组合模式**：skiplist + dict组合实现有序集合
2. **策略模式**：不同层数生成策略
3. **迭代器模式**：范围查询迭代器

**组合模式实现**：

```c
// 有序集合组合结构
typedef struct zset {
    dict *dict;  // 哈希表，O(1)查找
    zskiplist *zsl;  // 跳表，O(logN)范围查询
} zset;
```

### 7.2 代码结构分析

**代码组织**：

1. **跳表层**：跳表数据结构实现
2. **哈希表层**：哈希表数据结构实现
3. **操作层**：有序集合核心操作（查找、插入、删除、范围查询）

**模块化设计**：

- **高内聚**：skiplist相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的操作

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 内存** | 双数据结构 | 平衡性能和内存使用 |
| **简单 vs 复杂** | 跳表+哈希表 | 支持O(1)查找和O(logN)范围查询 |
| **通用 vs 专用** | 通用有序集合实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{memory} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（O(1)查找，O(logN)范围查询）
- $C_{memory}$：内存成本（双数据结构，内存开销较大）
- $C_{complexity}$：复杂度成本（跳表实现，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新数据结构**：可扩展为其他数据结构组合
2. **新操作**：可扩展为其他有序集合操作
3. **分布式skiplist**：可扩展为分布式skiplist实现

**扩展性设计**：

```c
// 可扩展的skiplist接口
typedef struct skiplist {
    zskiplistNode *header;
    zskiplistNode *tail;
    unsigned long length;
    int level;
} zskiplist;
```

**可维护性**：

- **代码清晰**：skiplist逻辑清晰，易于理解
- **易于调试**：跳表结构易于监控和调试
- **测试友好**：skiplist行为易于测试和验证

## 8. 扩展阅读

- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 9. 权威参考

### 9.1 学术论文

1. **"Skip Lists: A Probabilistic Alternative to Balanced Trees"** - William Pugh, Communications of the ACM, 1990
   - 跳表算法的原始论文
   - DOI: 10.1145/78973.78977
   - 详细描述了跳表的设计、实现和性能分析

### 9.2 官方文档

1. **Redis源码 - t_zset.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/t_zset.c>
   - 版本: Redis 1.0+
   - 跳表的完整实现源码

2. **Redis官方文档 - Sorted Sets**
   - URL: <https://redis.io/docs/data-types/sorted-sets/>
   - 版本: Redis 7.0+
   - Redis有序集合的官方文档

### 9.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第7章：有序集合（详细分析跳表实现）

2. **《算法导论（第3版）》** - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
   - 出版社: MIT Press
   - ISBN: 978-0262033848
   - 第12章：二叉搜索树（跳表的替代方案）

### 9.4 在线资源

1. **Wikipedia - Skip List**
   - URL: <https://en.wikipedia.org/wiki/Skip_list>
   - 提供跳表的详细说明和历史背景
