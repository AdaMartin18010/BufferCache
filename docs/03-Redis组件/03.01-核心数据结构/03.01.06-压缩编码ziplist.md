# 03.01.06 压缩编码ziplist

## 目录

- [03.01.06 压缩编码ziplist](#030106-压缩编码ziplist)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 设计目标](#2-设计目标)
    - [2.1 内存优化](#21-内存优化)
    - [2.2 适用场景](#22-适用场景)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数据结构设计](#3-数据结构设计)
    - [3.1 ziplist布局](#31-ziplist布局)
    - [结构体定义](#结构体定义)
    - [3.2 Entry结构](#32-entry结构)
    - [3.3 编码规则](#33-编码规则)
      - [3.3.1 prevlen编码](#331-prevlen编码)
      - [3.3.2 encoding编码](#332-encoding编码)
  - [4. 核心操作](#4-核心操作)
    - [4.1 查找操作](#41-查找操作)
    - [4.2 插入操作](#42-插入操作)
    - [4.3 删除操作](#43-删除操作)
  - [级联更新](#级联更新)
    - [问题场景](#问题场景)
    - [级联更新实现](#级联更新实现)
    - [4.3 删除操作](#43-删除操作-1)
  - [5. 性能分析](#5-性能分析)
    - [5.1 时间复杂度分析](#51-时间复杂度分析)
    - [5.2 空间复杂度分析](#52-空间复杂度分析)
    - [5.3 内存效率分析](#53-内存效率分析)
  - [6. 适用场景](#6-适用场景)
    - [6.1 优势场景](#61-优势场景)
    - [6.2 不适用场景](#62-不适用场景)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 经典书籍](#82-经典书籍)
    - [8.3 在线资源](#83-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**ziplist（压缩列表）**是Redis为了节省内存而设计的一种紧凑型数据结构，用于存储小型的Hash、List、Set、ZSet等数据结构。通过连续内存布局和变长编码，大幅降低内存占用。

**历史发展**：

- **2009年**：Redis 1.0引入ziplist，用于优化小对象存储
- **2012年**：Redis 2.6优化ziplist编码规则
- **2015年**：Redis 3.2引入quicklist，部分替代ziplist
- **2020年代**：ziplist仍用于Hash、Set、ZSet的小对象优化

### 1.2 应用价值

ziplist在Redis中具有重要价值：

1. **内存优化**：相比hashtable节省50-90%内存
2. **紧凑存储**：连续内存布局，缓存友好
3. **变长编码**：根据数据大小自动选择编码
4. **小对象优化**：针对小对象场景优化

## 2. 设计目标

### 2.1 内存优化

1. **紧凑存储**：连续内存布局，减少内存碎片
2. **变长编码**：根据数值大小选择最小编码
3. **小对象优化**：针对小对象场景优化

### 2.2 适用场景

- Hash：元素数 < 512 且 值长度 < 64字节
- List：元素数 < 512 且 值长度 < 64字节（Redis 3.2前）
- Set：元素数 < 512 且 全为整数
- ZSet：元素数 < 128 且 值长度 < 64字节

### 2.3 形式化定义

设ziplist包含$n$个元素：$E = \{e_1, e_2, ..., e_n\}$。

**ziplist结构**：

$$Ziplist = (zlbytes, zltail, zllen, e_1, e_2, ..., e_n, zlend)$$

其中：

- $zlbytes$：总字节数（4字节）
- $zltail$：尾节点偏移量（4字节）
- $zllen$：节点数量（2字节）
- $e_i$：第i个节点（变长）
- $zlend$：结束标记（1字节，值为255）

**节点结构**：

$$Entry_i = (prevlen_i, encoding_i, data_i)$$

其中：

- $prevlen_i$：前一个节点长度（变长编码）
- $encoding_i$：编码类型（变长编码）
- $data_i$：实际数据（变长）

## 3. 数据结构设计

### 3.1 ziplist布局

```
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```

### 结构体定义

```c
// ziplist结构（内存布局，非C结构体）
// +--------+--------+--------+--------+--------+--------+
// | zlbytes| zltail | zllen  | entry1 | entry2 | ...    |
// +--------+--------+--------+--------+--------+--------+
// | 4字节  | 4字节  | 2字节  | 变长    | 变长    | ...    |

// zlbytes: 整个ziplist的字节数
// zltail: 尾节点偏移量
// zllen: 节点数量（2字节，最大65535）
// entry: 节点数据
// zlend: 结束标记（255）
```

### 3.2 Entry结构

```c
// Entry编码格式
// +--------+--------+--------+--------+
// | prevlen| encoding|  data  | ...   |
// +--------+--------+--------+--------+

// prevlen: 前一个节点的长度（变长编码）
// encoding: 当前节点的编码类型（变长编码）
// data: 实际数据
```

### 3.3 编码规则

#### 3.3.1 prevlen编码

```c
// prevlen编码规则
if (prevlen < 254) {
    // 1字节：直接存储长度
    prevlen = prevlen;
} else {
    // 5字节：254(1字节) + 实际长度(4字节)
    prevlen = 254;
    actual_len = ...;  // 4字节
}
```

#### 3.3.2 encoding编码

```c
// encoding编码规则（前2位表示类型）
// 00xxxxxx: 6位整数，0-63
// 01xxxxxx xxxxxxxx: 14位整数，0-16383
// 10xxxxxx: 字符串，长度 <= 63字节
// 11000000: int16_t整数
// 11010000: int32_t整数
// 11100000: int64_t整数
// 11110000: 24位整数
// 11111110: 8位整数
// 1111xxxx: 4位整数，0-12（xxxx-1）
```

## 4. 核心操作

### 4.1 查找操作

```c
// 查找节点（O(N)复杂度）
unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr,
                           unsigned int vlen, unsigned int skip) {
    unsigned int skipcnt = 0;
    unsigned char vencoding = 0;
    long long vll = 0;

    while (p[0] != ZIP_END) {
        unsigned int prevlensize, encoding, lensize, len;
        unsigned char *q;

        ZIP_DECODE_PREVLENSIZE(p, prevlensize);
        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
        q = p + prevlensize + lensize;

        if (skipcnt == 0) {
            // 比较数据
            if (ZIP_IS_STR(encoding)) {
                if (len == vlen && memcmp(q, vstr, vlen) == 0) {
                    return p;
                }
            } else {
                if (zipTryEncoding(vstr, vlen, &vll, &vencoding)) {
                    if (vencoding == encoding) {
                        long long ll = zipLoadInteger(q, encoding);
                        if (ll == vll) {
                            return p;
                        }
                    }
                }
            }

            skipcnt = skip;
        } else {
            skipcnt--;
        }

        p = q + len;
    }

    return NULL;
}
```

**时间复杂度**：O(N)

**定理 4.1**：ziplist查找操作的时间复杂度为O(N)。

**证明**：

- ziplist使用连续内存布局，不支持随机访问
- 查找需要从头开始遍历所有节点
- 最坏情况需要遍历所有n个节点
- 时间复杂度：O(N)

### 4.2 插入操作

```c
// 插入节点
unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p,
                            unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl, p, s, slen);
}

unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p,
                               unsigned char *s, unsigned int slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789;
    zlentry tail;

    // 1. 计算所需空间
    if (p[0] != ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } else {
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            prevlen = zipRawEntryLength(ptail);
        }
    }

    // 2. 尝试整数编码
    if (zipTryEncoding(s, slen, &value, &encoding)) {
        reqlen = zipIntSize(encoding);
    } else {
        reqlen = slen;
    }
    reqlen += zipStorePrevEntryLength(NULL, prevlen);
    reqlen += zipStoreEntryEncoding(NULL, encoding, slen);

    // 3. 检查是否需要扩容
    int forcelarge = 0;
    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p, prevlen) : 0;
    if (nextdiff == -4 && reqlen < 4) {
        nextdiff = 0;
        forcelarge = 1;
    }

    // 4. 重新分配内存
    offset = p - zl;
    zl = ziplistResize(zl, curlen + reqlen + nextdiff);
    p = zl + offset;

    // 5. 移动后续节点
    if (p[0] != ZIP_END) {
        memmove(p + reqlen, p - nextdiff, curlen - offset - 1 + nextdiff);

        // 更新后续节点的prevlen
        zipPrevLenToLen(p + reqlen, prevlen);
    }

    // 6. 写入新节点
    p += zipStorePrevEntryLength(p, prevlen);
    p += zipStoreEntryEncoding(p, encoding, slen);
    if (ZIP_IS_STR(encoding)) {
        memcpy(p, s, slen);
    } else {
        zipSaveInteger(p, value, encoding);
    }
    ZIPLIST_INCR_LENGTH(zl, 1);
    return zl;
}
```

**时间复杂度**：O(N)（需要移动后续节点）

### 4.3 删除操作

```c
// 删除节点
unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p - zl;
    zl = __ziplistDelete(zl, *p, 1);

    *p = zl + offset;
    return zl;
}

unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p,
                               unsigned int num) {
    unsigned int i, totlen, deleted = 0;
    size_t offset;
    int nextdiff = 0;
    zlentry first, tail;
    size_t zlbytes, zltail_offset;

    first = zipEntry(p);
    for (i = 0; p[0] != ZIP_END && i < num; i++) {
        p += zipRawEntryLength(p);
        deleted++;
    }

    totlen = p - first.p;
    if (totlen > 0) {
        if (p[0] != ZIP_END) {
            // 更新后续节点的prevlen
            nextdiff = zipPrevLenByteDiff(p, first.prevrawlen);
            zipPrevLenToLen(p, first.prevrawlen);
        } else {
            // 删除的是尾节点
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe((first.p - zl) - first.prevrawlen);
        }

        // 移动内存
        offset = first.p - zl;
        memmove(first.p, p, intrev32ifbe(ZIPLIST_BYTES(zl)) -
               (p - zl) - 1);
        offset -= deleted;
        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl)) - totlen + nextdiff);
        ZIPLIST_INCR_LENGTH(zl, -deleted);
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) - totlen);

        // 级联更新
        if (nextdiff != 0)
            zl = __ziplistCascadeUpdate(zl, p);
    } else {
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe((first.p - zl) - first.prevrawlen);
    }

    return zl;
}
```

**时间复杂度**：O(N)

## 级联更新

### 问题场景

当删除或插入节点导致prevlen变化时，可能触发级联更新：

```
原始ziplist:
[1字节prevlen][data1][1字节prevlen][data2][1字节prevlen][data3]

删除data1后，data2的prevlen需要更新：
如果data1长度>=254，data2的prevlen从1字节变为5字节
这可能导致data2总长度变化，进而影响data3的prevlen
```

### 级联更新实现

```c
// 级联更新
unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
    size_t offset, noffset, extra;
    unsigned char *np;
    zlentry cur, next;

    while (p[0] != ZIP_END) {
        cur = zipEntry(p);
        rawlen = cur.headersize + cur.len;
        rawlensize = zipStorePrevEntryLength(NULL, rawlen);

        if (p[rawlen] == ZIP_END) break;
        next = zipEntry(p + rawlen);

        if (next.prevrawlen == rawlen) break;

        if (next.prevrawlen < rawlen) {
            // 需要扩展prevlen
            offset = p - zl;
            extra = rawlensize - next.prevrawlen;
            zl = ziplistResize(zl, curlen + extra);
            p = zl + offset;

            np = p + rawlen;
            noffset = np - zl;

            if ((zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
                ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + extra);
            }

            memmove(np + rawlensize,
                    np + next.prevrawlen,
                    curlen - noffset - next.prevrawlen - 1);
            zipStorePrevEntryLength(np, rawlen);

            p += rawlen;
            curlen += extra;
        } else {
            // prevlen过大，可以缩小
            if (next.prevrawlen > rawlensize) {
                zipStorePrevEntryLengthLarge(np + rawlen, rawlen);
            } else {
                zipStorePrevEntryLength(np + rawlen, rawlen);
            }
            break;
        }
    }
    return zl;
}
```

**定理 4.2**：ziplist插入操作的时间复杂度为O(N)，最坏情况为O(N²)。

**证明**：

- 查找插入位置：O(N)
- 移动数据：O(N)
- 级联更新prevlen：最坏情况O(N)
- 总时间复杂度：O(N)，最坏情况O(N²)

### 4.3 删除操作

**删除操作**与插入操作类似，时间复杂度为O(N)，最坏情况O(N²)。

## 5. 性能分析

### 5.1 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **查找** | O(N) | 需要遍历所有节点 |
| **插入** | O(N) | 需要移动数据 |
| **删除** | O(N) | 需要移动数据 |
| **级联更新** | O(N²) | 最坏情况 |

### 5.2 空间复杂度分析

**空间开销**：

$$S_{ziplist} = S_{header} + \sum_{i=1}^{n} S_{entry_i}$$

其中：

- $S_{header}$：ziplist头部大小（11字节）
- $S_{entry_i}$：第i个节点大小（变长，取决于编码）

**编码优化**：

- 小整数（0-12）：1字节
- 中等整数（0-63）：1字节
- 大整数（0-16383）：2字节
- 字符串：1字节（长度）+ 数据长度

### 5.3 内存效率分析

**内存优化效果对比**：

| 数据结构 | 传统实现 | ziplist | 内存节省 |
|----------|----------|---------|----------|
| **Hash（10个字段）** | 320字节 | 120字节 | **62%** |
| **List（10个元素）** | 240字节 | 100字节 | **58%** |
| **Set（10个整数）** | 160字节 | 60字节 | **62%** |

**定理 5.1**：ziplist相比传统实现可以节省50-80%的内存。

**证明**：

- 传统实现：每个元素需要指针（8字节）+ 数据大小
- ziplist：使用变长编码，小整数只需1-2字节
- 内存节省：$\frac{S_{traditional} - S_{ziplist}}{S_{traditional}} \approx 50-80\%$

## 6. 适用场景

### 6.1 优势场景

1. **小对象**：元素数量<512，值长度<64字节
2. **内存敏感**：需要节省内存的场景
3. **顺序访问**：主要进行顺序遍历的场景

### 6.2 不适用场景

1. **大对象**：元素数量>512或值长度>64字节
2. **频繁查找**：需要O(1)查找的场景
3. **频繁插入删除**：O(N)时间复杂度影响性能

## 7. 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [有序集合skiplist实现](./03.01.05-有序集合skiplist实现.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 8. 权威参考

### 8.1 官方文档

1. **Redis源码 - ziplist.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/ziplist.c>
   - 版本: Redis 1.0+
   - ziplist的完整实现源码

2. **Redis官方文档 - Memory Optimization**
   - URL: <https://redis.io/docs/manual/optimization/>
   - 版本: Redis 7.0+
   - Redis内存优化的官方文档

### 8.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第8章：压缩列表（详细分析ziplist实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第1章：Redis基础数据结构（ziplist详解）

### 8.3 在线资源

1. **Wikipedia - Variable-Length Encoding**
   - URL: <https://en.wikipedia.org/wiki/Variable-length_code>
   - 提供变长编码的详细说明
