# 03.01.06 压缩编码ziplist

## 概述

ziplist（压缩列表）是Redis为了节省内存而设计的一种紧凑型数据结构，用于存储小型的Hash、List、Set、ZSet等数据结构。通过连续内存布局和变长编码，大幅降低内存占用。

## 设计目标

### 内存优化

1. **紧凑存储**：连续内存布局，减少内存碎片
2. **变长编码**：根据数值大小选择最小编码
3. **小对象优化**：针对小对象场景优化

### 适用场景

- Hash：元素数 < 512 且 值长度 < 64字节
- List：元素数 < 512 且 值长度 < 64字节（Redis 3.2前）
- Set：元素数 < 512 且 全为整数
- ZSet：元素数 < 128 且 值长度 < 64字节

## 数据结构设计

### ziplist布局

```
<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```

### 结构体定义

```c
// ziplist结构（内存布局，非C结构体）
// +--------+--------+--------+--------+--------+--------+
// | zlbytes| zltail | zllen  | entry1 | entry2 | ...    |
// +--------+--------+--------+--------+--------+--------+
// | 4字节  | 4字节  | 2字节  | 变长    | 变长    | ...    |

// zlbytes: 整个ziplist的字节数
// zltail: 尾节点偏移量
// zllen: 节点数量（2字节，最大65535）
// entry: 节点数据
// zlend: 结束标记（255）
```

### Entry结构

```c
// Entry编码格式
// +--------+--------+--------+--------+
// | prevlen| encoding|  data  | ...   |
// +--------+--------+--------+--------+

// prevlen: 前一个节点的长度（变长编码）
// encoding: 当前节点的编码类型（变长编码）
// data: 实际数据
```

### prevlen编码

```c
// prevlen编码规则
if (prevlen < 254) {
    // 1字节：直接存储长度
    prevlen = prevlen;
} else {
    // 5字节：254(1字节) + 实际长度(4字节)
    prevlen = 254;
    actual_len = ...;  // 4字节
}
```

### encoding编码

```c
// encoding编码规则（前2位表示类型）
// 00xxxxxx: 6位整数，0-63
// 01xxxxxx xxxxxxxx: 14位整数，0-16383
// 10xxxxxx: 字符串，长度 <= 63字节
// 11000000: int16_t整数
// 11010000: int32_t整数
// 11100000: int64_t整数
// 11110000: 24位整数
// 11111110: 8位整数
// 1111xxxx: 4位整数，0-12（xxxx-1）
```

## 核心操作

### 1. 查找操作

```c
// 查找节点（O(N)复杂度）
unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr,
                           unsigned int vlen, unsigned int skip) {
    unsigned int skipcnt = 0;
    unsigned char vencoding = 0;
    long long vll = 0;

    while (p[0] != ZIP_END) {
        unsigned int prevlensize, encoding, lensize, len;
        unsigned char *q;

        ZIP_DECODE_PREVLENSIZE(p, prevlensize);
        ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);
        q = p + prevlensize + lensize;

        if (skipcnt == 0) {
            // 比较数据
            if (ZIP_IS_STR(encoding)) {
                if (len == vlen && memcmp(q, vstr, vlen) == 0) {
                    return p;
                }
            } else {
                if (zipTryEncoding(vstr, vlen, &vll, &vencoding)) {
                    if (vencoding == encoding) {
                        long long ll = zipLoadInteger(q, encoding);
                        if (ll == vll) {
                            return p;
                        }
                    }
                }
            }

            skipcnt = skip;
        } else {
            skipcnt--;
        }

        p = q + len;
    }

    return NULL;
}
```

**时间复杂度**：O(N)

### 2. 插入操作

```c
// 插入节点
unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p,
                            unsigned char *s, unsigned int slen) {
    return __ziplistInsert(zl, p, s, slen);
}

unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p,
                               unsigned char *s, unsigned int slen) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;
    unsigned int prevlensize, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789;
    zlentry tail;

    // 1. 计算所需空间
    if (p[0] != ZIP_END) {
        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);
    } else {
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            prevlen = zipRawEntryLength(ptail);
        }
    }

    // 2. 尝试整数编码
    if (zipTryEncoding(s, slen, &value, &encoding)) {
        reqlen = zipIntSize(encoding);
    } else {
        reqlen = slen;
    }
    reqlen += zipStorePrevEntryLength(NULL, prevlen);
    reqlen += zipStoreEntryEncoding(NULL, encoding, slen);

    // 3. 检查是否需要扩容
    int forcelarge = 0;
    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p, prevlen) : 0;
    if (nextdiff == -4 && reqlen < 4) {
        nextdiff = 0;
        forcelarge = 1;
    }

    // 4. 重新分配内存
    offset = p - zl;
    zl = ziplistResize(zl, curlen + reqlen + nextdiff);
    p = zl + offset;

    // 5. 移动后续节点
    if (p[0] != ZIP_END) {
        memmove(p + reqlen, p - nextdiff, curlen - offset - 1 + nextdiff);

        // 更新后续节点的prevlen
        zipPrevLenToLen(p + reqlen, prevlen);
    }

    // 6. 写入新节点
    p += zipStorePrevEntryLength(p, prevlen);
    p += zipStoreEntryEncoding(p, encoding, slen);
    if (ZIP_IS_STR(encoding)) {
        memcpy(p, s, slen);
    } else {
        zipSaveInteger(p, value, encoding);
    }
    ZIPLIST_INCR_LENGTH(zl, 1);
    return zl;
}
```

**时间复杂度**：O(N)（需要移动后续节点）

### 3. 删除操作

```c
// 删除节点
unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {
    size_t offset = *p - zl;
    zl = __ziplistDelete(zl, *p, 1);

    *p = zl + offset;
    return zl;
}

unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p,
                               unsigned int num) {
    unsigned int i, totlen, deleted = 0;
    size_t offset;
    int nextdiff = 0;
    zlentry first, tail;
    size_t zlbytes, zltail_offset;

    first = zipEntry(p);
    for (i = 0; p[0] != ZIP_END && i < num; i++) {
        p += zipRawEntryLength(p);
        deleted++;
    }

    totlen = p - first.p;
    if (totlen > 0) {
        if (p[0] != ZIP_END) {
            // 更新后续节点的prevlen
            nextdiff = zipPrevLenByteDiff(p, first.prevrawlen);
            zipPrevLenToLen(p, first.prevrawlen);
        } else {
            // 删除的是尾节点
            ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe((first.p - zl) - first.prevrawlen);
        }

        // 移动内存
        offset = first.p - zl;
        memmove(first.p, p, intrev32ifbe(ZIPLIST_BYTES(zl)) -
               (p - zl) - 1);
        offset -= deleted;
        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl)) - totlen + nextdiff);
        ZIPLIST_INCR_LENGTH(zl, -deleted);
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) - totlen);

        // 级联更新
        if (nextdiff != 0)
            zl = __ziplistCascadeUpdate(zl, p);
    } else {
        ZIPLIST_TAIL_OFFSET(zl) =
            intrev32ifbe((first.p - zl) - first.prevrawlen);
    }

    return zl;
}
```

**时间复杂度**：O(N)

## 级联更新

### 问题场景

当删除或插入节点导致prevlen变化时，可能触发级联更新：

```
原始ziplist:
[1字节prevlen][data1][1字节prevlen][data2][1字节prevlen][data3]

删除data1后，data2的prevlen需要更新：
如果data1长度>=254，data2的prevlen从1字节变为5字节
这可能导致data2总长度变化，进而影响data3的prevlen
```

### 级联更新实现

```c
// 级联更新
unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
    size_t offset, noffset, extra;
    unsigned char *np;
    zlentry cur, next;

    while (p[0] != ZIP_END) {
        cur = zipEntry(p);
        rawlen = cur.headersize + cur.len;
        rawlensize = zipStorePrevEntryLength(NULL, rawlen);

        if (p[rawlen] == ZIP_END) break;
        next = zipEntry(p + rawlen);

        if (next.prevrawlen == rawlen) break;

        if (next.prevrawlen < rawlen) {
            // 需要扩展prevlen
            offset = p - zl;
            extra = rawlensize - next.prevrawlen;
            zl = ziplistResize(zl, curlen + extra);
            p = zl + offset;

            np = p + rawlen;
            noffset = np - zl;

            if ((zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
                ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + extra);
            }

            memmove(np + rawlensize,
                    np + next.prevrawlen,
                    curlen - noffset - next.prevrawlen - 1);
            zipStorePrevEntryLength(np, rawlen);

            p += rawlen;
            curlen += extra;
        } else {
            // prevlen过大，可以缩小
            if (next.prevrawlen > rawlensize) {
                zipStorePrevEntryLengthLarge(np + rawlen, rawlen);
            } else {
                zipStorePrevEntryLength(np + rawlen, rawlen);
            }
            break;
        }
    }
    return zl;
}
```

**最坏情况**：O(N²)（所有节点都需要更新）

## 内存优化效果

### 对比分析

| 数据结构 | 传统实现 | ziplist | 内存节省 |
|----------|----------|---------|----------|
| **Hash（10个字段）** | 320字节 | 120字节 | **62%** |
| **List（10个元素）** | 240字节 | 100字节 | **58%** |
| **Set（10个整数）** | 160字节 | 60字节 | **62%** |

### 编码优化示例

```c
// 整数编码优化
// 小整数（0-12）：4位编码，1字节
// 中等整数（0-63）：6位编码，1字节
// 大整数（0-16383）：14位编码，2字节
// 更大整数：使用int16/int32/int64

// 示例：存储整数5
// 传统方式：8字节（int64_t）
// ziplist：1字节（11110001，其中0001=5-1=4，实际存储5）
// 节省：87.5%
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **内存节省** | 节省50-80%内存 |
| **缓存友好** | 连续内存布局，缓存命中率高 |
| **紧凑存储** | 减少内存碎片 |

### 劣势

| 特性 | 说明 |
|------|------|
| **查找慢** | O(N)时间复杂度 |
| **插入慢** | O(N)时间复杂度，需要移动数据 |
| **级联更新** | 最坏情况O(N²) |
| **大小限制** | 只适合小对象 |

## 编码转换

### 转换条件

```c
// Hash转换条件
if (hash->length < server.hash_max_ziplist_entries &&
    all_values_small(hash)) {
    // 使用ziplist
    return OBJ_ENCODING_ZIPLIST;
} else {
    // 转换为hashtable
    return OBJ_ENCODING_HT;
}

// List转换条件（Redis 3.2前）
if (list->length < server.list_max_ziplist_entries &&
    all_values_small(list)) {
    return OBJ_ENCODING_ZIPLIST;
} else {
    return OBJ_ENCODING_LINKEDLIST;
}
```

### 转换实现

```c
// ziplist转hashtable
void hashTypeConvert(robj *o, int enc) {
    if (o->encoding == OBJ_ENCODING_ZIPLIST) {
        hashTypeIterator *hi;
        dict *dict;
        int ret;

        hi = hashTypeInitIterator(o);
        dict = dictCreate(&hashDictType, NULL);

        while (hashTypeNext(hi) != C_ERR) {
            sds field, value;

            field = hashTypeCurrentObjectNewSds(hi, OBJ_HASH_KEY);
            value = hashTypeCurrentObjectNewSds(hi, OBJ_HASH_VALUE);
            ret = dictAdd(dict, field, value);
            if (ret != DICT_OK) {
                // 错误处理
            }
        }

        hashTypeReleaseIterator(hi);
        zfree(o->ptr);
        o->encoding = OBJ_ENCODING_HT;
        o->ptr = dict;
    }
}
```

## 配置优化

### 生产环境配置

```conf
# Hash配置
hash-max-ziplist-entries 512    # 最大元素数
hash-max-ziplist-value 64       # 最大值长度

# List配置（Redis 3.2前）
list-max-ziplist-entries 512
list-max-ziplist-value 64

# Set配置
set-max-intset-entries 512      # 整数集合最大元素数

# ZSet配置
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
```

### 调优建议

1. **小对象场景**：增大阈值，更多使用ziplist
2. **大对象场景**：减小阈值，避免性能问题
3. **内存优先**：增大阈值，节省内存
4. **性能优先**：减小阈值，提升性能

## 扩展阅读

- [SDS简单动态字符串](./03.01.01-SDS简单动态字符串.md)
- [哈希表dict实现](./03.01.02-哈希表dict实现.md)
- [有序集合skiplist实现](./03.01.05-有序集合skiplist实现.md)
- [Redis内存管理](../03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/optimization/>
