# 03.01.07 HyperLogLog基数统计

## 目录

- [03.01.07 HyperLogLog基数统计](#030107-hyperloglog基数统计)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. HyperLogLog原理](#2-hyperloglog原理)
    - [2.1 基本概念](#21-基本概念)
    - [2.2 算法原理](#22-算法原理)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数学模型与理论分析](#3-数学模型与理论分析)
    - [3.1 基数估计公式](#31-基数估计公式)
    - [3.2 误差率分析](#32-误差率分析)
    - [3.3 复杂度分析](#33-复杂度分析)
      - [3.3.1 时间复杂度](#331-时间复杂度)
      - [3.3.2 空间复杂度](#332-空间复杂度)
  - [4. Redis实现](#4-redis实现)
    - [4.1 稀疏编码](#41-稀疏编码)
    - [4.2 密集编码](#42-密集编码)
    - [3. 基数估计](#3-基数估计)
    - [4.3 基数估计](#43-基数估计)
  - [5. 性能分析](#5-性能分析)
    - [5.1 内存占用分析](#51-内存占用分析)
    - [5.2 误差率分析](#52-误差率分析)
    - [5.3 时间复杂度分析](#53-时间复杂度分析)
  - [6. 适用场景](#6-适用场景)
    - [6.1 优势场景](#61-优势场景)
    - [6.2 不适用场景](#62-不适用场景)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 学术论文](#91-学术论文)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 经典书籍](#93-经典书籍)
    - [9.4 在线资源](#94-在线资源)
    - [2. PFCOUNT](#2-pfcount)
    - [3. PFMERGE](#3-pfmerge)
  - [性能分析](#性能分析)
    - [1. 内存占用](#1-内存占用)
    - [2. 误差率](#2-误差率)
    - [3. 时间复杂度](#3-时间复杂度)
  - [应用场景](#应用场景)
    - [1. UV统计](#1-uv统计)
    - [2. 去重统计](#2-去重统计)
  - [扩展阅读](#扩展阅读)
  - [权威参考](#权威参考)

---

## 1. 概述

### 1.1 定义与历史背景

**HyperLogLog**是Redis用于基数统计（Cardinality Estimation）的数据结构，使用极小的内存空间（约12KB）即可统计数十亿级别的唯一元素数量，误差率约0.81%。

**历史发展**：

- **2007年**：Philippe Flajolet等人提出HyperLogLog算法
- **2012年**：Redis 2.8引入HyperLogLog
- **2015年**：Redis 3.2优化HyperLogLog实现
- **2020年代**：HyperLogLog成为基数统计的标准算法

### 1.2 应用价值

HyperLogLog在Redis中具有重要价值：

1. **内存效率**：使用极小的内存空间（约12KB）
2. **高精度**：误差率约0.81%
3. **高性能**：O(1)的添加和查询操作
4. **可合并**：支持多个HyperLogLog合并

## 2. HyperLogLog原理

### 2.1 基本概念

```c
// HyperLogLog基本概念
// 1. 使用概率算法估计基数
// 2. 内存占用固定（12KB）
// 3. 误差率约0.81%
// 4. 支持合并操作

// HyperLogLog结构
struct hllhdr {
    char magic[4];      // "HYLL"魔数
    uint8_t encoding;   // 编码方式（HLL_DENSE或HLL_SPARSE）
    uint8_t notused[3]; // 保留字段
    uint8_t card[8];    // 缓存基数（可选）
    uint8_t registers[]; // 寄存器数组
};
```

### 2.2 算法原理

```python
# HyperLogLog算法原理
class HyperLogLog:
    """
    1. 哈希函数：将元素映射到[0, 2^64-1]
    2. 前导零：统计哈希值前导零的个数
    3. 寄存器：使用前导零的最大值更新寄存器
    4. 估计：使用调和平均数估计基数
    """

    def add(self, element):
        """添加元素"""
        hash_value = hash(element)
        leading_zeros = count_leading_zeros(hash_value)
        register_index = extract_register_index(hash_value)
        self.registers[register_index] = max(
            self.registers[register_index],
            leading_zeros + 1
        )

    def count(self):
        """估计基数"""
        # 调和平均数
        harmonic_mean = sum(2 ** -r for r in self.registers)
        estimate = self.alpha * self.m ** 2 / harmonic_mean
        return estimate
```

### 2.3 形式化定义

设元素集合为$S = \{e_1, e_2, ..., e_n\}$，基数为$n = |S|$。

**HyperLogLog形式化定义**：

1. **哈希函数**：$h: S \rightarrow [0, 2^{64})$，将元素映射到64位整数
2. **寄存器索引**：$j = h(e) \bmod m$，其中$m = 2^{14} = 16384$
3. **前导零计数**：$\rho(h(e)) = \text{前导零个数} + 1$
4. **寄存器更新**：$M[j] = \max(M[j], \rho(h(e)))$

**基数估计公式**：

$$E = \alpha_m \cdot m^2 \cdot \left(\sum_{j=0}^{m-1} 2^{-M[j]}\right)^{-1}$$

其中$\alpha_m$为修正因子。

## 3. 数学模型与理论分析

### 3.1 基数估计公式

**标准误差**：

$$\sigma = \frac{1.04}{\sqrt{m}}$$

其中$m$为寄存器数量。

**定理 3.1**：HyperLogLog的标准误差为$\frac{1.04}{\sqrt{m}}$。

**证明**：

- 寄存器数量$m = 2^{14} = 16384$
- 标准误差：$\sigma = \frac{1.04}{\sqrt{16384}} = \frac{1.04}{128} \approx 0.0081 = 0.81\%$

### 3.2 误差率分析

**误差率**：

$$\text{误差率} = \frac{\sigma}{E} = \frac{1.04}{\sqrt{m} \cdot E}$$

其中$E$为估计值。

**定理 3.2**：当$m = 16384$时，误差率约为0.81%。

**证明**：

- 标准误差：$\sigma = \frac{1.04}{\sqrt{16384}} \approx 0.0081$
- 对于大基数（$E > 10^6$），相对误差：$\frac{\sigma}{E} \approx 0.81\%$

### 3.3 复杂度分析

#### 3.3.1 时间复杂度

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **添加元素** | O(1) | 哈希+寄存器更新 |
| **查询基数** | O(m) | 遍历所有寄存器 |
| **合并** | O(m) | 遍历所有寄存器 |

#### 3.3.2 空间复杂度

- **密集编码**：O(m)，存储m个寄存器（每个6位）
- **稀疏编码**：O(k)，k为非零寄存器数
- **总空间复杂度**：O(m)（最坏情况）

## 4. Redis实现

### 4.1 稀疏编码

```c
// 稀疏编码（HLL_SPARSE）
// 适用于基数较小的情况
// 只存储非零寄存器

// 稀疏编码格式
// ZERO: 00xxxxxx - 连续零寄存器
// XZERO: 01xxxxxx xxxxxxxx - 扩展零寄存器
// VAL: 1vvvvvxx - 值寄存器

// 稀疏编码示例
// [ZERO: 5个零] [VAL: 3] [ZERO: 10个零] [VAL: 5]
```

### 4.2 密集编码

```c
// 密集编码（HLL_DENSE）
// 适用于基数较大的情况
// 存储所有寄存器

// 寄存器数组
uint8_t registers[16384];  // 2^14个寄存器，每个6位

// 寄存器访问
uint8_t hllDenseGetRegister(uint8_t *registers, long regnum) {
    uint8_t *byte = registers + (regnum * 6) / 8;
    uint8_t fb = regnum * 6 & 7;  // 第一个位的位置
    uint8_t fb8 = 8 - fb;
    uint8_t bit = 6;

    if (fb8 >= 6) {
        return (*byte >> fb) & ((1<<6)-1);
    } else {
        uint8_t l = *byte >> fb;
        uint8_t r = *(byte+1) << fb8;
        return (l | r) & ((1<<6)-1);
    }
}
```

### 3. 基数估计

```c
// 基数估计
uint64_t hllCount(struct hllhdr *hdr, int *invalid) {
    double m = 16384;  // 寄存器数量
    double E;
    int j;
    int reghisto[64] = {0};

    // 统计寄存器分布
    for (j = 0; j < m; j++) {
        unsigned long reg;
        reg = hllGetRegister(hdr, j);
        reghisto[reg]++;
    }

    // 计算调和平均数
    double z = m * hllTau((m - reghisto[64]) / m);
    for (j = 63; j >= 1; j--) {
        z += reghisto[j];
        z *= 0.5;
    }
    z += m * hllSigma(reghisto[0] / m);

    // 估计值
    E = llroundl(m * m * hllAlpha(m) / z);

    return (uint64_t)E;
}
```

### 4.3 基数估计

**基数估计实现**已在上面定义。

## 5. 性能分析

### 5.1 内存占用分析

**内存占用**：

| 编码方式 | 内存占用 | 说明 |
|---------|----------|------|
| **稀疏编码** | <1KB-12KB | 基数较小时使用 |
| **密集编码** | 12KB（固定） | 基数较大时使用 |

**定理 5.1**：HyperLogLog的内存占用固定为12KB（密集编码）。

**证明**：

- 寄存器数量：$m = 2^{14} = 16384$
- 每个寄存器：6位
- 总内存：$\frac{16384 \times 6}{8} = 12288\text{字节} = 12\text{KB}$

### 5.2 误差率分析

**误差率**：

$$\text{误差率} = \frac{1.04}{\sqrt{m}} = \frac{1.04}{\sqrt{16384}} \approx 0.0081 = 0.81\%$$

**定理 5.2**：HyperLogLog的标准误差为0.81%。

**证明**：

- 寄存器数量：$m = 16384$
- 标准误差：$\sigma = \frac{1.04}{\sqrt{16384}} = \frac{1.04}{128} \approx 0.0081 = 0.81\%$

### 5.3 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **PFADD** | O(1) | 哈希+寄存器更新 |
| **PFCOUNT** | O(m) | 遍历所有寄存器（m=16384，固定） |
| **PFMERGE** | O(m × k) | k为HyperLogLog数量 |

## 6. 适用场景

### 6.1 优势场景

1. **UV统计**：统计独立访客数（Unique Visitors）
2. **去重统计**：统计唯一元素数量
3. **大数据基数统计**：统计数十亿级别的唯一元素

### 6.2 不适用场景

1. **精确统计**：需要精确基数统计的场景
2. **小数据量**：数据量较小时，使用Set更合适

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：不同编码策略（稀疏编码、密集编码）
2. **适配器模式**：适配不同基数范围
3. **模板方法模式**：定义基数估计的基本流程

**策略模式实现**：

```c
// HyperLogLog编码策略接口
typedef struct hll_encoding_strategy {
    void (*encode)(hllhdr *hdr, uint8_t *registers);
    uint64_t (*estimate)(hllhdr *hdr);
    const char *name;
} hll_encoding_strategy_t;

// 不同编码策略
hll_encoding_strategy_t strategies[] = {
    {.encode = sparse_encode, .name = "稀疏编码"},
    {.encode = dense_encode, .name = "密集编码"},
};
```

### 7.2 代码结构分析

**代码组织**：

1. **编码层**：稀疏编码和密集编码实现
2. **算法层**：基数估计算法实现
3. **操作层**：HyperLogLog操作（PFADD、PFCOUNT）

**模块化设计**：

- **高内聚**：HyperLogLog相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的编码策略

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **精度 vs 内存** | 稀疏+密集编码 | 平衡精度和内存使用 |
| **简单 vs 复杂** | 双编码设计 | 支持不同基数范围 |
| **通用 vs 专用** | 通用基数估计 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{accuracy} + C_{memory} + C_{complexity}$$

其中：

- $C_{accuracy}$：精度成本（误差率0.81%）
- $C_{memory}$：内存成本（稀疏+密集编码，内存优化）
- $C_{complexity}$：复杂度成本（双编码设计，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新编码策略**：可扩展为其他编码策略
2. **新估计算法**：可扩展为其他估计算法
3. **分布式HyperLogLog**：可扩展为分布式HyperLogLog实现

**扩展性设计**：

```c
// 可扩展的HyperLogLog接口
typedef struct hyperloglog {
    hllhdr *hdr;
    hll_encoding_strategy_t *strategy;
    uint64_t (*count)(struct hyperloglog *hll);
} hyperloglog_t;
```

**可维护性**：

- **代码清晰**：HyperLogLog逻辑清晰，易于理解
- **易于调试**：编码状态易于监控和调试
- **测试友好**：HyperLogLog行为易于测试和验证

## 8. 扩展阅读

- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [集合intset实现](./03.01.04-集合intset实现.md)

## 9. 权威参考

### 9.1 学术论文

1. **"HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm"** - Philippe Flajolet, Éric Fusy, Olivier Gandouet, Frédéric Meunier, AofA, 2007
   - HyperLogLog算法的原始论文
   - URL: <http://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf>
   - 详细描述了HyperLogLog的设计、实现和性能分析

2. **"LogLog Counting of Large Cardinalities"** - Marianne Durand, Philippe Flajolet, ESA, 2003
   - LogLog算法的原始论文
   - DOI: 10.1007/978-3-540-39658-1_26
   - HyperLogLog的前身算法

### 9.2 官方文档

1. **Redis源码 - hyperloglog.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/hyperloglog.c>
   - 版本: Redis 2.8+
   - HyperLogLog的完整实现源码

2. **Redis官方文档 - HyperLogLog**
   - URL: <https://redis.io/docs/data-types/hyperloglogs/>
   - 版本: Redis 7.0+
   - HyperLogLog的官方文档

### 9.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第9章：HyperLogLog（详细分析HyperLogLog实现）

2. **《算法导论（第3版）》** - Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, Clifford Stein
   - 出版社: MIT Press
   - ISBN: 978-0262033848
   - 第5章：概率分析和随机算法（概率算法基础）

### 9.4 在线资源

1. **Wikipedia - HyperLogLog**
   - URL: <https://en.wikipedia.org/wiki/HyperLogLog>
   - 提供HyperLogLog的详细说明和历史背景

```c
// PFADD命令
int pfaddCommand(client *c) {
    robj *o = lookupKeyWrite(c->db, c->argv[1]);
    struct hllhdr *hdr;
    int updated = 0, j;

    // 创建或获取HyperLogLog
    if (o == NULL) {
        o = createHLLObject();
        dbAdd(c->db, c->argv[1], o);
        updated++;
    } else {
        if (isHLLObjectOrReply(c, o) != C_OK) return;
    }

    hdr = o->ptr;

    // 添加元素
    for (j = 2; j < c->argc; j++) {
        int retval = hllAdd(hdr, (unsigned char*)c->argv[j]->ptr,
                           sdslen(c->argv[j]->ptr));
        switch(retval) {
            case 1:
                updated++;
                break;
            case -1:
                addReplySds(c, sdsnew(invalid_hll_err));
                return;
        }
    }

    // 转换编码（如果需要）
    hllSparseToDense(hdr);

    addReply(c, updated ? shared.cone : shared.czero);
}
```

### 2. PFCOUNT

```c
// PFCOUNT命令
void pfcountCommand(client *c) {
    robj *o;
    struct hllhdr *hdr;
    uint64_t card;
    int j, invalid = 0;

    // 单个HyperLogLog
    if (c->argc == 2) {
        o = lookupKeyRead(c->db, c->argv[1]);
        if (o == NULL) {
            addReply(c, shared.czero);
            return;
        }

        hdr = o->ptr;
        card = hllCount(hdr, &invalid);
        addReplyLongLong(c, card);
        return;
    }

    // 多个HyperLogLog合并
    uint8_t max[16384];
    memset(max, 0, sizeof(max));

    for (j = 1; j < c->argc; j++) {
        o = lookupKeyRead(c->db, c->argv[j]);
        if (o == NULL) continue;

        hdr = o->ptr;
        hllMerge(max, hdr);
    }

    card = hllCount(max, &invalid);
    addReplyLongLong(c, card);
}
```

### 3. PFMERGE

```c
// PFMERGE命令
void pfmergeCommand(client *c) {
    uint8_t max[16384];
    int j;
    robj *o;

    memset(max, 0, sizeof(max));

    // 合并所有HyperLogLog
    for (j = 1; j < c->argc; j++) {
        o = lookupKeyRead(c->db, c->argv[j]);
        if (o == NULL) continue;

        hllMerge(max, o->ptr);
    }

    // 创建目标HyperLogLog
    o = createHLLObject();
    hllDenseSet(o->ptr, max);

    dbReplace(c->db, c->argv[1], o);
    addReply(c, shared.ok);
}
```

## 性能分析

### 1. 内存占用

```python
# HyperLogLog内存占用
class HLLMemory:
    def analyze(self):
        return {
            'sparse_encoding': {
                'small_cardinality': '<1KB',
                'medium_cardinality': '1-12KB',
            },
            'dense_encoding': {
                'fixed_size': '12KB',
                'registers': '16384 * 6 bits = 12KB',
            },
        }
```

### 2. 误差率

```python
# HyperLogLog误差率
class HLLErrorRate:
    def calculate(self, m=16384):
        """计算误差率"""
        # 标准误差：1.04 / sqrt(m)
        std_error = 1.04 / (m ** 0.5)
        return std_error  # 约0.81%
```

### 3. 时间复杂度

```python
# HyperLogLog时间复杂度
class HLLComplexity:
    def analyze(self):
        return {
            'pfadd': 'O(1)',
            'pfcount': 'O(N)',  # N为寄存器数量（固定16384）
            'pfmerge': 'O(N * M)',  # M为HyperLogLog数量
        }
```

## 应用场景

### 1. UV统计

```python
# 使用HyperLogLog统计UV
class UVStatistics:
    def count_uv(self, user_ids):
        """统计独立访客数"""
        # 使用HyperLogLog
        hll = HyperLogLog()
        for user_id in user_ids:
            hll.add(user_id)
        return hll.count()
```

### 2. 去重统计

```python
# 使用HyperLogLog去重统计
class Deduplication:
    def count_unique(self, items):
        """统计唯一元素数量"""
        hll = HyperLogLog()
        for item in items:
            hll.add(item)
        return hll.count()
```

## 扩展阅读

- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)
- [集合intset实现](./03.01.04-集合intset实现.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **HyperLogLog论文** - "HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm"
