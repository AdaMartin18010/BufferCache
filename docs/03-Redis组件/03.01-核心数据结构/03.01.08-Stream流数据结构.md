# 03.01.08 Stream流数据结构

## 目录

- [03.01.08 Stream流数据结构](#030108-stream流数据结构)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. Stream原理](#2-stream原理)
    - [2.1 基本概念](#21-基本概念)
    - [2.2 消息结构](#22-消息结构)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. Radix树存储](#3-radix树存储)
    - [3.1 Radix树结构](#31-radix树结构)
    - [3.2 消息存储](#32-消息存储)
  - [4. 核心操作](#4-核心操作)
    - [4.1 XADD（添加消息）](#41-xadd添加消息)
    - [4.2 XREAD（读取消息）](#42-xread读取消息)
    - [4.3 XGROUP（消费者组管理）](#43-xgroup消费者组管理)
    - [4.4 XREADGROUP（消费者组读取）](#44-xreadgroup消费者组读取)
  - [5. 消费者组](#5-消费者组)
    - [5.1 消费者组原理](#51-消费者组原理)
    - [5.2 消息确认](#52-消息确认)
  - [6. 性能分析](#6-性能分析)
    - [6.1 时间复杂度分析](#61-时间复杂度分析)
    - [6.2 空间复杂度分析](#62-空间复杂度分析)
    - [6.3 内存占用分析](#63-内存占用分析)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**Stream**是Redis 5.0引入的流数据结构，类似于日志文件，支持消息队列、事件溯源等场景。Stream提供了类似Kafka的消息队列功能，是Redis实现消息队列的重要数据结构。

**历史发展**：

- **2018年**：Redis 5.0引入Stream
- **2019年**：Redis 5.1优化Stream实现
- **2020年代**：Stream成为Redis消息队列的标准实现

### 1.2 应用价值

Stream在Redis中具有重要价值：

1. **消息队列**：实现类似Kafka的消息队列功能
2. **事件溯源**：支持事件溯源模式
3. **实时数据处理**：支持实时数据流处理
4. **消费者组**：支持多个消费者组并发消费

## 2. Stream原理

### 2.1 基本概念

```c
// Stream基本概念
// 1. 类似日志文件的数据结构
// 2. 支持消息追加和消费
// 3. 支持消费者组（Consumer Group）
// 4. 支持消息ID和时间戳

// Stream结构
typedef struct stream {
    rax *rax;              // Radix树，存储消息
    uint64_t length;        // 消息数量
    streamID last_id;       // 最后一条消息ID
    rax *cgroups;           // 消费者组
} stream;

// 消息ID结构
typedef struct streamID {
    uint64_t ms;            // 毫秒时间戳
    uint64_t seq;           // 序列号
} streamID;
```

### 2.2 消息结构

```c
// Stream消息结构
typedef struct streamNACK {
    streamID delivery_time;  // 投递时间
    uint64_t delivery_count; // 投递次数
    streamConsumer *consumer; // 消费者
} streamNACK;

typedef struct streamCG {
    streamID last_id;       // 最后处理的ID
    rax *pel;               // Pending Entry List
    rax *consumers;         // 消费者列表
} streamCG;

typedef struct streamConsumer {
    mstime_t seen_time;     // 最后活跃时间
    rax *pel;               // Pending Entry List
    sds name;                // 消费者名称
} streamConsumer;
```

### 2.3 形式化定义

设Stream为$S$，消息集合为$M = \{m_1, m_2, ..., m_n\}$。

**Stream结构**：

$$Stream = (R, length, last\_id, cgroups)$$

其中：

- $R$：Radix树，存储消息
- $length = n$：消息数量
- $last\_id$：最后一条消息ID
- $cgroups$：消费者组集合

**消息ID**：

$$ID = (ms, seq)$$

其中：

- $ms$：毫秒时间戳
- $seq$：序列号

**消息路由**：

$$Route(m) = \arg\min_{id \in R} \{id | id \geq m.id\}$$

## 3. Radix树存储

### 3.1 Radix树结构

```c
// Radix树（压缩前缀树）
// 用于高效存储Stream消息

// Radix树节点
typedef struct raxNode {
    uint32_t iskey:1;       // 是否为key
    uint32_t isnull:1;     // 值是否为NULL
    uint32_t iscompr:1;    // 是否为压缩节点
    uint32_t size:29;      // 节点大小
    unsigned char data[];  // 数据
} raxNode;
```

### 3.2 消息存储

```c
// Stream消息存储
// Key: streamID (16字节)
// Value: 消息字段列表

// 消息追加
streamID streamAppendItem(stream *s, robj **argv, int numfields,
                         streamID *added_id, streamID *use_id) {
    // 1. 生成消息ID
    streamID id;
    if (use_id) {
        id = *use_id;
    } else {
        id.ms = mstime();
        id.seq = s->last_id.seq + 1;
    }

    // 2. 序列化消息
    unsigned char *lp = lpAppend(lp, (unsigned char*)&id, sizeof(id));
    for (int i = 0; i < numfields; i++) {
        lp = lpAppend(lp, argv[i]->ptr, sdslen(argv[i]->ptr));
    }

    // 3. 插入Radix树
    raxInsert(s->rax, (unsigned char*)&id, sizeof(id), lp, NULL);

    s->length++;
    s->last_id = id;

    return id;
}
```

## 4. 核心操作

### 4.1 XADD（添加消息）

```c
// XADD命令
void xaddCommand(client *c) {
    // 1. 解析参数
    robj *o = lookupKeyWriteOrReply(c, c->argv[1], shared.nokeyerr);
    if (o == NULL) {
        o = createStreamObject();
        dbAdd(c->db, c->argv[1], o);
    }

    stream *s = o->ptr;

    // 2. 解析消息ID
    streamID id;
    if (parseStreamIDOrReply(c, c->argv[2], &id, 0) != C_OK) {
        return;
    }

    // 3. 追加消息
    int field_count = (c->argc - 3) / 2;
    streamID added_id = streamAppendItem(s, c->argv + 3, field_count,
                                         &id, NULL);

    // 4. 通知消费者组
    if (s->cgroups) {
        streamPropagateXADD(c, c->argv[1], &added_id, c->argv + 3, field_count);
    }

    addReplyStreamID(c, &added_id);
}
```

### 4.2 XREAD（读取消息）

```c
// XREAD命令
void xreadCommand(client *c) {
    // 1. 解析参数
    int streams_count = (c->argc - 1) / 2;
    robj **keys = c->argv + 1;
    robj **ids = c->argv + 1 + streams_count;

    // 2. 读取消息
    addReplyArrayLen(c, streams_count);
    for (int i = 0; i < streams_count; i++) {
        robj *o = lookupKeyRead(c->db, keys[i]);
        if (o == NULL) continue;

        streamID id;
        parseStreamIDOrReply(c, ids[i], &id, 0);

        // 从指定ID开始读取
        streamIterator si;
        streamIteratorStart(&si, o->ptr, &id, NULL, 0);

        addReplyArrayLen(c, 2);
        addReplyBulk(c, keys[i]);

        int arraylen = 0;
        streamID last_id;
        while (streamIteratorGetID(&si, &last_id, NULL)) {
            arraylen++;
            streamIteratorNext(&si);
        }

        addReplyArrayLen(c, arraylen);
        // 输出消息...
    }
}
```

### 4.3 XGROUP（消费者组管理）

```c
// XGROUP命令
void xgroupCommand(client *c) {
    // CREATE子命令
    if (!strcasecmp(c->argv[1]->ptr, "CREATE")) {
        robj *o = lookupKeyWrite(c->db, c->argv[2]);
        if (o == NULL) {
            o = createStreamObject();
            dbAdd(c->db, c->argv[2], o);
        }

        stream *s = o->ptr;
        streamID id;
        parseStreamIDOrReply(c, c->argv[4], &id, 0);

        // 创建消费者组
        streamCG *cg = streamCreateCG(s, c->argv[3]->ptr, &id);
        addReply(c, shared.ok);
    }
    // 其他子命令...
}
```

### 4.4 XREADGROUP（消费者组读取）

```c
// XREADGROUP命令
void xreadgroupCommand(client *c) {
    // 1. 解析参数
    robj *groupname = c->argv[2];
    robj *consumername = c->argv[3];

    // 2. 获取消费者组
    robj *o = lookupKeyRead(c->db, c->argv[5]);
    stream *s = o->ptr;
    streamCG *cg = streamLookupCG(s, groupname->ptr);

    // 3. 获取或创建消费者
    streamConsumer *consumer = streamLookupConsumer(cg, consumername->ptr, 1);

    // 4. 读取消息
    streamID id;
    parseStreamIDOrReply(c, c->argv[6], &id, 0);

    // 从未消费的消息开始读取
    streamIterator si;
    streamIteratorStart(&si, s, &cg->last_id, NULL, 0);

    // 读取并标记为pending
    while (streamIteratorGetID(&si, &id, NULL)) {
        streamNACK *nack = streamCreateNACK(consumer);
        raxInsert(cg->pel, (unsigned char*)&id, sizeof(id), nack, NULL);
        // 输出消息...
    }
}
```

## 5. 消费者组

### 5.1 消费者组原理

```c
// 消费者组原理
// 1. 多个消费者共享消息
// 2. 每个消息只被一个消费者消费
// 3. 支持消息确认（ACK）
// 4. 支持消息重试（PEL）

// Pending Entry List
// 已投递但未确认的消息列表
```

### 5.2 消息确认

```c
// XACK命令
void xackCommand(client *c) {
    robj *o = lookupKeyRead(c->db, c->argv[1]);
    stream *s = o->ptr;
    streamCG *cg = streamLookupCG(s, c->argv[2]->ptr);

    int acked = 0;
    for (int j = 3; j < c->argc; j++) {
        streamID id;
        parseStreamIDOrReply(c, c->argv[j], &id, 0);

        // 从PEL中移除
        streamNACK *nack = raxFind(cg->pel, (unsigned char*)&id, sizeof(id));
        if (nack) {
            raxRemove(cg->pel, (unsigned char*)&id, sizeof(id), NULL);
            acked++;
        }
    }

    addReplyLongLong(c, acked);
}
```

## 6. 性能分析

### 6.1 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **XADD** | O(1) | Radix树插入 |
| **XREAD** | O(N) | N为读取的消息数 |
| **XREADGROUP** | O(N) | N为读取的消息数 |
| **XACK** | O(M) | M为确认的消息数 |

**定理 6.1**：Stream添加消息的时间复杂度为O(1)。

**证明**：

- Radix树插入：O(1)（平均情况）
- 更新last_id：O(1)
- 总时间复杂度：O(1)

### 6.2 空间复杂度分析

**空间开销**：

$$S_{stream} = S_{radix} + \sum_{i=1}^{n} S_{message_i} + \sum_{j=1}^{g} S_{cgroup_j}$$

其中：

- $S_{radix}$：Radix树开销（~50字节/消息）
- $S_{message_i}$：第i个消息大小（~100字节）
- $S_{cgroup_j}$：第j个消费者组大小（~200字节）

### 6.3 内存占用分析

**内存占用**：

| 组件 | 内存占用 | 说明 |
|------|----------|------|
| **每条消息** | ~100字节 | 消息数据 |
| **Radix树开销** | ~50字节/消息 | Radix树节点 |
| **消费者组** | ~200字节 | 每个消费者组 |
| **消费者** | ~100字节 | 每个消费者 |

## 7. 适用场景

### 7.1 优势场景

1. **消息队列**：实现类似Kafka的消息队列功能
2. **事件溯源**：支持事件溯源模式
3. **实时数据处理**：支持实时数据流处理
4. **消费者组**：支持多个消费者组并发消费

### 7.2 不适用场景

1. **大数据量**：消息数量非常大时，内存占用较大
2. **复杂查询**：需要复杂查询的场景（建议使用数据库）

## 8. 扩展阅读

- [列表quicklist实现](./03.01.03-列表quicklist实现.md)
- [压缩编码ziplist](./03.01.06-压缩编码ziplist.md)

## 9. 权威参考

### 9.1 官方文档

1. **Redis源码 - stream.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/stream.c>
   - 版本: Redis 5.0+
   - Stream的完整实现源码

2. **Redis官方文档 - Streams**
   - URL: <https://redis.io/docs/data-types/streams/>
   - 版本: Redis 7.0+
   - Stream的官方文档

### 9.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第11章：Stream（详细分析Stream实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第5章：Redis Stream（Stream应用）

### 9.3 在线资源

1. **Wikipedia - Radix Tree**
   - URL: <https://en.wikipedia.org/wiki/Radix_tree>
   - 提供Radix树的详细说明

2. **Apache Kafka Documentation**
   - URL: <https://kafka.apache.org/documentation/>
   - Kafka的官方文档，Stream的设计参考了Kafka
