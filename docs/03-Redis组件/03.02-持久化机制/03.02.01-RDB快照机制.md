# 03.02.01 RDB快照机制

## 目录

- [03.02.01 RDB快照机制](#030201-rdb快照机制)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 核心原理](#2-核心原理)
    - [2.1 快照机制](#21-快照机制)
    - [2.2 Copy-on-Write（COW）](#22-copy-on-writecow)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. RDB文件格式](#3-rdb文件格式)
    - [3.1 文件结构](#31-文件结构)
    - [3.2 键值对编码](#32-键值对编码)
  - [4. 触发机制](#4-触发机制)
    - [4.1 手动触发](#41-手动触发)
    - [4.2 自动触发](#42-自动触发)
  - [5. 性能分析](#5-性能分析)
    - [5.1 时间复杂度分析](#51-时间复杂度分析)
    - [5.2 空间复杂度分析](#52-空间复杂度分析)
    - [5.3 COW性能分析](#53-cow性能分析)
    - [COW成本](#cow成本)
  - [6. 适用场景](#6-适用场景)
    - [6.1 优势场景](#61-优势场景)
    - [6.2 不适用场景](#62-不适用场景)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 经典书籍](#82-经典书籍)
    - [8.3 在线资源](#83-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**RDB（Redis Database）**是Redis的持久化机制之一，通过创建数据快照的方式将内存中的数据保存到磁盘。

**历史发展**：

- **2009年**：Redis 1.0引入RDB快照机制
- **2010年**：Redis 2.0优化RDB性能，引入COW机制
- **2012年**：Redis 2.6改进RDB文件格式
- **2015年**：Redis 3.2优化RDB压缩算法
- **2020年代**：RDB与AOF混合持久化成为标准配置

### 1.2 应用价值

RDB在Redis中具有重要价值：

1. **数据备份**：定期创建数据快照，用于备份和恢复
2. **快速恢复**：RDB文件加载速度快，适合灾难恢复
3. **主从复制**：主节点生成RDB发送给从节点
4. **数据迁移**：通过RDB文件在不同Redis实例间迁移数据

## 2. 核心原理

### 2.1 快照机制

RDB通过**fork子进程**的方式创建数据快照，子进程负责将内存数据写入RDB文件，主进程继续处理请求。

**快照一致性保证**：

**定理 2.1**：RDB快照保证数据的一致性。

**证明**：

- fork()创建子进程时，父子进程共享内存页（只读）
- 子进程遍历数据库时，看到的是fork时刻的数据快照
- 主进程的后续修改不影响子进程的快照
- 因此RDB文件包含fork时刻的一致数据快照

### 2.2 Copy-on-Write（COW）

```c
// fork()创建子进程时，父子进程共享内存页
pid_t pid = fork();

if (pid == 0) {
    // 子进程：遍历数据库，写入RDB文件
    rdbSave("dump.rdb");
    exit(0);
} else {
    // 主进程：继续处理请求
    // 修改数据时触发COW，复制页面
}
```

**COW机制**：

- fork()时：父子进程共享内存页（只读）
- 写入时：触发页错误，复制修改的页面
- 优势：减少内存拷贝，提升性能

**COW性能分析**：

**定理 2.2**：COW机制的内存开销为O(M)，其中M为修改的页面数。

**证明**：

- fork()时：O(1)（仅复制页表）
- 修改页面时：O(1)（复制单个页面）
- 总开销：O(M)，其中M为修改的页面数
- 通常M << N（N为总页面数），因此COW大幅减少内存开销

### 2.3 形式化定义

设Redis数据库状态为$D = \{k_1: v_1, k_2: v_2, ..., k_n: v_n\}$，RDB快照过程：

1. **fork时刻**：$t_0$，数据库状态$D(t_0)$
2. **子进程**：遍历$D(t_0)$，写入RDB文件
3. **主进程**：继续处理请求，状态变为$D(t)$，$t > t_0$
4. **RDB文件**：包含$D(t_0)$的完整快照

## 3. RDB文件格式

### 3.1 文件结构

```
+------------------+
| REDIS            | 5字节：魔数
+------------------+
| RDB-VERSION      | 4字节：版本号（如"0006"）
+------------------+
| AUX              | 辅助字段（可选）
+------------------+
| SELECTDB         | 数据库选择
+------------------+
| KEY-VALUE-PAIRS  | 键值对数据
+------------------+
| EOF              | 结束标记
+------------------+
| CHECK-SUM        | 8字节：CRC64校验和
+------------------+
```

### 3.2 键值对编码

```c
// 字符串编码
+--------+--------+--------+
| TYPE   | LEN    | DATA   |
+--------+--------+--------+
| 1 byte | varint | N bytes|

// 列表编码
+--------+--------+--------+--------+
| TYPE   | LEN    | ELEM1  | ELEM2  |
+--------+--------+--------+--------+
| 1 byte | varint | ...    | ...    |
```

## 4. 触发机制

### 4.1 手动触发

```bash
# SAVE命令：阻塞主线程
127.0.0.1:6379> SAVE
OK

# BGSAVE命令：后台执行
127.0.0.1:6379> BGSAVE
Background saving started by pid 12345
```

### 4.2 自动触发

```c
// Redis配置
struct saveparam {
    time_t seconds;   // 时间窗口
    int changes;      // 修改次数阈值
};

// 周期性检查
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // 检查save条件
    for (j = 0; j < server.saveparamslen; j++) {
        struct saveparam *sp = server.saveparams+j;

        if (server.dirty >= sp->changes &&
            server.unixtime-server.lastsave > sp->seconds)
        {
            // 触发BGSAVE
            rdbSaveBackground(server.rdb_filename);
            break;
        }
    }
}
```

**默认配置**：

```conf
save 900 1      # 900秒内至少1次修改
save 300 10     # 300秒内至少10次修改
save 60 10000   # 60秒内至少10000次修改
```

## 5. 性能分析

### 5.1 时间复杂度分析

**RDB生成时间复杂度**：

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| **fork()** | O(1) | 仅复制页表 |
| **遍历数据库** | O(N) | N为键值对数量 |
| **写入文件** | O(N) | N为数据大小 |
| **总时间** | O(N) | N为数据大小 |

**定理 5.1**：RDB生成的时间复杂度为O(N)，其中N为数据大小。

**证明**：

- fork()：O(1)（仅复制页表）
- 遍历数据库：O(K)，K为键值对数量
- 写入文件：O(S)，S为数据大小
- 总时间：$T = O(1) + O(K) + O(S) = O(N)$，其中$N = \max(K, S)$

### 5.2 空间复杂度分析

**RDB文件大小**：

$$S_{RDB} = S_{header} + \sum_{i=1}^{n} S_{key_i} + S_{value_i} + S_{overhead}$$

其中：

- $S_{header}$：文件头大小（约20字节）
- $S_{key_i}$：第i个键的大小
- $S_{value_i}$：第i个值的大小
- $S_{overhead}$：编码开销（约10%）

**压缩后大小**：

$$S_{compressed} = S_{RDB} \times \text{compression\_ratio}$$

通常压缩比：0.3-0.7（取决于数据类型）

### 5.3 COW性能分析

**fork()性能**

```c
// fork()耗时分析
fork_time = page_table_copy_time + COW_setup_time

// 页表拷贝
page_table_size = memory_size / page_size * 8 bytes
page_table_copy_time = page_table_size / memory_bandwidth

// 示例：16GB内存
page_table_size = 16GB / 4KB * 8 = 32MB
page_table_copy_time = 32MB / 20GB/s ≈ 1.6ms

// 实际观测：50-100ms（包含其他开销）
```

### COW成本

```c
// COW页面复制成本
COW_cost_per_page = page_fault_time + page_copy_time
                   = 100ns + 4KB/20GB/s
                   = 100ns + 200ns
                   = 300ns/page

// BGSAVE期间10万次写入
total_COW_cost = 100000 * 300ns = 30ms
```

## 6. 适用场景

### 6.1 优势场景

1. **数据备份**：定期创建数据快照，用于备份和恢复
2. **快速恢复**：RDB文件加载速度快，适合灾难恢复
3. **主从复制**：主节点生成RDB发送给从节点
4. **数据迁移**：通过RDB文件在不同Redis实例间迁移数据

### 6.2 不适用场景

1. **实时性要求高**：需要秒级持久化的场景
2. **数据丢失敏感**：无法接受两次快照间数据丢失的场景
3. **大内存实例**：fork()耗时较长的场景

## 7. 扩展阅读

- [AOF日志机制](./03.02.02-AOF日志机制.md)
- [混合持久化](./03.02.03-混合持久化.md)
- [RDB持久化一致性证明](../../00-项目总览/证明图网-核心机制证明.md#2-rdb持久化一致性证明)

## 8. 权威参考

### 8.1 官方文档

1. **Redis源码 - rdb.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/rdb.c>
   - 版本: Redis 1.0+
   - RDB的完整实现源码

2. **Redis官方文档 - Persistence**
   - URL: <https://redis.io/docs/manual/persistence/>
   - 版本: Redis 7.0+
   - Redis持久化机制的官方文档

### 8.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第10章：RDB持久化（详细分析RDB实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第3章：持久化（RDB和AOF详解）

### 8.3 在线资源

1. **Wikipedia - Snapshot (computer storage)**
   - URL: <https://en.wikipedia.org/wiki/Snapshot_(computer_storage)>
   - 提供快照机制的通用说明

2. **Linux man page - fork(2)**
   - URL: <https://man7.org/linux/man-pages/man2/fork.2.html>
   - fork()系统调用的详细说明
