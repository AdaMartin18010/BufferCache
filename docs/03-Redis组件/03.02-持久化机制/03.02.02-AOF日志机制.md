# 03.02.02 AOF日志机制

## 概述

AOF（Append Only File，追加文件）是Redis的另一种持久化机制，通过记录每个写命令的方式实现数据持久化，相比RDB提供更好的数据安全性。

## 核心原理

### 命令追加

AOF以文本格式记录每个写命令，追加到AOF文件末尾：

```
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```

### 文件重写

定期重写AOF文件，去除冗余命令，压缩文件大小。

## AOF文件格式

### RESP协议格式

AOF文件使用Redis的RESP（Redis Serialization Protocol）协议：

```
*<参数数量>\r\n
$<参数1长度>\r\n
<参数1>\r\n
$<参数2长度>\r\n
<参数2>\r\n
...
```

### 示例

```bash
# SET命令
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n

# LPUSH命令
*3\r\n$5\r\nLPUSH\r\n$4\r\nlist\r\n$3\r\nval\r\n

# HSET命令
*4\r\n$4\r\nHSET\r\n$4\r\nhash\r\n$3\r\nfld\r\n$3\r\nval\r\n
```

## 同步策略

### 三级同步策略

```c
// AOF同步策略
#define AOF_FSYNC_NO 0      // 不主动fsync
#define AOF_FSYNC_ALWAYS 1   // 每个命令都fsync
#define AOF_FSYNC_EVERYSEC 2 // 每秒fsync一次（默认）

// 写入AOF缓冲区
void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) return;

    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        // always策略：每个命令都fsync
        latencyStartMonitor(latency);
        nwritten = aofWrite(server.aof_buf, sdslen(server.aof_buf));
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded("aof-write", latency);

        if (fsync(server.aof_fd) == -1) {
            // fsync失败处理
        }
    } else if (server.aof_fsync == AOF_FSYNC_EVERYSEC) {
        // everysec策略：每秒fsync一次
        if (server.aof_flush_postponed_start) {
            // 延迟写入
            return;
        }

        if (aeCreateFileEvent(server.el, server.aof_fd,
                             AE_WRITABLE, flushAppendOnlyFile, NULL) == AE_ERR) {
            // 创建文件事件失败
            return;
        }

        server.aof_flush_postponed_start = server.unixtime;
    }

    // no策略：由OS控制fsync
    nwritten = aofWrite(server.aof_buf, sdslen(server.aof_buf));
}
```

### 策略对比

| 策略 | 数据安全性 | 性能 | 适用场景 |
|------|------------|------|----------|
| **always** | 最高（每条命令fsync） | 最低（TPS < 1000） | 金融支付 |
| **everysec** | 较高（1秒内可能丢失） | 高（TPS ≈ 5万） | 通用场景（默认） |
| **no** | 较低（依赖OS，可能丢失30秒） | 最高 | 高性能场景 |

## AOF重写

### 重写目的

1. **压缩文件**：去除冗余命令
2. **优化结构**：使用更高效的命令
3. **减少恢复时间**：文件更小，恢复更快

### 重写触发条件

```c
// 检查是否需要重写AOF
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // ...

    // 检查AOF重写条件
    if (server.aof_state == AOF_ON &&
        server.rdb_child_pid == -1 &&
        server.aof_child_pid == -1 &&
        server.aof_rewrite_perc &&
        server.aof_current_size > server.aof_rewrite_min_size) {

        long long base = server.aof_rewrite_base_size ?
                         server.aof_rewrite_base_size : 1;
        long long growth = (server.aof_current_size * 100 / base) - 100;

        if (growth >= server.aof_rewrite_perc) {
            // 触发AOF重写
            rewriteAppendOnlyFileBackground();
        }
    }
}
```

**默认条件**：
- `auto-aof-rewrite-min-size 64mb`：最小文件大小
- `auto-aof-rewrite-percentage 100`：增长100%触发

### 重写流程

```c
// 后台重写AOF
int rewriteAppendOnlyFileBackground(void) {
    pid_t childpid;
    long long start;

    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
        return C_ERR;
    }

    if (aofCreatePipes() != C_OK) {
        return C_ERR;
    }

    start = ustime();
    if ((childpid = fork()) == 0) {
        // 子进程：执行重写
        char tmpfile[256];

        snprintf(tmpfile, 256, "temp-rewriteaof-%d.aof", (int)getpid());
        rewriteAppendOnlyFile(tmpfile);

        exitFromChild(0);
    } else {
        // 父进程：继续处理请求
        server.aof_child_pid = childpid;
        server.aof_rewrite_scheduled = 0;
        server.aof_rewrite_time_start = time(NULL);

        // 关闭子进程继承的文件描述符
        closeChildInfoPipe();
        return C_OK;
    }

    return C_ERR;
}
```

### 重写实现

```c
// 重写AOF文件
int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp;
    char tmpfile[256];
    long long now = mstime();
    int j;

    // 创建临时文件
    snprintf(tmpfile, 256, "temp-rewriteaof-bg-%d.aof", (int)getpid());
    fp = fopen(tmpfile, "w");

    server.aof_child_diff = sdsempty();
    initrio(&aof, fp);

    // 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
        redisDb *db = server.db + j;
        dictIterator *di = dictGetSafeIterator(db->dict);

        if (rioWrite(&aof, selectcmd, sizeof(selectcmd)-1) == 0) goto werr;

        // 遍历所有key
        while ((de = dictNext(di)) != NULL) {
            sds key = dictGetKey(de);
            robj *o = dictGetVal(de);
            long long expiretime = getExpire(db, key);

            // 写入过期时间
            if (expiretime != -1) {
                char cmd[] = "*3\r\n$6\r\nPEXPIREAT\r\n";
                if (rioWrite(&aof, cmd, sizeof(cmd)-1) == 0) goto werr;
                if (rioWriteBulkObject(&aof, key) == 0) goto werr;
                if (rioWriteBulkLongLong(&aof, expiretime) == 0) goto werr;
            }

            // 写入key-value
            if (rioWriteBulkObject(&aof, key) == 0) goto werr;
            if (rioWriteBulkObject(&aof, o) == 0) goto werr;
        }
        dictReleaseIterator(di);
    }

    // 同步到磁盘
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    // 重命名临时文件
    if (rename(tmpfile, filename) == -1) {
        unlink(tmpfile);
        return C_ERR;
    }

    return C_OK;
}
```

## 重写缓冲区

### 设计目的

在AOF重写期间，主进程继续处理请求，需要将新命令写入重写缓冲区，重写完成后合并。

### 实现机制

```c
// 写入重写缓冲区
void feedAppendOnlyFile(struct redisCommand *cmd, int dictid,
                       robj **argv, int argc) {
    sds buf = sdsempty();
    robj *tmpargv[3];

    // 如果正在重写，写入重写缓冲区
    if (server.aof_child_pid != -1) {
        aofRewriteBufferAppend((unsigned char*)buf, sdslen(buf));
        return;
    }

    // 否则写入AOF缓冲区
    if (server.aof_buf) {
        server.aof_buf = sdscatlen(server.aof_buf, buf, sdslen(buf));
    }
}

// 合并重写缓冲区和AOF文件
void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    // ...

    // 读取重写缓冲区内容
    aofReadDiffFromParent();

    // 合并到AOF文件
    snprintf(tmpfile, 256, "temp-rewriteaof-bg-%d.aof",
             (int)server.aof_child_pid);
    if (rename(tmpfile, server.aof_filename) == -1) {
        // 重命名失败处理
    }

    // 更新AOF状态
    server.aof_state = AOF_ON;
    server.aof_lastfsync = server.unixtime;
    server.aof_fd = open(server.aof_filename, O_WRONLY|O_APPEND);
}
```

## Multi Part AOF（Redis 7.0+）

### 设计目的

将AOF文件拆分为多个部分，提升管理效率和恢复速度。

### 文件结构

```
appendonlydir/
├── appendonly.aof.1.base.rdb    # BASE文件（RDB格式）
├── appendonly.aof.1.incr.aof    # INCR文件（增量AOF）
├── appendonly.aof.2.base.rdb    # 历史BASE文件
└── appendonly.aof.manifest      # 清单文件
```

### 清单文件格式

```json
{
  "version": 1,
  "base_aof_info": {
    "file_name": "appendonly.aof.1.base.rdb",
    "file_seq": 1
  },
  "incr_aof_list": [
    {
      "file_name": "appendonly.aof.1.incr.aof",
      "file_seq": 1
    }
  ],
  "history_aof_list": []
}
```

## 数据恢复

### 恢复流程

```c
// 加载AOF文件
int loadAppendOnlyFile(char *filename) {
    struct client *fakeClient;
    FILE *fp;
    struct redis_stat sb;
    int old_aof_state = server.aof_state;
    long loops = 0;

    // 打开AOF文件
    fp = fopen(filename, "r");

    server.aof_state = AOF_OFF;
    fakeClient = createFakeClient();

    // 逐行读取并执行命令
    while (1) {
        int argc, j;
        unsigned long len;
        robj **argv;
        char buf[1024];

        // 读取命令
        if (fgets(buf, sizeof(buf), fp) == NULL) {
            if (feof(fp)) {
                break;
            } else {
                goto readerr;
            }
        }

        // 解析命令
        if (buf[0] != '*') goto fmterr;
        if (buf[1] == '\0') goto readerr;
        argc = atoi(buf+1);

        argv = zmalloc(sizeof(robj*)*argc);
        // ... 解析参数

        // 执行命令
        fakeClient->argc = argc;
        fakeClient->argv = argv;
        cmd = lookupCommand(argv[0]->ptr);
        cmd->proc(fakeClient);

        // 清理
        for (j = 0; j < argc; j++) {
            decrRefCount(argv[j]);
        }
        zfree(argv);
    }

    fclose(fp);
    freeFakeClient(fakeClient);
    server.aof_state = old_aof_state;

    return C_OK;
}
```

## 性能优化

### 1. 批量写入

```c
// 批量写入AOF缓冲区
void aofWrite(ssize_t nwritten) {
    // 使用writev批量写入
    struct iovec iov[2];
    iov[0].iov_base = server.aof_buf;
    iov[0].iov_len = sdslen(server.aof_buf);

    writev(server.aof_fd, iov, 1);
}
```

### 2. 异步fsync

```c
// Redis 6.0+：使用后台线程fsync
void flushAppendOnlyFile(int force) {
    // ...

    if (server.aof_fsync == AOF_FSYNC_EVERYSEC) {
        // 提交到后台线程
        bioCreateBackgroundJob(BIO_AOF_FSYNC, NULL, NULL, NULL);
    }
}
```

## 优缺点分析

### 优势

| 特性 | 说明 |
|------|------|
| **数据安全** | 每条命令都记录，数据丢失风险低 |
| **可读性** | 文本格式，易于理解和调试 |
| **可恢复性** | 可以手动编辑AOF文件修复数据 |

### 劣势

| 特性 | 说明 |
|------|------|
| **文件大小** | 文件比RDB大，恢复慢 |
| **性能影响** | fsync影响写入性能 |
| **复杂度** | 重写机制复杂 |

## 配置建议

### 生产环境配置

```conf
# 启用AOF
appendonly yes

# 同步策略：每秒fsync
appendfsync everysec

# 重写条件
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 重写时不同步（提升性能）
no-appendfsync-on-rewrite yes
```

## 扩展阅读

- [RDB快照机制](./03.02.01-RDB快照机制.md)
- [混合持久化](./03.02.03-混合持久化.md)
- [持久化机制对比](../../00-项目总览/多维概念矩阵对比.md#4-redis持久化机制对比矩阵)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/persistence/>
