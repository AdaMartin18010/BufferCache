# 03.02.02 AOF日志机制

## 目录

- [03.02.02 AOF日志机制](#030202-aof日志机制)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 核心原理](#2-核心原理)
    - [2.1 命令追加](#21-命令追加)
    - [2.2 文件重写](#22-文件重写)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. AOF文件格式](#3-aof文件格式)
    - [3.1 RESP协议格式](#31-resp协议格式)
    - [3.2 命令编码](#32-命令编码)
  - [4. 同步策略](#4-同步策略)
    - [4.1 三级同步策略](#41-三级同步策略)
    - [4.2 性能分析](#42-性能分析)
  - [5. AOF重写机制](#5-aof重写机制)
    - [5.1 重写原理](#51-重写原理)
    - [5.2 重写流程](#52-重写流程)
  - [重写缓冲区](#重写缓冲区)
    - [设计目的](#设计目的)
    - [实现机制](#实现机制)
    - [5.5 Multi Part AOF（Redis 7.0+）](#55-multi-part-aofredis-70)
    - [清单文件格式](#清单文件格式)
  - [6. 性能优化](#6-性能优化)
    - [6.1 批量写入](#61-批量写入)
    - [6.2 异步fsync](#62-异步fsync)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 程序设计分析](#8-程序设计分析)
    - [8.1 设计模式应用](#81-设计模式应用)
    - [8.2 代码结构分析](#82-代码结构分析)
    - [8.3 设计权衡](#83-设计权衡)
    - [8.4 可扩展性分析](#84-可扩展性分析)
  - [9. 扩展阅读](#9-扩展阅读)
  - [10. 权威参考](#10-权威参考)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 经典书籍](#102-经典书籍)
    - [10.3 在线资源](#103-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**AOF（Append Only File，追加文件）**是Redis的另一种持久化机制，通过记录每个写命令的方式实现数据持久化，相比RDB提供更好的数据安全性。

**版本信息**：
- **适用版本**：Redis 1.0+
- **文档基于版本**：Redis 7.2
- **最后更新**：2025-01

**历史发展**：

- **2010年**：Redis 2.0引入AOF持久化机制
- **2012年**：Redis 2.4优化AOF重写机制
- **2015年**：Redis 3.2改进AOF同步策略
- **2020年代**：AOF与RDB混合持久化成为标准配置

### 1.2 应用价值

AOF在Redis中具有重要价值：

1. **数据安全性**：记录每个写命令，数据丢失风险低
2. **可恢复性**：AOF文件可读，便于调试和恢复
3. **实时性**：支持秒级同步，数据实时性高
4. **灵活性**：支持多种同步策略，平衡性能和安全

## 2. 核心原理

### 2.1 命令追加

AOF以文本格式记录每个写命令，追加到AOF文件末尾：

```
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```

**命令追加过程**：

1. **命令执行**：Redis执行写命令
2. **命令序列化**：将命令序列化为RESP格式
3. **追加到缓冲区**：写入AOF缓冲区
4. **同步到磁盘**：根据同步策略同步到AOF文件

### 2.2 文件重写

定期重写AOF文件，去除冗余命令，压缩文件大小。

**重写目的**：

- **压缩文件**：去除冗余命令，减少文件大小
- **提升性能**：文件越小，加载越快
- **优化结构**：将多个命令合并为单个命令

### 2.3 形式化定义

设Redis命令序列为$C = \{c_1, c_2, ..., c_n\}$，AOF持久化过程：

1. **命令追加**：对于每个写命令$c_i$，序列化为RESP格式$s_i$，追加到AOF缓冲区
2. **缓冲区刷新**：根据同步策略，将缓冲区内容刷新到AOF文件
3. **文件重写**：定期重写AOF文件，生成压缩版本

**AOF文件内容**：

$$AOF = \{s_1, s_2, ..., s_n\}$$

其中$s_i$为命令$c_i$的RESP序列化结果。

## 3. AOF文件格式

### 3.1 RESP协议格式

AOF文件使用Redis的RESP（Redis Serialization Protocol）协议：

```
*<参数数量>\r\n
$<参数1长度>\r\n
<参数1>\r\n
$<参数2长度>\r\n
<参数2>\r\n
...
```

### 3.2 命令编码

**命令编码规则**：

对于命令$C(arg_1, arg_2, ..., arg_n)$，RESP编码为：

$$RESP(C) = *n\r\n$|arg_1|\r\narg_1\r\n$|arg_2|\r\narg_2\r\n...$$

其中：

- $*n$：参数数量
- $|arg_i|$：第i个参数的长度
- $arg_i$：第i个参数的内容

**示例**

```bash
# SET命令
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n

# LPUSH命令
*3\r\n$5\r\nLPUSH\r\n$4\r\nlist\r\n$3\r\nval\r\n

# HSET命令
*4\r\n$4\r\nHSET\r\n$4\r\nhash\r\n$3\r\nfld\r\n$3\r\nval\r\n
```

## 4. 同步策略

### 4.1 三级同步策略

```c
// AOF同步策略
#define AOF_FSYNC_NO 0      // 不主动fsync
#define AOF_FSYNC_ALWAYS 1   // 每个命令都fsync
#define AOF_FSYNC_EVERYSEC 2 // 每秒fsync一次（默认）

// 写入AOF缓冲区
void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) return;

    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        // always策略：每个命令都fsync
        latencyStartMonitor(latency);
        nwritten = aofWrite(server.aof_buf, sdslen(server.aof_buf));
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded("aof-write", latency);

        if (fsync(server.aof_fd) == -1) {
            // fsync失败处理
        }
    } else if (server.aof_fsync == AOF_FSYNC_EVERYSEC) {
        // everysec策略：每秒fsync一次
        if (server.aof_flush_postponed_start) {
            // 延迟写入
            return;
        }

        if (aeCreateFileEvent(server.el, server.aof_fd,
                             AE_WRITABLE, flushAppendOnlyFile, NULL) == AE_ERR) {
            // 创建文件事件失败
            return;
        }

        server.aof_flush_postponed_start = server.unixtime;
    }

    // no策略：由OS控制fsync
    nwritten = aofWrite(server.aof_buf, sdslen(server.aof_buf));
}
```

### 4.2 性能分析

**同步策略性能对比**：

| 策略 | 数据安全性 | 性能 | 适用场景 |
|------|------------|------|----------|
| **always** | 最高（每条命令fsync） | 最低（TPS < 1000） | 金融支付 |
| **everysec** | 较高（1秒内可能丢失） | 高（TPS ≈ 5万） | 通用场景（默认） |
| **no** | 较低（依赖OS，可能丢失30秒） | 最高 | 高性能场景 |

**性能分析**：

**定理 4.1**：AOF同步策略的时间复杂度。

**证明**：

- **always策略**：每个命令都需要fsync，时间复杂度O(1)但常数大（~10ms）
- **everysec策略**：每秒fsync一次，摊销时间复杂度O(1)
- **no策略**：由OS控制，时间复杂度O(1)

**数据丢失风险**：

- **always策略**：$P(\text{丢失}) = 0$（每条命令都fsync）
- **everysec策略**：$P(\text{丢失}) = P(\text{崩溃发生在1秒内}) \approx 0.001$
- **no策略**：$P(\text{丢失}) = P(\text{崩溃发生在OS刷新前}) \approx 0.01-0.1$

## 5. AOF重写机制

### 5.1 重写原理

**重写目的**：

1. **压缩文件**：去除冗余命令
2. **优化结构**：使用更高效的命令
3. **减少恢复时间**：文件更小，恢复更快

**重写原理**：

**定理 5.1**：AOF重写可以将文件大小压缩到原来的10-50%。

**证明**：

- 原始AOF：$S_{original} = \sum_{i=1}^{n} |RESP(c_i)|$
- 重写后AOF：$S_{rewrite} = \sum_{j=1}^{m} |RESP(c'_j)|$，其中$m << n$
- 压缩比：$\frac{S_{rewrite}}{S_{original}} = \frac{m}{n} \times \frac{|RESP(c')|}{|RESP(c)|} \approx 0.1-0.5$

### 5.2 重写流程

**重写触发条件**

```c
// 检查是否需要重写AOF
int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    // ...

    // 检查AOF重写条件
    if (server.aof_state == AOF_ON &&
        server.rdb_child_pid == -1 &&
        server.aof_child_pid == -1 &&
        server.aof_rewrite_perc &&
        server.aof_current_size > server.aof_rewrite_min_size) {

        long long base = server.aof_rewrite_base_size ?
                         server.aof_rewrite_base_size : 1;
        long long growth = (server.aof_current_size * 100 / base) - 100;

        if (growth >= server.aof_rewrite_perc) {
            // 触发AOF重写
            rewriteAppendOnlyFileBackground();
        }
    }
}
```

**默认条件**：

- `auto-aof-rewrite-min-size 64mb`：最小文件大小
- `auto-aof-rewrite-percentage 100`：增长100%触发

**重写触发条件**
    pid_t childpid;
    long long start;

    if (server.aof_child_pid != -1 || server.rdb_child_pid != -1) {
        return C_ERR;
    }

    if (aofCreatePipes() != C_OK) {
        return C_ERR;
    }

    start = ustime();
    if ((childpid = fork()) == 0) {
        // 子进程：执行重写
        char tmpfile[256];

        snprintf(tmpfile, 256, "temp-rewriteaof-%d.aof", (int)getpid());
        rewriteAppendOnlyFile(tmpfile);

        exitFromChild(0);
    } else {
        // 父进程：继续处理请求
        server.aof_child_pid = childpid;
        server.aof_rewrite_scheduled = 0;
        server.aof_rewrite_time_start = time(NULL);

        // 关闭子进程继承的文件描述符
        closeChildInfoPipe();
        return C_OK;
    }

    return C_ERR;
}

```

### 5.3 性能分析

**重写性能分析**：

**定理 5.2**：AOF重写的时间复杂度为O(N)，其中N为键值对数量。

**证明**：
- 遍历所有数据库：O(D)，D为数据库数量
- 遍历每个键值对：O(N)，N为键值对数量
- 序列化命令：O(1)每个键值对
- 写入文件：O(S)，S为数据大小
- 总时间：$T = O(D) + O(N) + O(S) = O(N)$

**重写实现**

```c
// 重写AOF文件
int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp;
    char tmpfile[256];
    long long now = mstime();
    int j;

    // 创建临时文件
    snprintf(tmpfile, 256, "temp-rewriteaof-bg-%d.aof", (int)getpid());
    fp = fopen(tmpfile, "w");

    server.aof_child_diff = sdsempty();
    initrio(&aof, fp);

    // 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        char selectcmd[] = "*2\r\n$6\r\nSELECT\r\n";
        redisDb *db = server.db + j;
        dictIterator *di = dictGetSafeIterator(db->dict);

        if (rioWrite(&aof, selectcmd, sizeof(selectcmd)-1) == 0) goto werr;

        // 遍历所有key
        while ((de = dictNext(di)) != NULL) {
            sds key = dictGetKey(de);
            robj *o = dictGetVal(de);
            long long expiretime = getExpire(db, key);

            // 写入过期时间
            if (expiretime != -1) {
                char cmd[] = "*3\r\n$6\r\nPEXPIREAT\r\n";
                if (rioWrite(&aof, cmd, sizeof(cmd)-1) == 0) goto werr;
                if (rioWriteBulkObject(&aof, key) == 0) goto werr;
                if (rioWriteBulkLongLong(&aof, expiretime) == 0) goto werr;
            }

            // 写入key-value
            if (rioWriteBulkObject(&aof, key) == 0) goto werr;
            if (rioWriteBulkObject(&aof, o) == 0) goto werr;
        }
        dictReleaseIterator(di);
    }

    // 同步到磁盘
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    // 重命名临时文件
    if (rename(tmpfile, filename) == -1) {
        unlink(tmpfile);
        return C_ERR;
    }

    return C_OK;
}
```

## 重写缓冲区

### 设计目的

在AOF重写期间，主进程继续处理请求，需要将新命令写入重写缓冲区，重写完成后合并。

### 实现机制

```c
// 写入重写缓冲区
void feedAppendOnlyFile(struct redisCommand *cmd, int dictid,
                       robj **argv, int argc) {
    sds buf = sdsempty();
    robj *tmpargv[3];

    // 如果正在重写，写入重写缓冲区
    if (server.aof_child_pid != -1) {
        aofRewriteBufferAppend((unsigned char*)buf, sdslen(buf));
        return;
    }

    // 否则写入AOF缓冲区
    if (server.aof_buf) {
        server.aof_buf = sdscatlen(server.aof_buf, buf, sdslen(buf));
    }
}

// 合并重写缓冲区和AOF文件
void backgroundRewriteDoneHandler(int exitcode, int bysignal) {
    // ...

    // 读取重写缓冲区内容
    aofReadDiffFromParent();

    // 合并到AOF文件
    snprintf(tmpfile, 256, "temp-rewriteaof-bg-%d.aof",
             (int)server.aof_child_pid);
    if (rename(tmpfile, server.aof_filename) == -1) {
        // 重命名失败处理
    }

    // 更新AOF状态
    server.aof_state = AOF_ON;
    server.aof_lastfsync = server.unixtime;
    server.aof_fd = open(server.aof_filename, O_WRONLY|O_APPEND);
}
```

### 5.5 Multi Part AOF（Redis 7.0+）

**设计目的**：将AOF文件拆分为多个部分，提升管理效率和恢复速度。

**文件结构**

```
appendonlydir/
├── appendonly.aof.1.base.rdb    # BASE文件（RDB格式）
├── appendonly.aof.1.incr.aof    # INCR文件（增量AOF）
├── appendonly.aof.2.base.rdb    # 历史BASE文件
└── appendonly.aof.manifest      # 清单文件
```

### 清单文件格式

```json
{
  "version": 1,
  "base_aof_info": {
    "file_name": "appendonly.aof.1.base.rdb",
    "file_seq": 1
  },
  "incr_aof_list": [
    {
      "file_name": "appendonly.aof.1.incr.aof",
      "file_seq": 1
    }
  ],
  "history_aof_list": []
}
```

## 6. 性能优化

### 6.1 批量写入

### 6.2 异步fsync

## 7. 适用场景

### 7.1 优势场景

1. **数据安全性要求高**：需要记录每个写命令
2. **可恢复性要求高**：需要可读的日志文件
3. **实时性要求高**：需要秒级同步

### 7.2 不适用场景

1. **性能要求极高**：无法接受fsync性能开销
2. **文件大小敏感**：AOF文件比RDB大

## 8. 程序设计分析

### 8.1 设计模式应用

**使用的设计模式**：

1. **模板方法模式**：定义AOF追加的基本流程（命令执行、格式化、追加）
2. **策略模式**：不同同步策略（always、everysec、no）
3. **观察者模式**：命令执行事件通知AOF追加

**策略模式实现**：

```c
// AOF同步策略接口
typedef enum {
    AOF_FSYNC_NO,      // 不主动fsync
    AOF_FSYNC_ALWAYS,  // 每次写入都fsync
    AOF_FSYNC_EVERYSEC // 每秒fsync一次
} aof_fsync_type;

// 不同同步策略
void aof_fsync(aof_fsync_type type) {
    switch (type) {
        case AOF_FSYNC_ALWAYS:
            fsync(aof_fd);
            break;
        case AOF_FSYNC_EVERYSEC:
            // 异步fsync
            break;
        // ...
    }
}
```

### 8.2 代码结构分析

**代码组织**：

1. **追加层**：AOF命令追加实现
2. **同步层**：AOF文件同步实现
3. **重写层**：AOF重写实现

**模块化设计**：

- **高内聚**：AOF相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的同步策略和重写策略

### 8.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 安全性** | 三级同步策略 | 平衡性能和安全性 |
| **简单 vs 复杂** | 命令追加+重写 | 支持数据恢复 |
| **通用 vs 专用** | 通用AOF格式 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{safety} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（fsync开销，重写开销）
- $C_{safety}$：安全性成本（数据安全性）
- $C_{complexity}$：复杂度成本（重写机制，复杂度较高）

### 8.4 可扩展性分析

**扩展点**：

1. **新同步策略**：可扩展为其他同步策略
2. **新重写策略**：可扩展为其他重写策略
3. **增量AOF**：可扩展为增量AOF追加

**扩展性设计**：

```c
// 可扩展的AOF接口
typedef struct aofHandler {
    int (*appendCommand)(rio *aof, robj **argv, int argc);
    int (*rewrite)(char *filename);
    void (*fsync)(int fd);
} aofHandler;
```

**可维护性**：

- **代码清晰**：AOF逻辑清晰，易于理解
- **易于调试**：AOF文件格式易于解析和调试
- **测试友好**：AOF行为易于测试和验证

## 9. 扩展阅读

- [RDB快照机制](./03.02.01-RDB快照机制.md)
- [混合持久化](./03.02.03-混合持久化.md)
- [持久化机制对比](../../00-项目总览/多维概念矩阵对比.md#4-redis持久化机制对比矩阵)

## 10. 权威参考

### 10.1 官方文档

1. **Redis源码 - aof.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/aof.c>
   - 版本: Redis 2.0+
   - AOF的完整实现源码

2. **Redis官方文档 - Persistence**
   - URL: <https://redis.io/docs/manual/persistence/>
   - 版本: Redis 7.0+
   - Redis持久化机制的官方文档

### 10.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第11章：AOF持久化（详细分析AOF实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第3章：持久化（AOF详解）

### 10.3 在线资源

1. **Wikipedia - Write-ahead logging**
   - URL: <https://en.wikipedia.org/wiki/Write-ahead_logging>
   - 提供预写日志的通用说明

2. **Linux man page - fsync(2)**
   - URL: <https://man7.org/linux/man-pages/man2/fsync.2.html>
   - fsync()系统调用的详细说明

```c
// 加载AOF文件
int loadAppendOnlyFile(char *filename) {
    struct client *fakeClient;
    FILE *fp;
    struct redis_stat sb;
    int old_aof_state = server.aof_state;
    long loops = 0;

    // 打开AOF文件
    fp = fopen(filename, "r");

    server.aof_state = AOF_OFF;
    fakeClient = createFakeClient();

    // 逐行读取并执行命令
    while (1) {
        int argc, j;
        unsigned long len;
        robj **argv;
        char buf[1024];

        // 读取命令
        if (fgets(buf, sizeof(buf), fp) == NULL) {
            if (feof(fp)) {
                break;
            } else {
                goto readerr;
            }
        }

        // 解析命令
        if (buf[0] != '*') goto fmterr;
        if (buf[1] == '\0') goto readerr;
        argc = atoi(buf+1);

        argv = zmalloc(sizeof(robj*)*argc);
        // ... 解析参数

        // 执行命令
        fakeClient->argc = argc;
        fakeClient->argv = argv;
        cmd = lookupCommand(argv[0]->ptr);
        cmd->proc(fakeClient);

        // 清理
        for (j = 0; j < argc; j++) {
            decrRefCount(argv[j]);
        }
        zfree(argv);
    }

    fclose(fp);
    freeFakeClient(fakeClient);
    server.aof_state = old_aof_state;

    return C_OK;
}
```
