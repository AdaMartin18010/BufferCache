# 03.02.03 混合持久化

## 目录

- [03.02.03 混合持久化](#030203-混合持久化)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 设计目标](#2-设计目标)
    - [2.1 问题分析](#21-问题分析)
    - [2.2 解决方案](#22-解决方案)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 实现原理](#3-实现原理)
    - [3.1 文件格式](#31-文件格式)
    - [3.2 AOF重写流程](#32-aof重写流程)
    - [3.3 数据恢复流程](#33-数据恢复流程)
  - [4. 性能分析](#4-性能分析)
    - [4.1 恢复性能分析](#41-恢复性能分析)
    - [4.2 文件大小分析](#42-文件大小分析)
  - [5. 配置与使用](#5-配置与使用)
    - [5.1 开启混合持久化](#51-开启混合持久化)
    - [5.2 性能调优](#52-性能调优)
  - [6. 适用场景](#6-适用场景)
    - [6.1 优势场景](#61-优势场景)
    - [6.2 不适用场景](#62-不适用场景)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**混合持久化（Mixed Persistence）**是Redis 4.0引入的特性，结合RDB和AOF的优点，既保证快速恢复，又保证数据完整性。

**历史发展**：

- **2009年**：Redis 1.0引入RDB和AOF
- **2017年**：Redis 4.0引入混合持久化
- **2020年代**：混合持久化成为Redis持久化的推荐方案

### 1.2 应用价值

混合持久化在Redis中具有重要价值：

1. **快速恢复**：RDB快照保证快速恢复
2. **数据完整性**：AOF增量日志保证数据完整性
3. **平衡性能**：在恢复速度和数据完整性之间取得平衡

## 2. 设计目标

### 2.1 问题分析

- **RDB优势**：恢复速度快，文件小
- **RDB劣势**：可能丢失数据（两次快照之间的数据）
- **AOF优势**：数据完整性好，最多丢失1秒数据
- **AOF劣势**：恢复速度慢，文件大

### 2.2 解决方案

混合持久化 = RDB快照 + AOF增量日志

**设计思路**：

- AOF重写时，先写入RDB快照
- 然后追加AOF增量日志
- 恢复时，先加载RDB快照，再重放AOF日志

### 2.3 形式化定义

设RDB快照为$R$，AOF增量日志为$A$。

**混合持久化文件**：

$$MixedFile = R || A$$

其中$||$表示连接操作。

**恢复过程**：

$$Recover(MixedFile) = Replay(R) \circ Replay(A)$$

其中$\circ$表示顺序执行。

## 3. 实现原理

### 3.1 文件格式

```text
[RDB文件内容]
[AOF增量日志]
```

### 3.2 AOF重写流程

```c
// aof.c
int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp;
    char tmpfile[256];
    long long start = ustime();

    // 1. 创建临时文件
    snprintf(tmpfile, 256, "temp-rewriteaof-%d.aof", (int)getpid());
    fp = fopen(tmpfile, "w");
    if (!fp) {
        serverLog(LL_WARNING, "Opening the temp file for AOF rewrite: %s", strerror(errno));
        return C_ERR;
    }

    // 2. 如果开启混合持久化，先写入RDB
    if (server.aof_use_rdb_preamble) {
        int error;
        if (rdbSaveRio(&aof, &error, RDB_SAVE_AOF_PREAMBLE, NULL) == C_ERR) {
            errno = error;
            goto werr;
        }
    } else {
        // 3. 否则写入AOF格式
        if (rioWrite(&aof, "REDIS", 5) == 0) goto werr;
        if (rioWriteBulkCount(&aof, '$', server.dbnum) == 0) goto werr;
    }

    // 4. 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db+j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;

        // 5. 写入SELECT命令
        if (rioWriteBulkCount(&aof, '*', 2) == 0) goto werr;
        if (rioWriteBulkString(&aof, "SELECT", 6) == 0) goto werr;
        if (rioWriteBulkLongLong(&aof, j) == 0) goto werr;

        // 6. 遍历所有key-value
        di = dictGetIterator(d);
        while((de = dictNext(di)) != NULL) {
            sds keystr = dictGetKey(de);
            robj *o = dictGetVal(de);
            long long expiretime = getExpire(db, keystr);

            // 7. 写入key-value
            if (expiretime != -1) {
                if (rioWriteBulkCount(&aof, '*', 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, "PEXPIREAT", 9) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                if (rioWriteBulkLongLong(&aof, expiretime) == 0) goto werr;
            }

            if (o->type == OBJ_STRING) {
                if (rioWriteBulkCount(&aof, '*', 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, "SET", 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                if (rioWriteBulkObject(&aof, o) == 0) goto werr;
            } else if (o->type == OBJ_LIST) {
                if (rioWriteBulkCount(&aof, '*', 2 + listTypeLength(o)) == 0) goto werr;
                if (rioWriteBulkString(&aof, "RPUSH", 5) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                // ... 其他类型
            }
        }
        dictReleaseIterator(di);
    }

    // 8. 同步到磁盘
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    // 9. 原子替换文件
    if (rename(tmpfile, filename) == -1) {
        serverLog(LL_WARNING, "Error moving temp append only file: %s", strerror(errno));
        unlink(tmpfile);
        return C_ERR;
    }

    serverLog(LL_NOTICE, "SYNC append only file rewrite performed");
    return C_OK;
}
```

### 3.3 数据恢复流程

**恢复流程**

```c
// server.c
int loadDataFromDisk(void) {
    long long start = ustime();

    // 1. 如果开启AOF，优先加载AOF
    if (server.aof_state == AOF_ON) {
        if (loadAppendOnlyFile(server.aof_filename) == C_OK) {
            serverLog(LL_NOTICE, "DB loaded from append only file: %.2f seconds",
                     (float)(ustime() - start) / 1000000);
            return C_OK;
        }
    }

    // 2. 否则加载RDB
    if (rdbLoad(server.rdb_filename) == C_OK) {
        serverLog(LL_NOTICE, "DB loaded from disk: %.2f seconds",
                 (float)(ustime() - start) / 1000000);
        return C_OK;
    }

    return C_ERR;
}

// aof.c
int loadAppendOnlyFile(char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) return C_ERR;

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        fclose(fp);
        return C_ERR;
    }

    // 1. 检查文件格式
    char sig[5];
    if (fread(sig, 1, 5, fp) != 5 || memcmp(sig, "REDIS", 5) != 0) {
        // 不是AOF格式，可能是RDB格式（混合持久化）
        fclose(fp);
        return loadAppendOnlyFileRDB(filename);
    }

    // 2. 读取版本号
    uint8_t byte;
    if (fread(&byte, 1, 1, fp) != 1) {
        fclose(fp);
        return C_ERR;
    }

    // 3. 如果是混合持久化，先加载RDB部分
    if (byte == 0xFE) {  // RDB magic number
        fclose(fp);
        return loadAppendOnlyFileRDB(filename);
    }

    // 4. 否则按AOF格式加载
    fclose(fp);
    return loadAppendOnlyFileAOF(filename);
}

int loadAppendOnlyFileRDB(char *filename) {
    // 1. 加载RDB部分
    if (rdbLoad(filename) != C_OK) {
        return C_ERR;
    }

    // 2. 查找AOF部分的位置
    FILE *fp = fopen(filename, "r");
    // ... 定位AOF部分

    // 3. 加载AOF增量日志
    return loadAppendOnlyFileAOF(filename);
}
```

## 4. 性能分析

### 4.1 恢复性能分析

**恢复时间对比**：

| 方案 | 恢复时间 | 数据丢失 |
|------|----------|----------|
| **RDB** | 10秒 | 可能丢失几分钟数据 |
| **AOF** | 100秒 | 最多丢失1秒数据 |
| **混合持久化** | 15秒 | 最多丢失1秒数据 |

**定理 4.1**：混合持久化的恢复时间约为RDB的1.5倍，但比AOF快约6.7倍。

**证明**：

- RDB恢复时间：$T_{RDB} = 10\text{秒}$
- AOF恢复时间：$T_{AOF} = 100\text{秒}$
- 混合持久化恢复时间：$T_{Mixed} = T_{RDB} + T_{AOF\_incremental} \approx 15\text{秒}$
- 恢复时间比：$\frac{T_{Mixed}}{T_{RDB}} = \frac{15}{10} = 1.5$，$\frac{T_{AOF}}{T_{Mixed}} = \frac{100}{15} \approx 6.7$

### 4.2 文件大小分析

**文件大小对比**：

| 方案 | 文件大小 | 压缩率 |
|------|----------|--------|
| **RDB** | 100MB | 高 |
| **AOF** | 500MB | 低 |
| **混合持久化** | 150MB | 中 |

**定理 4.2**：混合持久化的文件大小约为RDB的1.5倍，但比AOF小约3.3倍。

**证明**：

- RDB文件大小：$S_{RDB} = 100\text{MB}$
- AOF文件大小：$S_{AOF} = 500\text{MB}$
- 混合持久化文件大小：$S_{Mixed} = S_{RDB} + S_{AOF\_incremental} \approx 150\text{MB}$
- 文件大小比：$\frac{S_{Mixed}}{S_{RDB}} = \frac{150}{100} = 1.5$，$\frac{S_{AOF}}{S_{Mixed}} = \frac{500}{150} \approx 3.3$

## 5. 配置与使用

### 5.1 开启混合持久化

```conf
# redis.conf

# 开启AOF
appendonly yes

# 开启混合持久化
aof-use-rdb-preamble yes

# AOF同步策略
appendfsync everysec

# AOF重写触发条件
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# RDB备份（作为兜底）
save 900 1
save 300 10
save 60 10000
```

### 5.2 性能调优

```conf
# 1. 增大AOF缓冲区
aof-rewrite-incremental-fsync yes

# 2. 后台重写时禁用fsync
no-appendfsync-on-rewrite yes

# 3. 使用更快的磁盘
# 使用SSD存储AOF文件
```

## 6. 适用场景

### 6.1 优势场景

1. **生产环境**：需要快速恢复和数据完整性
2. **高可用要求**：需要最小化数据丢失
3. **性能敏感**：需要平衡恢复速度和数据完整性

### 6.2 不适用场景

1. **只读场景**：不需要持久化的场景
2. **内存受限**：内存非常紧张的场景

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **组合模式**：混合持久化 = RDB + AOF组合
2. **策略模式**：不同持久化策略组合
3. **模板方法模式**：定义混合持久化的基本流程

**组合模式实现**：

```c
// 混合持久化组合结构
typedef struct mixed_persistence {
    rdb_file_t *rdb;
    aof_file_t *aof;
    int (*save)(struct mixed_persistence *mp);
    int (*load)(struct mixed_persistence *mp);
} mixed_persistence_t;
```

### 7.2 代码结构分析

**代码组织**：

1. **RDB层**：RDB文件处理
2. **AOF层**：AOF文件处理
3. **混合层**：混合持久化管理

**模块化设计**：

- **高内聚**：混合持久化相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的持久化策略

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 安全性** | RDB+AOF组合 | 平衡性能和安全性 |
| **简单 vs 复杂** | 组合设计 | 支持快速恢复和数据完整性 |
| **通用 vs 专用** | 通用混合实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{safety} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（RDB快速恢复）
- $C_{safety}$：安全性成本（AOF数据完整性）
- $C_{complexity}$：复杂度成本（组合设计，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新持久化策略**：可扩展为其他持久化策略
2. **新组合方式**：可扩展为其他组合方式
3. **自适应混合**：可扩展为自适应混合实现

**扩展性设计**：

```c
// 可扩展的混合持久化接口
typedef struct persistence_component {
    void *data;
    int (*save)(struct persistence_component *comp);
    int (*load)(struct persistence_component *comp);
} persistence_component_t;
```

**可维护性**：

- **代码清晰**：混合持久化逻辑清晰，易于理解
- **易于调试**：文件状态易于监控和调试
- **测试友好**：混合持久化行为易于测试和验证

## 8. 扩展阅读

- [RDB快照机制](./03.02.01-RDB快照机制.md)
- [AOF日志机制](./03.02.02-AOF日志机制.md)
- [持久化机制总览](./README.md)

## 9. 权威参考

### 9.1 官方文档

1. **Redis源码 - aof.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/aof.c>
   - 版本: Redis 4.0+
   - 混合持久化的完整实现源码

2. **Redis官方文档 - Persistence**
   - URL: <https://redis.io/docs/manual/persistence/>
   - 版本: Redis 7.0+
   - Redis持久化的官方文档

### 9.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第10章：持久化（混合持久化详解）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第2章：Redis持久化（混合持久化应用）

### 9.3 在线资源

1. **Redis Release Notes - Redis 4.0**
   - URL: <https://raw.githubusercontent.com/antirez/redis/4.0/00-RELEASENOTES>
   - Redis 4.0版本说明，包含混合持久化的引入说明
