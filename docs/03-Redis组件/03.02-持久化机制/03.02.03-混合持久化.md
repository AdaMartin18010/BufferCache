# 03.02.03 混合持久化

## 概述

混合持久化（Mixed Persistence）是Redis 4.0引入的特性，结合RDB和AOF的优点，既保证快速恢复，又保证数据完整性。

## 设计目标

### 问题分析

- **RDB优势**：恢复速度快，文件小
- **RDB劣势**：可能丢失数据（两次快照之间的数据）
- **AOF优势**：数据完整性好，最多丢失1秒数据
- **AOF劣势**：恢复速度慢，文件大

### 解决方案

混合持久化 = RDB快照 + AOF增量日志

## 实现原理

### 文件格式

```
[RDB文件内容]
[AOF增量日志]
```

### 开启混合持久化

```conf
# redis.conf
aof-use-rdb-preamble yes  # 开启混合持久化
```

### AOF重写流程

```c
// aof.c
int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp;
    char tmpfile[256];
    long long start = ustime();

    // 1. 创建临时文件
    snprintf(tmpfile, 256, "temp-rewriteaof-%d.aof", (int)getpid());
    fp = fopen(tmpfile, "w");
    if (!fp) {
        serverLog(LL_WARNING, "Opening the temp file for AOF rewrite: %s", strerror(errno));
        return C_ERR;
    }

    // 2. 如果开启混合持久化，先写入RDB
    if (server.aof_use_rdb_preamble) {
        int error;
        if (rdbSaveRio(&aof, &error, RDB_SAVE_AOF_PREAMBLE, NULL) == C_ERR) {
            errno = error;
            goto werr;
        }
    } else {
        // 3. 否则写入AOF格式
        if (rioWrite(&aof, "REDIS", 5) == 0) goto werr;
        if (rioWriteBulkCount(&aof, '$', server.dbnum) == 0) goto werr;
    }

    // 4. 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db+j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;

        // 5. 写入SELECT命令
        if (rioWriteBulkCount(&aof, '*', 2) == 0) goto werr;
        if (rioWriteBulkString(&aof, "SELECT", 6) == 0) goto werr;
        if (rioWriteBulkLongLong(&aof, j) == 0) goto werr;

        // 6. 遍历所有key-value
        di = dictGetIterator(d);
        while((de = dictNext(di)) != NULL) {
            sds keystr = dictGetKey(de);
            robj *o = dictGetVal(de);
            long long expiretime = getExpire(db, keystr);

            // 7. 写入key-value
            if (expiretime != -1) {
                if (rioWriteBulkCount(&aof, '*', 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, "PEXPIREAT", 9) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                if (rioWriteBulkLongLong(&aof, expiretime) == 0) goto werr;
            }

            if (o->type == OBJ_STRING) {
                if (rioWriteBulkCount(&aof, '*', 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, "SET", 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                if (rioWriteBulkObject(&aof, o) == 0) goto werr;
            } else if (o->type == OBJ_LIST) {
                if (rioWriteBulkCount(&aof, '*', 2 + listTypeLength(o)) == 0) goto werr;
                if (rioWriteBulkString(&aof, "RPUSH", 5) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                // ... 其他类型
            }
        }
        dictReleaseIterator(di);
    }

    // 8. 同步到磁盘
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    // 9. 原子替换文件
    if (rename(tmpfile, filename) == -1) {
        serverLog(LL_WARNING, "Error moving temp append only file: %s", strerror(errno));
        unlink(tmpfile);
        return C_ERR;
    }

    serverLog(LL_NOTICE, "SYNC append only file rewrite performed");
    return C_OK;
}
```

## 数据恢复

### 恢复流程

```c
// server.c
int loadDataFromDisk(void) {
    long long start = ustime();

    // 1. 如果开启AOF，优先加载AOF
    if (server.aof_state == AOF_ON) {
        if (loadAppendOnlyFile(server.aof_filename) == C_OK) {
            serverLog(LL_NOTICE, "DB loaded from append only file: %.2f seconds",
                     (float)(ustime() - start) / 1000000);
            return C_OK;
        }
    }

    // 2. 否则加载RDB
    if (rdbLoad(server.rdb_filename) == C_OK) {
        serverLog(LL_NOTICE, "DB loaded from disk: %.2f seconds",
                 (float)(ustime() - start) / 1000000);
        return C_OK;
    }

    return C_ERR;
}

// aof.c
int loadAppendOnlyFile(char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) return C_ERR;

    struct redis_stat sb;
    if (redis_fstat(fileno(fp), &sb) == -1) {
        fclose(fp);
        return C_ERR;
    }

    // 1. 检查文件格式
    char sig[5];
    if (fread(sig, 1, 5, fp) != 5 || memcmp(sig, "REDIS", 5) != 0) {
        // 不是AOF格式，可能是RDB格式（混合持久化）
        fclose(fp);
        return loadAppendOnlyFileRDB(filename);
    }

    // 2. 读取版本号
    uint8_t byte;
    if (fread(&byte, 1, 1, fp) != 1) {
        fclose(fp);
        return C_ERR;
    }

    // 3. 如果是混合持久化，先加载RDB部分
    if (byte == 0xFE) {  // RDB magic number
        fclose(fp);
        return loadAppendOnlyFileRDB(filename);
    }

    // 4. 否则按AOF格式加载
    fclose(fp);
    return loadAppendOnlyFileAOF(filename);
}

int loadAppendOnlyFileRDB(char *filename) {
    // 1. 加载RDB部分
    if (rdbLoad(filename) != C_OK) {
        return C_ERR;
    }

    // 2. 查找AOF部分的位置
    FILE *fp = fopen(filename, "r");
    // ... 定位AOF部分

    // 3. 加载AOF增量日志
    return loadAppendOnlyFileAOF(filename);
}
```

## 性能对比

### 恢复时间

| 方案 | 恢复时间 | 数据丢失 |
|------|----------|----------|
| **RDB** | 10秒 | 可能丢失几分钟数据 |
| **AOF** | 100秒 | 最多丢失1秒数据 |
| **混合持久化** | 15秒 | 最多丢失1秒数据 |

### 文件大小

| 方案 | 文件大小 | 压缩率 |
|------|----------|--------|
| **RDB** | 100MB | 高 |
| **AOF** | 500MB | 低 |
| **混合持久化** | 150MB | 中 |

## 配置建议

### 生产环境配置

```conf
# redis.conf

# 开启AOF
appendonly yes

# 开启混合持久化
aof-use-rdb-preamble yes

# AOF同步策略
appendfsync everysec

# AOF重写触发条件
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# RDB备份（作为兜底）
save 900 1
save 300 10
save 60 10000
```

### 性能调优

```conf
# 1. 增大AOF缓冲区
aof-rewrite-incremental-fsync yes

# 2. 后台重写时禁用fsync
no-appendfsync-on-rewrite yes

# 3. 使用更快的磁盘
# 使用SSD存储AOF文件
```

## 扩展阅读

- [RDB快照机制](./03.02.01-RDB快照机制.md)
- [AOF日志机制](./03.02.02-AOF日志机制.md)
- [持久化机制总览](./README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/persistence/>
