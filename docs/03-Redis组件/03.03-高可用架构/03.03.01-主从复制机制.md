# 03.03.01 主从复制机制

## 目录

- [03.03.01 主从复制机制](#030301-主从复制机制)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 核心原理](#2-核心原理)
    - [2.1 复制流程](#21-复制流程)
    - [2.2 复制阶段](#22-复制阶段)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数据结构](#3-数据结构)
    - [3.1 复制积压缓冲区](#31-复制积压缓冲区)
    - [复制积压缓冲区](#复制积压缓冲区)
    - [3.2 复制偏移量](#32-复制偏移量)
  - [4. 全量同步](#4-全量同步)
    - [4.1 触发条件](#41-触发条件)
    - [4.2 同步流程](#42-同步流程)
  - [5. 增量同步](#5-增量同步)
    - [5.1 部分重同步](#51-部分重同步)
    - [5.2 命令传播](#52-命令传播)
    - [复制积压缓冲区](#复制积压缓冲区-1)
  - [6. 性能分析](#6-性能分析)
    - [6.1 全量同步性能](#61-全量同步性能)
    - [6.2 增量同步性能](#62-增量同步性能)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 程序设计分析](#8-程序设计分析)
    - [8.1 设计模式应用](#81-设计模式应用)
    - [8.2 代码结构分析](#82-代码结构分析)
    - [8.3 设计权衡](#83-设计权衡)
    - [8.4 可扩展性分析](#84-可扩展性分析)
  - [9. 扩展阅读](#9-扩展阅读)
  - [10. 权威参考](#10-权威参考)
    - [10.1 官方文档](#101-官方文档)
    - [10.2 经典书籍](#102-经典书籍)
    - [10.3 在线资源](#103-在线资源)
  - [配置参数](#配置参数)
    - [关键配置](#关键配置)
    - [容量规划](#容量规划)
  - [性能优化](#性能优化)
    - [1. 无盘复制](#1-无盘复制)
    - [2. 并行复制](#2-并行复制)
    - [3. 增量同步优化](#3-增量同步优化)
  - [故障处理](#故障处理)
    - [主节点故障](#主节点故障)
    - [从节点故障](#从节点故障)
  - [监控指标](#监控指标)
    - [关键指标](#关键指标)
  - [扩展阅读](#扩展阅读)
  - [权威参考](#权威参考)

---

## 1. 概述

### 1.1 定义与历史背景

**Redis主从复制**是Redis高可用架构的基础，通过将主节点的数据复制到从节点，实现数据备份、读写分离和故障转移。

**历史发展**：

- **2010年**：Redis 2.0引入主从复制机制
- **2012年**：Redis 2.8引入部分重同步（PSYNC）
- **2015年**：Redis 3.2优化复制性能
- **2020年代**：主从复制成为Redis高可用的标准配置

### 1.2 应用价值

主从复制在Redis中具有重要价值：

1. **数据备份**：从节点作为主节点的数据备份
2. **读写分离**：从节点处理读请求，主节点处理写请求
3. **故障转移**：主节点故障时，从节点可以提升为主节点
4. **负载均衡**：多个从节点分担读请求负载

## 2. 核心原理

### 2.1 复制流程

```text
主节点(Master)                   从节点(Slave)
     │                               │
     │  1. SLAVEOF命令              │
     │◀──────────────────────────────│
     │                               │
     │  2. 建立连接                  │
     │──────────────────────────────▶│
     │                               │
     │  3. PING/PONG                 │
     │◀──────────────────────────────│
     │                               │
     │  4. 全量同步（RDB）           │
     │──────────────────────────────▶│
     │                               │
     │  5. 增量同步（命令传播）       │
     │──────────────────────────────▶│
     │                               │
```

### 2.2 复制阶段

1. **连接建立**：从节点连接主节点
2. **身份验证**：如果配置了密码，进行身份验证
3. **全量同步**：主节点生成RDB并发送给从节点
4. **增量同步**：主节点将后续命令传播给从节点

### 2.3 形式化定义

设主节点状态为$M(t)$，从节点状态为$S(t)$，主从复制过程：

1. **初始同步**：$S(t_0) = M(t_0)$（全量同步）
2. **增量同步**：对于$t > t_0$，主节点执行命令$c(t)$，传播给从节点
3. **最终一致性**：$\lim_{t \to \infty} S(t) = M(t)$

**复制延迟**：

$$\Delta(t) = |M(t) - S(t)|$$

其中$\Delta(t)$为时刻$t$的复制延迟。

## 3. 数据结构

### 3.1 复制积压缓冲区

### 复制积压缓冲区

```c
// 复制积压缓冲区（FIFO环形队列）
typedef struct redisServer {
    char *repl_backlog;          // 缓冲区
    long long repl_backlog_size; // 缓冲区大小
    long long repl_backlog_histlen; // 历史长度
    long long repl_backlog_idx;  // 当前写入位置
    long long repl_backlog_off;  // 第一个字节的偏移量
    time_t repl_backlog_time_limit; // 超时时间
    int repl_backlog_fd;         // RDB文件描述符
} redisServer;
```

### 3.2 复制偏移量

```c
// 主从节点各自维护偏移量
typedef struct redisClient {
    long long reploff;           // 复制偏移量
    long long repl_ack_off;      // 确认的偏移量
    time_t repl_ack_time;        // 最后确认时间
} redisClient;
```

## 4. 全量同步

### 4.1 触发条件

```c
// 从节点连接主节点时
void replicationFeedSlaves(list *slaves, int dictid,
                          robj **argv, int argc) {
    listIter li;
    listNode *ln;
    client *slave;
    int j, len;
    char llstr[32];

    if (server.masterhost != NULL) return;
    if (slaves == NULL) return;

    // 检查是否需要全量同步
    listRewind(slaves, &li);
    while((ln = listNext(&li))) {
        slave = ln->value;

        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START ||
            slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END) {
            // 需要全量同步
            continue;
        }

        // 增量同步
        addReplyMultiBulkLen(slave, argc);
        for (j = 0; j < argc; j++) {
            addReplyBulk(slave, argv[j]);
        }
    }
}
```

### 4.2 同步流程

**RDB传输**:

```c
// 主节点生成RDB并发送
int rdbSaveBackground(char *filename) {
    pid_t childpid;
    long long start;

    if (server.rdb_child_pid != -1) return C_ERR;

    server.dirty_before_bgsave = server.dirty;
    server.lastbgsave_try = time(NULL);
    start = ustime();

    if ((childpid = fork()) == 0) {
        // 子进程：生成RDB
        int retval;
        closeListeningSockets(0);
        redisSetProcTitle("redis-rdb-bgsave");
        retval = rdbSave(filename);
        exitFromChild((retval == C_OK) ? 0 : 1);
    } else {
        // 父进程：继续处理请求
        server.rdb_child_pid = childpid;
        server.rdb_save_time_start = time(NULL);
        server.rdb_child_type = RDB_CHILD_TYPE_DISK;
        return C_OK;
    }
    return C_ERR;
}
```

## 5. 增量同步

### 5.1 部分重同步

**PSYNC机制**：Redis 2.8+引入部分重同步，避免全量同步。

**触发条件**：

- 从节点保存了主节点的运行ID（runid）
- 从节点的复制偏移量在复制积压缓冲区内

**性能优势**：

**定理 5.1**：部分重同步的时间复杂度为O(M)，其中M为丢失的命令数，远小于全量同步的O(N)。

**证明**：

- 全量同步：$T_{full} = O(N)$，N为数据大小
- 部分重同步：$T_{partial} = O(M)$，M为丢失的命令数
- 通常$M << N$，因此$T_{partial} << T_{full}$

### 5.2 命令传播

```c
// 主节点传播命令到从节点
void replicationFeedSlaves(list *slaves, int dictid,
                          robj **argv, int argc) {
    listIter li;
    listNode *ln;
    client *slave;

    if (server.masterhost != NULL) return;
    if (slaves == NULL) return;

    listRewind(slaves, &li);
    while((ln = listNext(&li))) {
        slave = ln->value;

        // 跳过需要全量同步的从节点
        if (slave->replstate != SLAVE_STATE_ONLINE) continue;

        // 发送命令
        addReplyMultiBulkLen(slave, argc);
        for (int j = 0; j < argc; j++) {
            addReplyBulk(slave, argv[j]);
        }
    }
}
```

### 复制积压缓冲区

```c
// 写入复制积压缓冲区
void feedReplicationBacklog(void *ptr, size_t len) {
    unsigned char *p = ptr;

    server.master_repl_offset += len;

    while(len) {
        size_t thislen = server.repl_backlog_size - server.repl_backlog_idx;
        if (thislen > len) thislen = len;

        memcpy(server.repl_backlog + server.repl_backlog_idx, p, thislen);
        server.repl_backlog_idx += thislen;
        if (server.repl_backlog_idx == server.repl_backlog_size)
            server.repl_backlog_idx = 0;

        server.repl_backlog_histlen += thislen;
        len -= thislen;
        p += thislen;
    }

    if (server.repl_backlog_histlen > server.repl_backlog_size)
        server.repl_backlog_histlen = server.repl_backlog_size;

    server.repl_backlog_off = server.master_repl_offset -
                              server.repl_backlog_histlen + 1;
}
```

## 6. 性能分析

### 6.1 全量同步性能

**全量同步时间**：

$$T_{full} = T_{rdb\_generate} + T_{rdb\_transfer} + T_{rdb\_load}$$

其中：

- $T_{rdb\_generate}$：RDB生成时间（O(N)，N为数据大小）
- $T_{rdb\_transfer}$：RDB传输时间（O(N/B)，B为带宽）
- $T_{rdb\_load}$：RDB加载时间（O(N)）

**定理 6.1**：全量同步的时间复杂度为O(N)，其中N为数据大小。

### 6.2 增量同步性能

**增量同步时间**：

$$T_{incremental} = T_{command\_propagate} = O(1)$$

每个命令的传播时间为O(1)。

**复制延迟**：

$$\Delta = T_{network} + T_{process}$$

其中$T_{network}$为网络延迟，$T_{process}$为从节点处理时间。

## 7. 适用场景

### 7.1 优势场景

1. **数据备份**：从节点作为主节点的数据备份
2. **读写分离**：从节点处理读请求，主节点处理写请求
3. **故障转移**：主节点故障时，从节点可以提升为主节点

### 7.2 不适用场景

1. **强一致性要求**：主从复制存在延迟，无法保证强一致性
2. **跨地域复制**：网络延迟较大，复制延迟高

## 8. 程序设计分析

### 8.1 设计模式应用

**使用的设计模式**：

1. **主从模式**：主节点负责写，从节点负责读
2. **观察者模式**：主节点命令执行事件通知从节点
3. **状态模式**：复制状态（全量同步、增量同步）

**主从模式实现**：

```c
// 主从复制接口
typedef struct replication {
    int role;  // REPLICATION_ROLE_MASTER or REPLICATION_ROLE_SLAVE
    list *slaves;
    void (*propagate)(struct replication *rep, robj **argv, int argc);
} replication;
```

### 8.2 代码结构分析

**代码组织**：

1. **主节点层**：主节点复制实现
2. **从节点层**：从节点同步实现
3. **协议层**：复制协议实现

**模块化设计**：

- **高内聚**：复制相关功能集中在同一模块
- **低耦合**：通过协议交互，减少依赖
- **可扩展**：易于添加新的复制策略

### 8.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 一致性** | 最终一致性 | 平衡性能和一致性 |
| **简单 vs 复杂** | 全量+增量同步 | 支持数据恢复 |
| **通用 vs 专用** | 通用主从复制 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{consistency} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（全量同步开销，增量同步开销）
- $C_{consistency}$：一致性成本（最终一致性）
- $C_{complexity}$：复杂度成本（全量+增量同步，复杂度较高）

### 8.4 可扩展性分析

**扩展点**：

1. **新复制策略**：可扩展为其他复制策略
2. **新同步方式**：可扩展为其他同步方式
3. **多主复制**：可扩展为多主复制实现

**扩展性设计**：

```c
// 可扩展的复制接口
typedef struct replicationStrategy {
    int (*sync)(replication *rep);
    void (*propagate)(replication *rep, robj **argv, int argc);
    const char *name;
} replicationStrategy;
```

**可维护性**：

- **代码清晰**：复制逻辑清晰，易于理解
- **易于调试**：复制状态易于监控和调试
- **测试友好**：复制行为易于测试和验证

## 9. 扩展阅读

- [Sentinel哨兵机制](./03.03.02-Sentinel哨兵机制.md)
- [Cluster集群模式](./03.03.03-Cluster集群模式.md)
- [RDB快照机制](../03.02-持久化机制/03.02.01-RDB快照机制.md)

## 10. 权威参考

### 10.1 官方文档

1. **Redis源码 - replication.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/replication.c>
   - 版本: Redis 2.0+
   - 主从复制的完整实现源码

2. **Redis官方文档 - Replication**
   - URL: <https://redis.io/docs/manual/replication/>
   - 版本: Redis 7.0+
   - Redis主从复制的官方文档

### 10.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第15章：复制（详细分析主从复制实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第4章：主从复制（主从复制详解）

### 10.3 在线资源

1. **Wikipedia - Master-slave (technology)**
   - URL: <https://en.wikipedia.org/wiki/Master-slave_(technology)>
   - 提供主从架构的通用说明

```c
// 从节点重连时检查是否可以部分重同步
int masterTryPartialResynchronization(client *c) {
    long long psync_offset, psync_len;
    char *master_runid = c->argv[1]->ptr;
    char buf[128];
    int buflen;

    // 检查runid是否匹配
    if (strcasecmp(master_runid, server.runid)) {
        // runid不匹配，需要全量同步
        goto need_full_resync;
    }

    // 读取偏移量
    psync_offset = strtoll(c->argv[2]->ptr, NULL, 10);

    // 检查偏移量是否在积压缓冲区中
    if (!server.repl_backlog ||
        psync_offset < server.repl_backlog_off ||
        psync_offset > (server.repl_backlog_off + server.repl_backlog_histlen)) {
        // 偏移量不在缓冲区中，需要全量同步
        goto need_full_resync;
    }

    // 可以部分重同步
    c->flags |= CLIENT_SLAVE;
    c->replstate = SLAVE_STATE_ONLINE;
    c->repl_ack_off = psync_offset;
    c->repl_ack_time = server.unixtime;

    listAddNodeTail(server.slaves, c);

    // 发送CONTINUE响应
    buflen = snprintf(buf, sizeof(buf), "+CONTINUE\r\n");
    if (write(c->fd, buf, buflen) != buflen) {
        freeClientAsync(c);
        return C_OK;
    }

    // 发送积压缓冲区中的数据
    psync_len = server.master_repl_offset - psync_offset;
    replicationFeedSlave(c, server.repl_backlog +
                        (server.repl_backlog_size -
                         (server.master_repl_offset - psync_offset)),
                        psync_len);

    return C_OK;

need_full_resync:
    return C_ERR;
}
```

## 配置参数

### 关键配置

```conf
# 主节点配置
repl-backlog-size 1mb          # 复制积压缓冲区大小
repl-backlog-ttl 3600          # 缓冲区超时时间

# 从节点配置
replica-serve-stale-data yes   # 主从断开时是否提供服务
replica-read-only yes          # 从节点只读
repl-diskless-sync no          # 是否无盘复制
repl-diskless-sync-delay 5     # 无盘复制延迟
```

### 容量规划

```c
// 复制积压缓冲区大小计算
// repl_backlog_size = 平均写入速度 × 允许断线时长

// 示例：
// 平均写入速度：10MB/s
// 允许断线时长：60秒
// repl_backlog_size = 10MB/s × 60s = 600MB
```

## 性能优化

### 1. 无盘复制

```conf
# 启用无盘复制（Redis 2.8.18+）
repl-diskless-sync yes
repl-diskless-sync-delay 5
```

**优势**：

- 避免磁盘IO
- 提升复制速度
- 降低主节点压力

### 2. 并行复制

```conf
# Redis 4.0+支持并行复制
repl-diskless-sync yes
```

**机制**：

- 多个从节点并行接收RDB
- 减少主节点压力

### 3. 增量同步优化

```c
// 增大复制积压缓冲区
repl-backlog-size 100mb  // 默认1mb

// 减少全量同步频率
// 允许更长的断线时间
```

## 故障处理

### 主节点故障

```
1. 从节点检测主节点不可达
2. 等待超时（repl-timeout）
3. 尝试重连
4. 如果配置了Sentinel，触发故障转移
```

### 从节点故障

```
1. 主节点检测从节点断开
2. 清理从节点连接
3. 从节点重连后：
   - 如果偏移量在积压缓冲区中：部分重同步
   - 否则：全量同步
```

## 监控指标

### 关键指标

```bash
# 查看复制信息
127.0.0.1:6379> INFO replication

# 关键指标
role:master                    # 角色
connected_slaves:2            # 连接的从节点数
master_repl_offset:123456      # 主节点复制偏移量
repl_backlog_active:1          # 积压缓冲区是否激活
repl_backlog_size:1048576      # 积压缓冲区大小
repl_backlog_first_byte_offset:123000  # 第一个字节偏移量
```

## 扩展阅读

- [Sentinel哨兵机制](./03.03.02-Sentinel哨兵机制.md)
- [Cluster集群模式](./03.03.03-Cluster集群模式.md)
- [RDB快照机制](../03.02-持久化机制/03.02.01-RDB快照机制.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/replication/>
