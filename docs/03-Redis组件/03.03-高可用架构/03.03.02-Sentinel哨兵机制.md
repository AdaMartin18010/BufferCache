# 03.03.02 Sentinel哨兵机制

## 概述

Sentinel（哨兵）是Redis的高可用解决方案，通过监控主从节点状态，自动进行故障检测和故障转移，实现Redis的高可用。

## 核心功能

### 主要功能

1. **监控**：持续监控主从节点是否正常工作
2. **通知**：当被监控节点出现问题时，通知管理员
3. **自动故障转移**：主节点故障时，自动将某个从节点升级为主节点
4. **配置提供者**：客户端连接时，返回当前主节点地址

## 架构设计

### 最小高可用配置

```
┌─────────────┐
│  Sentinel1  │
│   (监控)    │
└─────────────┘
      │
      │ 监控
      │
┌─────────────┐         ┌─────────────┐
│   Master    │────────│   Slave1    │
│  (主节点)   │         │  (从节点)   │
└─────────────┘         └─────────────┘
      │
      │ 监控
      │
┌─────────────┐         ┌─────────────┐
│  Sentinel2  │         │   Slave2    │
│   (监控)    │         │  (从节点)   │
└─────────────┘         └─────────────┘
      │
      │ 监控
      │
┌─────────────┐
│  Sentinel3  │
│   (监控)    │
└─────────────┘
```

**最小配置**：3个Sentinel实例（满足超过50%存活要求）

## 故障检测机制

### 主观下线（SDOWN）

```c
// 单个Sentinel认为节点不可达
void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {
    mstime_t elapsed = mstime() - ri->last_avail_time;

    if (elapsed > ri->down_after_period) {
        // 超过down_after_period时间未响应
        if ((ri->flags & SRI_S_DOWN) == 0) {
            sentinelEvent(LL_WARNING, "+sdown", ri, "%@");
            ri->flags |= SRI_S_DOWN;
        }
    } else {
        // 节点恢复
        if (ri->flags & SRI_S_DOWN) {
            sentinelEvent(LL_WARNING, "-sdown", ri, "%@");
            ri->flags &= ~SRI_S_DOWN;
        }
    }
}
```

**触发条件**：

- `down-after-milliseconds`时间内未收到PING响应
- 默认值：5000ms

### 客观下线（ODOWN）

```c
// 超过quorum个Sentinel认为节点不可达
int sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {
    unsigned int quorum = master->quorum;
    unsigned int odown_quorum = 1; // 至少需要1个Sentinel

    if (master->flags & SRI_S_DOWN) {
        // 统计认为主节点下线的Sentinel数量
        unsigned int masters = 0;
        dictIterator *di;
        dictEntry *de;

        di = dictGetIterator(master->sentinels);
        while((de = dictNext(di)) != NULL) {
            sentinelRedisInstance *ri = dictGetVal(de);
            if (ri->flags & SRI_MASTER_DOWN) {
                masters++;
            }
        }
        dictReleaseIterator(di);

        // 检查是否达到quorum
        if (masters >= quorum) {
            if ((master->flags & SRI_O_DOWN) == 0) {
                sentinelEvent(LL_WARNING, "+odown", master,
                            "%quorum %d/%d", masters, quorum);
                master->flags |= SRI_O_DOWN;
            }
            return 1;
        }
    }

    // 恢复
    if (master->flags & SRI_O_DOWN) {
        sentinelEvent(LL_WARNING, "-odown", master, "%@");
        master->flags &= ~SRI_O_DOWN;
    }
    return 0;
}
```

**触发条件**：

- 超过`quorum`个Sentinel认为主节点下线
- 默认quorum：1（至少需要1个Sentinel）

## 故障转移流程

### 1. 领导者选举

```c
// Raft算法变种选举
void sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {
    // 检查是否需要进行故障转移
    if (master->flags & SRI_FAILOVER_IN_PROGRESS) return;
    if (master->flags & SRI_PROMOTED) return;

    // 检查客观下线
    if (!(master->flags & SRI_O_DOWN)) return;

    // 检查故障转移延迟
    if (mstime() - master->last_avail_time < master->failover_timeout) {
        return;
    }

    // 检查是否已经有其他Sentinel在故障转移
    if (sentinelGetLeader(master) != sentinel.myid) {
        return;
    }

    // 开始故障转移
    sentinelStartFailover(master);
}

// 选举领导者
char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t *leader_epoch) {
    dict *counters = dictCreate(&leaderVoteDictType, NULL);
    dictIterator *di;
    dictEntry *de;
    unsigned int voters = 0, voters_quorum;
    char *myvote;
    char *winner = NULL;
    uint64_t max_epoch = 0;
    uint64_t epoch;

    voters_quorum = (sentinelNumMasters(master) / 2) + 1;

    // 收集投票
    di = dictGetIterator(master->sentinels);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *ri = dictGetVal(de);
        if (ri->leader != NULL && ri->leader_epoch == sentinel.current_epoch) {
            epoch = ri->leader_epoch;
            uint64_t *count = dictFetchValue(counters, ri->leader);
            if (count) {
                (*count)++;
            } else {
                uint64_t c = 1;
                dictAdd(counters, ri->leader, &c);
            }
            if (epoch > max_epoch) max_epoch = epoch;
        }
    }
    dictReleaseIterator(di);

    // 统计投票
    di = dictGetIterator(counters);
    while((de = dictNext(di)) != NULL) {
        uint64_t *count = dictGetVal(de);
        voters += *count;
        if (*count >= voters_quorum) {
            winner = dictGetKey(de);
            break;
        }
    }
    dictReleaseIterator(di);

    if (leader_epoch) *leader_epoch = max_epoch;
    dictRelease(counters);
    return winner;
}
```

### 2. 选择新主节点

```c
// 选择最优从节点作为新主节点
sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance **instance = zmalloc(sizeof(instance[0]) *
                                               dictSize(master->slaves));
    int numslaves = 0, j;
    dictIterator *di;
    dictEntry *de;
    mstime_t max_master_down_time = 0;

    // 收集所有从节点
    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);
        mstime_t info_validity_time;

        // 检查从节点状态
        if (slave->flags & (SRI_S_DOWN | SRI_O_DOWN)) continue;
        if (slave->link->disconnected) continue;
        if (slave->role_reported != SRI_SLAVE) continue;

        // 检查主从断开时间
        info_validity_time = mstime() - slave->info_refresh;
        if (info_validity_time > SENTINEL_PING_PERIOD * 5) continue;

        // 检查从节点优先级
        if (slave->slave_priority == 0) continue;

        instance[numslaves++] = slave;
        if (slave->master_link_down_time > max_master_down_time)
            max_master_down_time = slave->master_link_down_time;
    }
    dictReleaseIterator(di);

    if (numslaves == 0) return NULL;

    // 排序：优先级 > 复制偏移量 > runid
    qsort(instance, numslaves, sizeof(sentinelRedisInstance*),
          compareSlavesForPromotion);

    return instance[0];
}

// 比较函数
int compareSlavesForPromotion(const void *a, const void *b) {
    sentinelRedisInstance **sa = (sentinelRedisInstance **)a;
    sentinelRedisInstance **sb = (sentinelRedisInstance **)b;

    // 1. 优先级（越小越好）
    if ((*sa)->slave_priority != (*sb)->slave_priority)
        return (*sa)->slave_priority - (*sb)->slave_priority;

    // 2. 复制偏移量（越大越好）
    if ((*sa)->slave_repl_offset > (*sb)->slave_repl_offset) return -1;
    if ((*sa)->slave_repl_offset < (*sb)->slave_repl_offset) return 1;

    // 3. runid（字典序）
    return strcmp((*sa)->runid, (*sb)->runid);
}
```

### 3. 故障转移执行

```c
// 执行故障转移
void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {
    serverAssert(ri->flags & SRI_MASTER);

    if (!(ri->flags & SRI_FAILOVER_IN_PROGRESS)) return;

    switch(ri->failover_state) {
        case SENTINEL_FAILOVER_STATE_WAIT_START:
            sentinelFailoverWaitStart(ri);
            break;

        case SENTINEL_FAILOVER_STATE_SELECT_SLAVE:
            sentinelFailoverSelectSlave(ri);
            break;

        case SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:
            sentinelFailoverSendSlaveOfNoOne(ri);
            break;

        case SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:
            sentinelFailoverWaitPromotion(ri);
            break;

        case SENTINEL_FAILOVER_STATE_RECONF_SLAVES:
            sentinelFailoverReconfNextSlave(ri);
            break;
    }
}

// 阶段1：等待开始
void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {
    char *leader;
    int isleader;

    // 检查是否被选为领导者
    leader = sentinelGetLeader(ri, &ri->leader_epoch);
    isleader = (leader && strcmp(leader, sentinel.myid) == 0);

    if (!isleader) {
        // 不是领导者，等待
        ri->failover_state = SENTINEL_FAILOVER_STATE_WAIT_START;
        ri->failover_start_time = mstime() + rand() % SENTINEL_MAX_DESYNC;
        return;
    }

    // 是领导者，进入下一阶段
    ri->failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;
    ri->failover_epoch = sentinel.current_epoch;
    sentinelEvent(LL_WARNING, "+elected-leader", ri, "%@");
}

// 阶段2：选择从节点
void sentinelFailoverSelectSlave(sentinelRedisInstance *master) {
    sentinelRedisInstance *slave;

    slave = sentinelSelectSlave(master);
    if (slave == NULL) {
        // 没有可用的从节点
        sentinelAbortFailover(master);
        return;
    }

    master->promoted_slave = slave;
    master->failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;
    sentinelEvent(LL_WARNING, "+selected-slave", slave, "%@");
}

// 阶段3：发送SLAVEOF NO ONE
void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *master) {
    int retval;

    retval = sentinelSendSlaveOf(master->promoted_slave, NULL, 0);
    if (retval == C_OK) {
        master->failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;
        master->failover_state_change_time = mstime();
    }
}

// 阶段4：等待提升
void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {
    mstime_t elapsed = mstime() - ri->failover_state_change_time;
    sentinelRedisInstance *slave = ri->promoted_slave;

    if (elapsed > SENTINEL_PROMOTE_TIMEOUT) {
        // 超时，取消故障转移
        sentinelAbortFailover(ri);
        return;
    }

    // 检查从节点是否已提升为主节点
    if (slave->flags & SRI_PROMOTED) {
        ri->failover_state = SENTINEL_FAILOVER_STATE_RECONF_SLAVES;
        ri->failover_state_change_time = mstime();
        sentinelEvent(LL_WARNING, "+promoted-slave", slave, "%@");
    }
}

// 阶段5：重新配置从节点
void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {
    dictIterator *di;
    dictEntry *de;
    int in_progress = 0;

    di = dictGetIterator(master->slaves);
    while((de = dictNext(di)) != NULL) {
        sentinelRedisInstance *slave = dictGetVal(de);

        if (slave->flags & SRI_RECONF_SENT) {
            in_progress++;
            continue;
        }

        if (slave->flags & (SRI_RECONF_INPROG | SRI_RECONF_DONE)) {
            continue;
        }

        // 发送SLAVEOF命令
        if (slave->flags & SRI_PROMOTED) {
            continue; // 跳过新主节点
        }

        sentinelSendSlaveOf(slave, master->promoted_slave->addr->ip,
                           master->promoted_slave->addr->port);
        slave->flags |= SRI_RECONF_SENT;
        slave->reconf_sent_time = mstime();
        in_progress++;
    }
    dictReleaseIterator(di);

    if (in_progress == 0) {
        // 所有从节点已重新配置
        master->failover_state = SENTINEL_FAILOVER_STATE_NONE;
        master->flags &= ~SRI_FAILOVER_IN_PROGRESS;
        sentinelEvent(LL_WARNING, "+failover-end", master, "%@");
    }
}
```

## 配置示例

### Sentinel配置文件

```conf
# sentinel.conf

# 监控主节点
sentinel monitor mymaster 127.0.0.1 6379 2

# 主观下线时间（毫秒）
sentinel down-after-milliseconds mymaster 5000

# 故障转移超时时间（毫秒）
sentinel failover-timeout mymaster 10000

# 并行同步的从节点数
sentinel parallel-syncs mymaster 1

# 密码（如果主节点有密码）
sentinel auth-pass mymaster mypassword
```

### 启动Sentinel

```bash
# 启动Sentinel
redis-sentinel sentinel.conf

# 或使用Redis服务器模式
redis-server sentinel.conf --sentinel
```

## 客户端集成

### 自动发现主节点

```python
import redis.sentinel

# 连接Sentinel
sentinel = redis.sentinel.Sentinel([
    ('localhost', 26379),
    ('localhost', 26380),
    ('localhost', 26381)
])

# 获取主节点
master = sentinel.master_for('mymaster', socket_timeout=0.1)

# 获取从节点
slave = sentinel.slave_for('mymaster', socket_timeout=0.1)

# 使用
master.set('key', 'value')
value = slave.get('key')
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **自动故障转移** | 无需人工干预 |
| **高可用** | 3个Sentinel保证高可用 |
| **配置简单** | 配置相对简单 |

### 劣势

| 特性 | 说明 |
|------|------|
| **单点写入** | 主节点单点写入 |
| **扩展性** | 垂直扩展有限 |
| **复杂度** | 需要维护多个Sentinel实例 |

## 扩展阅读

- [主从复制机制](./03.03.01-主从复制机制.md)
- [Cluster集群模式](./03.03.03-Cluster集群模式.md)
- [高可用架构总览](../README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/sentinel/>
