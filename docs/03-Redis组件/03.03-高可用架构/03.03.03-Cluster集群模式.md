# 03.03.03 Cluster集群模式

## 目录

- [03.03.03 Cluster集群模式](#030303-cluster集群模式)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 核心设计](#2-核心设计)
    - [2.1 数据分片](#21-数据分片)
    - [2.2 架构拓扑](#22-架构拓扑)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数据结构设计](#3-数据结构设计)
    - [3.1 集群节点结构](#31-集群节点结构)
  - [4. 槽位分配](#4-槽位分配)
    - [4.1 槽位计算](#41-槽位计算)
    - [4.2 槽位迁移](#42-槽位迁移)
  - [5. 路由机制](#5-路由机制)
    - [5.1 MOVED重定向](#51-moved重定向)
    - [5.2 ASK重定向](#52-ask重定向)
    - [5.3 节点通信](#53-节点通信)
      - [5.3.1 Gossip协议](#531-gossip协议)
      - [5.3.2 心跳机制](#532-心跳机制)
  - [6. 故障转移](#6-故障转移)
    - [6.1 故障检测流程](#61-故障检测流程)
    - [6.2 故障转移流程](#62-故障转移流程)
    - [6.3 槽位迁移](#63-槽位迁移)
  - [7. 性能分析](#7-性能分析)
    - [7.1 性能特征](#71-性能特征)
    - [7.2 性能指标](#72-性能指标)
  - [8. 配置与使用](#8-配置与使用)
    - [8.1 集群配置](#81-集群配置)
    - [8.2 创建集群](#82-创建集群)
  - [9. 适用场景](#9-适用场景)
    - [9.1 优势场景](#91-优势场景)
    - [9.2 不适用场景](#92-不适用场景)
  - [10. 程序设计分析](#10-程序设计分析)
    - [10.1 设计模式应用](#101-设计模式应用)
    - [10.2 代码结构分析](#102-代码结构分析)
    - [10.3 设计权衡](#103-设计权衡)
    - [10.4 可扩展性分析](#104-可扩展性分析)
  - [11. 扩展阅读](#11-扩展阅读)
  - [12. 权威参考](#12-权威参考)
    - [12.1 官方文档](#121-官方文档)
    - [12.2 经典书籍](#122-经典书籍)
    - [12.3 在线资源](#123-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**Redis Cluster**是Redis的分布式解决方案，通过数据分片和节点间通信实现水平扩展和高可用。Cluster模式支持自动故障转移和动态扩缩容。

**版本信息**：

- **适用版本**：Redis 3.0+
- **文档基于版本**：Redis 7.2
- **最后更新**：2025-01

**历史发展**：

- **2015年**：Redis 3.0引入Cluster模式
- **2017年**：Redis 4.0优化Cluster实现
- **2020年代**：Cluster成为Redis分布式的标准方案
- **2023年**：Redis 7.2优化Cluster性能和故障转移速度

### 1.2 应用价值

Redis Cluster在分布式系统中具有重要价值：

1. **水平扩展**：支持水平扩展，突破单机内存限制
2. **高可用**：支持自动故障转移
3. **数据分片**：通过哈希槽实现数据分片
4. **动态扩缩容**：支持动态添加/删除节点

## 2. 核心设计

### 2.1 数据分片

Redis Cluster采用**哈希槽（Hash Slot）**机制进行数据分片：

- **总槽数**：16384个槽位
- **槽分配**：每个节点负责一部分槽位
- **数据路由**：`CRC16(key) % 16384` 计算槽位

### 2.2 架构拓扑

```text
┌─────────────┐         ┌─────────────┐
│  Node 1     │────────▶│  Node 2     │
│  Slot:0-5460│         │  Slot:5461- │
│  Master     │         │  10922      │
└─────────────┘         │  Master     │
      │                  └─────────────┘
      │                        │
      │                        │
┌─────────────┐         ┌─────────────┐
│  Node 1-S   │         │  Node 2-S   │
│  Slave      │         │  Slave      │
└─────────────┘         └─────────────┘
      │                        │
      └────────┬───────────────┘
               │
      ┌─────────────┐
      │  Node 3     │
      │  Slot:10923-│
      │  16383      │
      │  Master     │
      └─────────────┘
```

### 2.3 形式化定义

设集群节点集合为$N = \{n_1, n_2, ..., n_k\}$，哈希槽总数为$S = 16384$。

**槽位分配**：

对于每个节点$n_i$，分配槽位集合$Slots_i \subseteq \{0, 1, ..., S-1\}$，满足：

$$\bigcup_{i=1}^{k} Slots_i = \{0, 1, ..., S-1\}$$

$$\forall i \neq j: Slots_i \cap Slots_j = \emptyset$$

**数据路由**：

$$Route(key) = n_i \text{ 其中 } slot(key) \in Slots_i$$

其中$slot(key) = CRC16(key) \bmod S$。

## 3. 数据结构设计

### 3.1 集群节点结构

```c
// 集群节点
typedef struct clusterNode {
    mstime_t ctime;              // 创建时间
    char name[REDIS_CLUSTER_NAMELEN]; // 节点ID
    int flags;                   // 节点标志
    uint64_t configEpoch;        // 配置纪元
    char ip[REDIS_IP_STR_LEN];   // IP地址
    int port;                    // 端口
    clusterLink *link;           // 连接信息
    unsigned char slots[CLUSTER_SLOTS/8]; // 槽位位图
    int numslots;                // 负责的槽位数
    int numslaves;               // 从节点数
    struct clusterNode **slaves; // 从节点数组
    struct clusterNode *slaveof; // 主节点指针
    list *fail_reports;          // 故障报告列表
} clusterNode;

// 集群状态
typedef struct clusterState {
    clusterNode *myself;         // 当前节点
    uint64_t currentEpoch;      // 当前配置纪元
    int state;                   // 集群状态
    int size;                    // 主节点数
    dict *nodes;                 // 节点字典
    clusterNode *slots[CLUSTER_SLOTS]; // 槽位映射
    zskiplist *slots_to_keys;    // 槽位到key的映射
} clusterState;
```

## 4. 槽位分配

### 4.1 槽位计算

```c
// 计算key的槽位
unsigned int keyHashSlot(char *key, int keylen) {
    int s, e;

    // 查找{...}标签
    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    if (s == keylen) return crc16(key, keylen) & 0x3FFF;

    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    if (e == keylen || e == s+1) return crc16(key, keylen) & 0x3FFF;

    // 使用标签计算槽位
    return crc16(key+s+1, e-s-1) & 0x3FFF;
}

// 示例
// key = "user:{1001}:profile"
// hash tag = "1001"
// slot = CRC16("1001") % 16384
```

**定理 4.1**：槽位计算的时间复杂度为O(1)。

**证明**：

- CRC16计算：O(1)
- 取模运算：O(1)
- 总时间复杂度：O(1)

### 4.2 槽位迁移

```c
// 槽位迁移
void clusterSetSlot(clusterNode *n, int slot, clusterNode *sender) {
    clusterNode *old = server.cluster->slots[slot];

    if (old == n) return;

    if (old != NULL) {
        // 从旧节点移除槽位
        if (old->numslots == 1) {
            // 节点不再负责任何槽位
            clusterDelNode(old);
        } else {
            // 更新位图
            bitmapClearBit(old->slots, slot);
            old->numslots--;
        }
    }

    // 分配给新节点
    if (n != NULL) {
        bitmapSetBit(n->slots, slot);
        n->numslots++;
    }

    server.cluster->slots[slot] = n;
}
```

**槽位迁移**：当节点增减时，需要迁移槽位和数据。

## 5. 路由机制

### 5.1 MOVED重定向

**MOVED重定向**：当key不在当前节点时，返回MOVED错误，客户端需要重定向到正确的节点。

### 5.2 ASK重定向

**ASK重定向**：当槽位正在迁移时，返回ASK错误，客户端需要先发送ASKING命令。

### 5.3 节点通信

#### 5.3.1 Gossip协议

```c
// Gossip消息格式
typedef struct {
    char sig[4];                 // 签名"RCmb"
    uint32_t totlen;             // 消息总长度
    uint16_t ver;                // 协议版本
    uint16_t port;               // TCP端口
    uint16_t type;               // 消息类型
    uint16_t count;              // 消息体数量
    uint64_t currentEpoch;       // 当前配置纪元
    uint64_t configEpoch;        // 配置纪元
    uint64_t offset;             // 复制偏移量
    char sender[REDIS_CLUSTER_NAMELEN]; // 发送者ID
    unsigned char myslots[CLUSTER_SLOTS/8]; // 槽位位图
    char slaveof[REDIS_CLUSTER_NAMELEN]; // 主节点ID
    char myip[REDIS_IP_STR_LEN]; // IP地址
    uint16_t cport;              // 集群端口
    uint16_t flags;              // 节点标志
    unsigned char state;         // 集群状态
    unsigned char mflags[3];    // 消息标志
    union clusterMsgData data;   // 消息数据
} clusterMsg;
```

**Gossip协议**：节点之间通过Gossip协议交换集群状态信息。

#### 5.3.2 心跳机制

```c
// 发送心跳
void clusterSendPing(clusterLink *link, int type) {
    unsigned char buf[sizeof(clusterMsg)];
    clusterMsg *hdr = (clusterMsg *)buf;
    int gossipcount = 0, totlen;
    clusterNode *node;
    dictIterator *di;
    dictEntry *de;

    // 构建消息头
    clusterBuildMessageHdr(hdr, type);

    // 添加Gossip信息
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL && gossipcount < 3) {
        node = dictGetVal(de);
        if (node->flags & (REDIS_NODE_HANDSHAKE|REDIS_NODE_NOADDR)) continue;
        if (node->flags & REDIS_NODE_PFAIL) continue;

        clusterMsgDataGossip *gossip = &(hdr->data.ping.gossip[gossipcount]);
        gossip->nodename = node->name;
        gossip->ping_sent = node->ping_sent;
        gossip->pong_received = node->pong_received;
        gossip->flags = node->flags;
        gossip->port = htons(node->port);
        gossip->cport = htons(node->cport);
        memcpy(gossip->ip, node->ip, sizeof(gossip->ip));
        gossipcount++;
    }
    dictReleaseIterator(di);

    hdr->count = htons(gossipcount);
    totlen = sizeof(clusterMsg) - sizeof(union clusterMsgData) +
             (sizeof(clusterMsgDataGossip) * gossipcount);
    hdr->totlen = htonl(totlen);

    // 发送消息
    clusterSendMessage(link, (unsigned char *)buf, totlen);
}
```

**心跳机制**：节点定期发送PING消息，检测其他节点状态。

## 6. 故障转移

### 6.1 故障检测流程

```c
// 故障检测
void clusterCron(void) {
    dictIterator *di;
    dictEntry *de;
    clusterNode *node;
    mstime_t now = mstime();
    mstime_t min_ping = 0;

    // 检查所有节点
    di = dictGetIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        node = dictGetVal(de);

        // 跳过自己
        if (node->flags & REDIS_NODE_MYSELF) continue;

        // 检查PING超时
        if (node->link && node->ping_sent != 0) {
            mstime_t ping_delay = now - node->ping_sent;

            if (ping_delay > server.cluster_node_timeout) {
                // PING超时，标记为疑似故障
                if (!(node->flags & REDIS_NODE_PFAIL)) {
                    node->flags |= REDIS_NODE_PFAIL;
                    clusterSendFail(node->name);
                }
            }
        }

        // 发送PING
        if (node->link && node->ping_sent == 0) {
            clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);
            node->ping_sent = now;
        }
    }
    dictReleaseIterator(di);

    // 检查故障报告
    clusterCheckFailover();
}
```

**故障检测**：节点通过心跳机制检测其他节点故障。

### 6.2 故障转移流程

```c
// 故障转移
void clusterHandleSlaveFailover(void) {
    mstime_t data_age;
    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
    mstime_t master_since = mstime() - server.cluster->failover_auth_sent;
    clusterNode *master = server.cluster->myself->slaveof;

    // 检查主节点是否真的下线
    if (master == NULL) return;

    // 检查数据新鲜度
    data_age = (mstime() - server.cluster->failover_auth_time) +
               (master->ping_sent ? (mstime() - master->ping_sent) : 0);

    if (data_age > server.cluster->cluster_node_timeout * 2) {
        // 数据太旧，取消故障转移
        return;
    }

    // 检查是否获得足够投票
    if (server.cluster->failover_auth_count >= server.cluster->failover_auth_quorum) {
        // 开始故障转移
        server.cluster->failover_auth_time = 0;
        server.cluster->failover_auth_count = 0;
        server.cluster->failover_auth_sent = 0;
        server.cluster->failover_auth_rank = 0;
        server.cluster->failover_auth_epoch = server.cluster->currentEpoch;

        // 提升自己为主节点
        clusterSetMaster(NULL);
        clusterBumpConfigEpochWithoutConsensus();
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE | CLUSTER_TODO_SAVE_CONFIG);

        serverLog(LL_WARNING, "Failover election won: I'm the new master.");
    }
}
```

**定理 6.1**：故障转移的时间复杂度为O(k)，其中k为从节点数。

**证明**：

- 选择最优从节点：O(k log k)（排序）
- 提升为主节点：O(1)
- 重新配置其他从节点：O(k)
- 总时间复杂度：O(k log k)

### 6.3 槽位迁移

**槽位迁移流程**：

1. 标记源节点为迁移中
2. 标记目标节点为导入中
3. 迁移数据
4. 更新槽位映射
5. 广播新配置

## 7. 性能分析

### 7.1 性能特征

**优势**：

| 特性 | 说明 |
|------|------|
| **水平扩展** | 支持1000+节点 |
| **高可用** | 自动故障转移 |
| **无单点** | 无中心节点 |

**劣势**：

| 特性 | 说明 |
|------|------|
| **复杂度** | 配置和维护复杂 |
| **跨槽操作** | 不支持多key操作 |
| **客户端** | 需要支持集群协议 |

### 7.2 性能指标

**性能指标**：

- **吞吐量**：线性扩展，节点数增加，吞吐量增加
- **延迟**：O(1)路由，延迟低
- **可用性**：99.9%+（3个9）

## 8. 配置与使用

### 8.1 集群配置

```conf
# redis.conf
port 7000
cluster-enabled yes
cluster-config-file nodes-7000.conf
cluster-node-timeout 5000
appendonly yes
```

### 8.2 创建集群

```bash
# 创建集群
redis-cli --cluster create \
  127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \
  127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
  --cluster-replicas 1

# 检查集群状态
redis-cli --cluster check 127.0.0.1:7000
```

## 9. 适用场景

### 9.1 优势场景

1. **水平扩展**：需要水平扩展的场景
2. **高可用**：需要高可用的场景
3. **大数据量**：数据量超过单机内存的场景

### 9.2 不适用场景

1. **简单场景**：数据量较小，不需要集群
2. **跨槽操作**：需要多key操作的场景

## 10. 程序设计分析

### 10.1 设计模式应用

**使用的设计模式**：

1. **集群模式**：多个节点组成集群
2. **状态模式**：节点状态（正常、故障、迁移）
3. **观察者模式**：集群拓扑变化通知
4. **路由模式**：客户端路由和服务端路由

**集群模式实现**：

```c
// 集群节点结构
typedef struct clusterNode {
    char nodename[CLUSTER_NAMELEN];
    int flags;  // 节点标志（主节点、从节点等）
    uint64_t configEpoch;
    unsigned char slots[CLUSTER_SLOTS/8];
    list *fail_reports;
    clusterLink *link;
} clusterNode;
```

### 10.2 代码结构分析

**代码组织**：

1. **节点层**：集群节点管理
2. **路由层**：路由机制实现
3. **通信层**：Gossip协议实现
4. **故障层**：故障检测和转移

**模块化设计**：

- **高内聚**：集群相关功能集中在同一模块
- **低耦合**：通过协议交互，减少依赖
- **可扩展**：易于添加新的集群功能

### 10.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 一致性** | 最终一致性 | 平衡性能和一致性 |
| **简单 vs 复杂** | Gossip协议 | 支持动态拓扑 |
| **通用 vs 专用** | 通用集群实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{consistency} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（Gossip开销，路由开销）
- $C_{consistency}$：一致性成本（最终一致性）
- $C_{complexity}$：复杂度成本（Gossip协议，复杂度高）

### 10.4 可扩展性分析

**扩展点**：

1. **新路由算法**：可扩展为其他路由算法
2. **新通信协议**：可扩展为其他通信协议
3. **跨集群支持**：可扩展为跨集群支持

**扩展性设计**：

```c
// 可扩展的集群接口
typedef struct cluster_manager {
    clusterNode **nodes;
    routing_table_t *routing_table;
    gossip_protocol_t *gossip;
    int (*route)(struct cluster_manager *mgr, const char *key);
} cluster_manager_t;
```

**可维护性**：

- **代码清晰**：集群逻辑清晰，易于理解
- **易于调试**：集群状态易于监控和调试
- **测试友好**：集群行为易于测试和验证

## 11. 扩展阅读

- [主从复制机制](./03.03.01-主从复制机制.md)
- [Sentinel哨兵机制](./03.03.02-Sentinel哨兵机制.md)
- [高可用架构总览](../README.md)

## 12. 权威参考

### 12.1 官方文档

1. **Redis源码 - cluster.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/cluster.c>
   - 版本: Redis 3.0+
   - Cluster的完整实现源码

2. **Redis官方文档 - Scaling**
   - URL: <https://redis.io/docs/manual/scaling/>
   - 版本: Redis 7.0+
   - Cluster的官方文档

### 12.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第16章：Cluster（详细分析Cluster实现）

2. **《Redis深度历险：核心原理与应用实践》** - 钱文品
   - 出版社: 电子工业出版社
   - ISBN: 978-7121356128
   - 第6章：Redis Cluster（Cluster应用）

### 12.3 在线资源

1. **Wikipedia - Consistent Hashing**
   - URL: <https://en.wikipedia.org/wiki/Consistent_hashing>
   - 提供一致性哈希的详细说明
