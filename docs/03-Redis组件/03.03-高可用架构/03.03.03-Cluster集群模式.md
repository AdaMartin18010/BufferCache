# 03.03.03 Cluster集群模式

## 概述

Redis Cluster是Redis的分布式解决方案，通过数据分片和节点间通信实现水平扩展和高可用。Cluster模式支持自动故障转移和动态扩缩容。

## 核心设计

### 数据分片

Redis Cluster采用**哈希槽（Hash Slot）**机制进行数据分片：

- **总槽数**：16384个槽位
- **槽分配**：每个节点负责一部分槽位
- **数据路由**：`CRC16(key) % 16384` 计算槽位

### 架构拓扑

```
┌─────────────┐         ┌─────────────┐
│  Node 1     │────────▶│  Node 2     │
│  Slot:0-5460│         │  Slot:5461- │
│  Master     │         │  10922      │
└─────────────┘         │  Master     │
      │                  └─────────────┘
      │                        │
      │                        │
┌─────────────┐         ┌─────────────┐
│  Node 1-S   │         │  Node 2-S   │
│  Slave      │         │  Slave      │
└─────────────┘         └─────────────┘
      │                        │
      └────────┬───────────────┘
               │
      ┌─────────────┐
      │  Node 3     │
      │  Slot:10923-│
      │  16383      │
      │  Master     │
      └─────────────┘
```

## 数据结构设计

### 集群节点结构

```c
// 集群节点
typedef struct clusterNode {
    mstime_t ctime;              // 创建时间
    char name[REDIS_CLUSTER_NAMELEN]; // 节点ID
    int flags;                   // 节点标志
    uint64_t configEpoch;        // 配置纪元
    char ip[REDIS_IP_STR_LEN];   // IP地址
    int port;                    // 端口
    clusterLink *link;           // 连接信息
    unsigned char slots[CLUSTER_SLOTS/8]; // 槽位位图
    int numslots;                // 负责的槽位数
    int numslaves;               // 从节点数
    struct clusterNode **slaves; // 从节点数组
    struct clusterNode *slaveof; // 主节点指针
    list *fail_reports;          // 故障报告列表
} clusterNode;

// 集群状态
typedef struct clusterState {
    clusterNode *myself;         // 当前节点
    uint64_t currentEpoch;      // 当前配置纪元
    int state;                   // 集群状态
    int size;                    // 主节点数
    dict *nodes;                 // 节点字典
    clusterNode *slots[CLUSTER_SLOTS]; // 槽位映射
    zskiplist *slots_to_keys;    // 槽位到key的映射
} clusterState;
```

## 槽位分配

### 槽位计算

```c
// 计算key的槽位
unsigned int keyHashSlot(char *key, int keylen) {
    int s, e;

    // 查找{...}标签
    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    if (s == keylen) return crc16(key, keylen) & 0x3FFF;

    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    if (e == keylen || e == s+1) return crc16(key, keylen) & 0x3FFF;

    // 使用标签计算槽位
    return crc16(key+s+1, e-s-1) & 0x3FFF;
}

// 示例
// key = "user:{1001}:profile"
// hash tag = "1001"
// slot = CRC16("1001") % 16384
```

### 槽位迁移

```c
// 槽位迁移
void clusterSetSlot(clusterNode *n, int slot, clusterNode *sender) {
    clusterNode *old = server.cluster->slots[slot];

    if (old == n) return;

    if (old != NULL) {
        // 从旧节点移除槽位
        if (old->numslots == 1) {
            // 节点不再负责任何槽位
            clusterDelNode(old);
        } else {
            // 更新位图
            bitmapClearBit(old->slots, slot);
            old->numslots--;
        }
    }

    // 分配给新节点
    if (n != NULL) {
        bitmapSetBit(n->slots, slot);
        n->numslots++;
    }

    server.cluster->slots[slot] = n;
}
```

## 节点通信

### Gossip协议

```c
// Gossip消息格式
typedef struct {
    char sig[4];                 // 签名"RCmb"
    uint32_t totlen;             // 消息总长度
    uint16_t ver;                // 协议版本
    uint16_t port;               // TCP端口
    uint16_t type;               // 消息类型
    uint16_t count;              // 消息体数量
    uint64_t currentEpoch;       // 当前配置纪元
    uint64_t configEpoch;        // 配置纪元
    uint64_t offset;             // 复制偏移量
    char sender[REDIS_CLUSTER_NAMELEN]; // 发送者ID
    unsigned char myslots[CLUSTER_SLOTS/8]; // 槽位位图
    char slaveof[REDIS_CLUSTER_NAMELEN]; // 主节点ID
    char myip[REDIS_IP_STR_LEN]; // IP地址
    uint16_t cport;              // 集群端口
    uint16_t flags;              // 节点标志
    unsigned char state;         // 集群状态
    unsigned char mflags[3];    // 消息标志
    union clusterMsgData data;   // 消息数据
} clusterMsg;
```

### 心跳机制

```c
// 发送心跳
void clusterSendPing(clusterLink *link, int type) {
    unsigned char buf[sizeof(clusterMsg)];
    clusterMsg *hdr = (clusterMsg *)buf;
    int gossipcount = 0, totlen;
    clusterNode *node;
    dictIterator *di;
    dictEntry *de;

    // 构建消息头
    clusterBuildMessageHdr(hdr, type);

    // 添加Gossip信息
    di = dictGetSafeIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL && gossipcount < 3) {
        node = dictGetVal(de);
        if (node->flags & (REDIS_NODE_HANDSHAKE|REDIS_NODE_NOADDR)) continue;
        if (node->flags & REDIS_NODE_PFAIL) continue;

        clusterMsgDataGossip *gossip = &(hdr->data.ping.gossip[gossipcount]);
        gossip->nodename = node->name;
        gossip->ping_sent = node->ping_sent;
        gossip->pong_received = node->pong_received;
        gossip->flags = node->flags;
        gossip->port = htons(node->port);
        gossip->cport = htons(node->cport);
        memcpy(gossip->ip, node->ip, sizeof(gossip->ip));
        gossipcount++;
    }
    dictReleaseIterator(di);

    hdr->count = htons(gossipcount);
    totlen = sizeof(clusterMsg) - sizeof(union clusterMsgData) +
             (sizeof(clusterMsgDataGossip) * gossipcount);
    hdr->totlen = htonl(totlen);

    // 发送消息
    clusterSendMessage(link, (unsigned char *)buf, totlen);
}
```

## 故障检测

### 故障检测流程

```c
// 故障检测
void clusterCron(void) {
    dictIterator *di;
    dictEntry *de;
    clusterNode *node;
    mstime_t now = mstime();
    mstime_t min_ping = 0;

    // 检查所有节点
    di = dictGetIterator(server.cluster->nodes);
    while((de = dictNext(di)) != NULL) {
        node = dictGetVal(de);

        // 跳过自己
        if (node->flags & REDIS_NODE_MYSELF) continue;

        // 检查PING超时
        if (node->link && node->ping_sent != 0) {
            mstime_t ping_delay = now - node->ping_sent;

            if (ping_delay > server.cluster_node_timeout) {
                // PING超时，标记为疑似故障
                if (!(node->flags & REDIS_NODE_PFAIL)) {
                    node->flags |= REDIS_NODE_PFAIL;
                    clusterSendFail(node->name);
                }
            }
        }

        // 发送PING
        if (node->link && node->ping_sent == 0) {
            clusterSendPing(node->link, CLUSTERMSG_TYPE_PING);
            node->ping_sent = now;
        }
    }
    dictReleaseIterator(di);

    // 检查故障报告
    clusterCheckFailover();
}
```

### 故障转移

```c
// 故障转移
void clusterHandleSlaveFailover(void) {
    mstime_t data_age;
    mstime_t auth_age = mstime() - server.cluster->failover_auth_time;
    mstime_t master_since = mstime() - server.cluster->failover_auth_sent;
    clusterNode *master = server.cluster->myself->slaveof;

    // 检查主节点是否真的下线
    if (master == NULL) return;

    // 检查数据新鲜度
    data_age = (mstime() - server.cluster->failover_auth_time) +
               (master->ping_sent ? (mstime() - master->ping_sent) : 0);

    if (data_age > server.cluster->cluster_node_timeout * 2) {
        // 数据太旧，取消故障转移
        return;
    }

    // 检查是否获得足够投票
    if (server.cluster->failover_auth_count >= server.cluster->failover_auth_quorum) {
        // 开始故障转移
        server.cluster->failover_auth_time = 0;
        server.cluster->failover_auth_count = 0;
        server.cluster->failover_auth_sent = 0;
        server.cluster->failover_auth_rank = 0;
        server.cluster->failover_auth_epoch = server.cluster->currentEpoch;

        // 提升自己为主节点
        clusterSetMaster(NULL);
        clusterBumpConfigEpochWithoutConsensus();
        clusterDoBeforeSleep(CLUSTER_TODO_UPDATE_STATE | CLUSTER_TODO_SAVE_CONFIG);

        serverLog(LL_WARNING, "Failover election won: I'm the new master.");
    }
}
```

## 客户端路由

### MOVED重定向

```c
// MOVED重定向处理
void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
    if (error_code == CLUSTER_REDIR_MOVED || error_code == CLUSTER_REDIR_ASK) {
        addReplySds(c, sdscatprintf(sdsempty(),
            "-%s %d %s:%d\r\n",
            (error_code == CLUSTER_REDIR_MOVED) ? "MOVED" : "ASK",
            hashslot, n->ip, n->port));
    } else {
        addReplySds(c, sdsnew("-CLUSTERDOWN The cluster is down\r\n"));
    }
}
```

### ASK重定向

```c
// ASK重定向（槽位迁移中）
void clusterSendAsk(client *c, clusterNode *n, int hashslot) {
    // 发送ASK重定向
    addReplySds(c, sdscatprintf(sdsempty(),
        "-ASK %d %s:%d\r\n",
        hashslot, n->ip, n->port));

    // 客户端需要先发送ASKING命令
}
```

## 槽位迁移

### 迁移流程

```c
// 槽位迁移
void clusterMigrateSlot(clusterNode *source, clusterNode *target,
                       int slot, int options) {
    int migrating = 0, importing = 0;

    // 1. 标记源节点为迁移中
    source->migrating_slots[slot] = target;
    migrating = 1;

    // 2. 标记目标节点为导入中
    target->importing_slots[slot] = source;
    importing = 1;

    // 3. 发送CLUSTER SETSLOT命令
    clusterSendSetSlot(target, slot, CLUSTER_SLOT_MIGRATING);
    clusterSendSetSlot(source, slot, CLUSTER_SLOT_IMPORTING);

    // 4. 迁移数据
    clusterMigrateKeys(source, target, slot);

    // 5. 更新槽位映射
    clusterSetSlot(target, slot, NULL);
    clusterSetSlot(source, slot, NULL);

    // 6. 广播新配置
    clusterBroadcastPong(CLUSTER_BROADCAST_ALL);
}
```

## 配置示例

### 集群配置

```conf
# redis.conf
port 7000
cluster-enabled yes
cluster-config-file nodes-7000.conf
cluster-node-timeout 5000
appendonly yes
```

### 创建集群

```bash
# 创建集群
redis-cli --cluster create \
  127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \
  127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
  --cluster-replicas 1

# 检查集群状态
redis-cli --cluster check 127.0.0.1:7000
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **水平扩展** | 支持1000+节点 |
| **高可用** | 自动故障转移 |
| **无单点** | 无中心节点 |

### 劣势

| 特性 | 说明 |
|------|------|
| **复杂度** | 配置和维护复杂 |
| **跨槽操作** | 不支持多key操作 |
| **客户端** | 需要支持集群协议 |

## 扩展阅读

- [主从复制机制](./03.03.01-主从复制机制.md)
- [Sentinel哨兵机制](./03.03.02-Sentinel哨兵机制.md)
- [高可用架构总览](../README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/scaling/>
