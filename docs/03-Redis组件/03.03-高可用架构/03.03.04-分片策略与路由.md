# 03.03.04 分片策略与路由

## 目录

- [03.03.04 分片策略与路由](#030304-分片策略与路由)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 分片策略](#2-分片策略)
    - [2.1 哈希分片](#21-哈希分片)
    - [2.2 一致性哈希](#22-一致性哈希)
    - [2.3 范围分片](#23-范围分片)
    - [2.4 形式化定义](#24-形式化定义)
  - [3. Redis Cluster分片](#3-redis-cluster分片)
    - [3.1 Slot分片](#31-slot分片)
    - [3.2 Slot分配](#32-slot分配)
    - [3.3 Hash Tag](#33-hash-tag)
  - [4. 路由机制](#4-路由机制)
    - [4.1 客户端路由](#41-客户端路由)
    - [4.2 服务端路由](#42-服务端路由)
    - [4.3 路由表更新](#43-路由表更新)
  - [5. 性能分析](#5-性能分析)
    - [5.1 分片策略对比](#51-分片策略对比)
    - [5.2 Slot迁移分析](#52-slot迁移分析)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 分片设计建议](#61-分片设计建议)
    - [2. 迁移优化](#2-迁移优化)
  - [分片策略对比](#分片策略对比)
    - [1. 哈希分片 vs 一致性哈希](#1-哈希分片-vs-一致性哈希)
    - [2. Slot分片优势](#2-slot分片优势)
  - [最佳实践](#最佳实践)
    - [1. 分片设计](#1-分片设计)
    - [6.2 路由优化](#62-路由优化)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 经典书籍](#82-经典书籍)
    - [8.3 在线资源](#83-在线资源)

---

## 1. 概述

### 1.1 定义与背景

分片（Sharding）是Redis实现水平扩展的关键技术，通过将数据分散到多个节点，突破单机内存限制。理解分片策略和路由算法对于设计和优化Redis集群架构至关重要。

**分片背景**：

- **单机限制**：单机内存有限
- **水平扩展**：需要水平扩展
- **数据分布**：需要均匀分布数据

### 1.2 应用价值

分片策略在Redis中具有重要价值：

1. **水平扩展**：突破单机内存限制
2. **负载均衡**：均匀分布数据
3. **高可用**：支持故障转移
4. **动态扩缩容**：支持动态添加/删除节点

## 2. 分片策略

### 2.1 哈希分片

```c
// 哈希分片
// 1. 对key进行哈希
// 2. 取模确定节点
// 3. 简单但扩展性差

// 哈希分片实现
int hashShard(const char *key, int node_count) {
    unsigned int hash = hashFunction(key);
    return hash % node_count;
}
```

**哈希分片**：

- **优点**：实现简单，分布均匀
- **缺点**：节点增减时数据迁移量大

### 2.2 一致性哈希

```c
// 一致性哈希
// 1. 将节点映射到哈希环
// 2. key映射到最近的节点
// 3. 支持动态扩缩容

// 一致性哈希实现
int consistentHashShard(const char *key, int node_count) {
    unsigned int hash = hashFunction(key);
    unsigned int node_hash = hashFunction(node_id);

    // 找到最近的节点
    int node = findNearestNode(hash, node_hash, node_count);
    return node;
}
```

**一致性哈希**：

- **优点**：节点增减时数据迁移量小
- **缺点**：需要虚拟节点保证负载均衡

### 2.3 范围分片

```c
// 范围分片
// 1. 按key范围分片
// 2. 支持范围查询
// 3. 数据分布可能不均匀

// 范围分片实现
int rangeShard(const char *key, int node_count) {
    // 按key范围分片
    int range_size = MAX_KEY / node_count;
    int shard = atoi(key) / range_size;
    return shard;
}
```

**范围分片**：

- **优点**：支持范围查询
- **缺点**：数据分布可能不均匀

### 2.4 形式化定义

设节点集合为$N = \{n_1, n_2, ..., n_k\}$，数据项为$d$。

**哈希分片**：

$$Shard(d) = hash(d) \bmod k$$

**一致性哈希**：

$$Shard(d) = \arg\min_{n_i \in N} \{hash(n_i) | hash(n_i) \geq hash(d)\}$$

**范围分片**：

$$Shard(d) = \lfloor \frac{d}{range\_size} \rfloor$$

## 3. Redis Cluster分片

### 3.1 Slot分片

```c
// Redis Cluster使用16384个slot
// 1. 每个key映射到一个slot
// 2. 每个节点负责一部分slot
// 3. 支持slot迁移

// Slot计算
unsigned int keyHashSlot(char *key, int keylen) {
    int s, e;

    // 查找{...}中的内容（hash tag）
    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    if (s == keylen) return crc16(key, keylen) & 0x3FFF;

    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    if (e == keylen || e == s+1) return crc16(key, keylen) & 0x3FFF;

    return crc16(key+s+1, e-s-1) & 0x3FFF;
}
```

**定理 3.1**：Slot分片的时间复杂度为O(1)。

**证明**：

- CRC16计算：O(1)
- 取模运算：O(1)
- 总时间复杂度：O(1)

### 3.2 Slot分配

```c
// Slot分配
// 1. 16384个slot平均分配
// 2. 每个节点负责约16384/N个slot
// 3. 支持手动分配

// Slot分配结构
typedef struct clusterNode {
    unsigned char slots[16384/8];  // Slot位图
    int numslots;                   // Slot数量
    // ...
} clusterNode;
```

**Slot分配**：

- **16384个slot平均分配**：每个节点负责约$\frac{16384}{N}$个slot
- **支持手动分配**：可以手动指定slot分配

### 3.3 Hash Tag

```c
// Hash Tag
// 1. 使用{tag}强制相同tag的key映射到同一slot
// 2. 支持多key操作
// 3. 保证数据局部性

// Hash Tag示例
// user:{1001}:name -> slot(user:1001)
// user:{1001}:age -> slot(user:1001)
// 保证同一用户的数据在同一节点
```

**Hash Tag**：

- **使用{tag}强制相同tag的key映射到同一slot**：保证数据局部性
- **支持多key操作**：同一tag的key在同一节点
- **保证数据局部性**：相关数据在同一节点

## 4. 路由机制

### 4.1 客户端路由

```c
// 客户端路由
// 1. 客户端计算slot
// 2. 查询slot到节点的映射
// 3. 直接连接目标节点

// 客户端路由实现
clusterNode *getNodeBySlot(int slot) {
    // 查询slot映射表
    return slotToNode[slot];
}

// 发送命令
void clusterSendCommand(client *c, int slot) {
    clusterNode *node = getNodeBySlot(slot);
    sendCommandToNode(node, c->argv, c->argc);
}
```

**客户端路由**：

- **客户端计算slot**：减少服务端负担
- **查询slot到节点的映射**：使用路由表
- **直接连接目标节点**：减少跳转

**定理 4.1**：客户端路由的时间复杂度为O(1)。

**证明**：

- 计算slot：O(1)
- 查询路由表：O(1)（哈希表）
- 总时间复杂度：O(1)

### 4.2 服务端路由

```c
// 服务端路由（MOVED/ASK重定向）
// 1. 节点接收命令
// 2. 检查slot是否属于自己
// 3. 如果不属于，返回MOVED/ASK重定向

// MOVED重定向
void clusterRedirectClient(client *c, clusterNode *n, int hashslot, int error_code) {
    if (error_code == CLUSTER_REDIR_MOVED) {
        addReplyErrorFormat(c, "MOVED %d %s:%d",
                           hashslot, n->ip, n->port);
    } else if (error_code == CLUSTER_REDIR_ASK) {
        addReplyErrorFormat(c, "ASK %d %s:%d",
                           hashslot, n->ip, n->port);
    }
}
```

**服务端路由**：

- **MOVED重定向**：slot已迁移到其他节点
- **ASK重定向**：slot正在迁移中

### 4.3 路由表更新

```c
// 路由表更新
// 1. 节点加入/离开时更新
// 2. Slot迁移时更新
// 3. 故障转移时更新

// 更新路由表
void clusterUpdateSlotsConfig(void) {
    // 1. 更新slot映射
    // 2. 通知客户端
    // 3. 更新集群状态
}
```

**路由表更新时机**：

- **节点加入/离开时**：更新slot映射
- **Slot迁移时**：更新slot映射
- **故障转移时**：更新slot映射

## 5. 性能分析

### 5.1 分片策略对比

**分片策略对比**：

| 维度 | 哈希分片 | 一致性哈希 | Slot分片 |
|------|----------|------------|----------|
| **扩展性** | 差（需要rehash） | 好（只影响部分数据） | 好（支持slot迁移） |
| **实现复杂度** | 简单 | 中等 | 中等 |
| **数据分布** | 均匀 | 可能不均匀 | 均匀 |
| **路由性能** | O(1) | O(log N) | O(1) |

**定理 5.1**：Slot分片在扩展性、数据分布和路由性能方面表现最优。

**证明**：

- 扩展性：支持slot迁移，只影响部分数据
- 数据分布：16384个slot保证均匀分布
- 路由性能：O(1)时间复杂度

### 5.2 Slot迁移分析

**迁移流程**：

1. 源节点标记slot为MIGRATING
2. 目标节点标记slot为IMPORTING
3. 迁移数据
4. 更新路由表

**迁移优化**：

- **批量迁移key**：减少网络开销
- **异步迁移**：不阻塞服务
- **迁移过程中继续服务**：保证可用性

## 6. 最佳实践

### 6.1 分片设计建议

```c
// Slot迁移流程
// 1. 源节点标记slot为MIGRATING
// 2. 目标节点标记slot为IMPORTING
// 3. 迁移数据
// 4. 更新路由表

// 迁移命令
void clusterSetSlotMigrating(int slot, clusterNode *target) {
    server.cluster->migrating_slots_to[slot] = target;
}

void clusterSetSlotImporting(int slot, clusterNode *source) {
    server.cluster->importing_slots_from[slot] = source;
}
```

### 2. 迁移优化

```c
// 迁移优化
// 1. 批量迁移key
// 2. 异步迁移
// 3. 迁移过程中继续服务

// 批量迁移
void migrateKeysInSlot(int slot, clusterNode *target) {
    // 1. 获取slot中的所有key
    // 2. 批量迁移
    // 3. 更新路由表
}
```

## 分片策略对比

### 1. 哈希分片 vs 一致性哈希

| 维度 | 哈希分片 | 一致性哈希 |
|------|----------|------------|
| **扩展性** | 差（需要rehash） | 好（只影响部分数据） |
| **实现复杂度** | 简单 | 中等 |
| **数据分布** | 均匀 | 可能不均匀 |

### 2. Slot分片优势

```python
# Slot分片优势
class SlotSharding:
    def advantages(self):
        return {
            'fixed_slots': '16384个固定slot',
            'easy_migration': '支持slot迁移',
            'hash_tag': '支持hash tag',
            'rebalancing': '支持动态重平衡',
        }
```

## 最佳实践

### 1. 分片设计

```python
# 分片设计建议
class ShardingDesign:
    def recommend(self):
        return {
            'slot_count': '16384（Redis Cluster标准）',
            'node_count': '3-100个节点',
            'replica_factor': '每个分片2-3个副本',
            'hash_tag': '使用hash tag保证数据局部性',
        }
```

**分片设计建议**：

- **Slot数量**：16384（Redis Cluster标准）
- **节点数量**：3-100个节点
- **副本因子**：每个分片2-3个副本
- **Hash Tag**：使用hash tag保证数据局部性

### 6.2 路由优化

```c
// 路由优化
// 1. 客户端缓存路由表
// 2. 批量操作使用pipeline
// 3. 使用hash tag减少跨节点操作
```

**路由优化建议**：

- **客户端缓存路由表**：减少查询次数
- **批量操作使用pipeline**：减少网络开销
- **使用hash tag减少跨节点操作**：提高性能

## 7. 扩展阅读

- [Cluster集群模式](./03.03.03-Cluster集群模式.md)
- [一致性哈希原理](../../01-理论基础/01.03-分布式缓存算法/01.03.01-一致性哈希原理.md)
- [虚拟节点优化](../../01-理论基础/01.03-分布式缓存算法/01.03.02-虚拟节点优化.md)

## 8. 权威参考

### 8.1 官方文档

1. **Redis源码 - cluster.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/cluster.c>
   - 版本: Redis 3.0+
   - Cluster分片的完整实现源码

2. **Redis官方文档 - Scaling**
   - URL: <https://redis.io/docs/manual/scaling/>
   - 版本: Redis 7.0+
   - Cluster的官方文档

### 8.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第16章：Cluster（分片策略详解）

2. **《大规模分布式存储系统：原理解析与架构实战》** - 杨传辉
   - 出版社: 机械工业出版社
   - ISBN: 978-7111421900
   - 第3章：分布式哈希（分片策略详解）

### 8.3 在线资源

1. **Wikipedia - Sharding**
   - URL: <https://en.wikipedia.org/wiki/Shard_(database_architecture)>
   - 提供分片的详细说明
