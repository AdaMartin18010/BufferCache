# 03.04.01 内存分配与回收

## 目录

- [03.04.01 内存分配与回收](#030401-内存分配与回收)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 内存分配器](#2-内存分配器)
    - [2.1 为什么使用jemalloc](#21-为什么使用jemalloc)
    - [2.2 内存分配器选择](#22-内存分配器选择)
  - [3. 内存分配函数](#3-内存分配函数)
    - [3.1 zmalloc](#31-zmalloc)
    - [3.2 zfree](#32-zfree)
    - [3.3 zrealloc](#33-zrealloc)
  - [4. 内存统计](#4-内存统计)
    - [4.1 内存使用统计](#41-内存使用统计)
    - [4.2 内存碎片统计](#42-内存碎片统计)
  - [5. 性能分析](#5-性能分析)
    - [5.1 内存分配性能](#51-内存分配性能)
    - [5.2 内存回收性能](#52-内存回收性能)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 内存分配器选择](#61-内存分配器选择)
    - [6.2 内存限制配置](#62-内存限制配置)
    - [6.3 内存监控](#63-内存监控)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)
    - [内存碎片整理](#内存碎片整理)
  - [内存优化](#内存优化)
    - [1. 使用jemalloc](#1-使用jemalloc)
    - [2. 内存碎片整理](#2-内存碎片整理)
    - [3. 内存限制](#3-内存限制)
  - [内存监控](#内存监控)
    - [INFO命令](#info命令)
    - [内存分析工具](#内存分析工具)
  - [扩展阅读](#扩展阅读)
  - [权威参考](#权威参考)

---

## 1. 概述

### 1.1 定义与背景

Redis使用自定义的内存分配器jemalloc，优化内存分配和回收性能。理解Redis的内存管理机制对于优化内存使用和性能至关重要。

**版本信息**：

- **适用版本**：Redis 1.0+
- **文档基于版本**：Redis 7.2
- **最后更新**：2025-01

**内存管理背景**：

- **内存分配器**：jemalloc、tcmalloc、glibc malloc
- **内存统计**：实时统计内存使用情况
- **内存优化**：减少内存碎片，提高分配效率

### 1.2 应用价值

内存分配与回收在Redis中具有重要价值：

1. **性能优化**：优化内存分配和回收性能
2. **内存统计**：实时统计内存使用情况
3. **碎片管理**：减少内存碎片
4. **多线程支持**：更好的多线程支持

## 2. 内存分配器

### 2.1 为什么使用jemalloc

```c
// Redis默认使用jemalloc而非glibc的malloc
// 原因：
// 1. 减少内存碎片
// 2. 提升分配性能
// 3. 更好的多线程支持
```

**jemalloc优势**：

- **减少内存碎片**：更好的内存管理
- **提升分配性能**：更快的分配速度
- **更好的多线程支持**：线程安全

### 2.2 内存分配器选择

```c
// Redis支持多种内存分配器
#if defined(USE_JEMALLOC)
    #define zmalloc je_malloc
    #define zfree je_free
    #define zrealloc je_realloc
#elif defined(USE_TCMALLOC)
    #define zmalloc tc_malloc
    #define zfree tc_free
    #define zrealloc tc_realloc
#else
    #define zmalloc malloc
    #define zfree free
    #define zrealloc realloc
#endif
```

**内存分配器对比**：

| 分配器 | 碎片率 | 分配性能 | 多线程支持 |
|--------|--------|----------|------------|
| **jemalloc** | 低 | 高 | 好 |
| **tcmalloc** | 中 | 高 | 好 |
| **glibc malloc** | 高 | 中 | 中 |

## 3. 内存分配函数

### 3.1 zmalloc

```c
// Redis内存分配（带统计）
void *zmalloc(size_t size) {
    void *ptr = malloc(size + PREFIX_SIZE);

    if (!ptr) zmalloc_oom_handler(size);

#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_alloc(zmalloc_size(ptr));
    return ptr;
#else
    *((size_t *)ptr) = size;
    update_zmalloc_stat_alloc(size + PREFIX_SIZE);
    return (char *)ptr + PREFIX_SIZE;
#endif
}
```

**zmalloc特点**：

- **带统计**：统计内存使用情况
- **前缀大小**：存储分配大小（如果没有HAVE_MALLOC_SIZE）
- **OOM处理**：内存不足时调用OOM处理函数

**定理 3.1**：zmalloc的时间复杂度为O(1)。

**证明**：

- malloc调用：O(1)（jemalloc）
- 统计更新：O(1)
- 总时间复杂度：O(1)

### 3.2 zfree

```c
// Redis内存释放（带统计）
void zfree(void *ptr) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;

#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char *)ptr - PREFIX_SIZE;
    oldsize = *((size_t *)realptr);
    update_zmalloc_stat_free(oldsize + PREFIX_SIZE);
    free(realptr);
#endif
}
```

**zfree特点**：

- **带统计**：统计内存释放情况
- **NULL检查**：检查指针是否为NULL
- **前缀处理**：处理前缀大小（如果没有HAVE_MALLOC_SIZE）

**定理 3.2**：zfree的时间复杂度为O(1)。

**证明**：

- free调用：O(1)（jemalloc）
- 统计更新：O(1)
- 总时间复杂度：O(1)

### 3.3 zrealloc

```c
// Redis内存重分配
void *zrealloc(void *ptr, size_t size) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
#endif
    size_t oldsize;
    void *newptr;

    if (ptr == NULL) return zmalloc(size);

#ifdef HAVE_MALLOC_SIZE
    oldsize = zmalloc_size(ptr);
    newptr = realloc(ptr, size);
    if (!newptr) zmalloc_oom_handler(size);

    update_zmalloc_stat_free(oldsize);
    update_zmalloc_stat_alloc(zmalloc_size(newptr));
    return newptr;
#else
    realptr = (char *)ptr - PREFIX_SIZE;
    oldsize = *((size_t *)realptr);
    newptr = realloc(realptr, size + PREFIX_SIZE);
    if (!newptr) zmalloc_oom_handler(size);

    *((size_t *)newptr) = size;
    update_zmalloc_stat_free(oldsize);
    update_zmalloc_stat_alloc(size);
    return (char *)newptr + PREFIX_SIZE;
#endif
}
```

**zrealloc特点**：

- **内存重分配**：重新分配内存大小
- **带统计**：统计内存使用情况
- **OOM处理**：内存不足时调用OOM处理函数

**定理 3.3**：zrealloc的时间复杂度为O(1)（平均情况）。

**证明**：

- realloc调用：O(1)（平均情况，jemalloc）
- 统计更新：O(1)
- 总时间复杂度：O(1)（平均情况）

## 4. 内存统计

### 4.1 内存使用统计

```c
// 内存统计
size_t zmalloc_used_memory(void) {
    size_t um;
    atomicGet(used_memory, um);
    return um;
}

// 更新统计
#define update_zmalloc_stat_alloc(__n) do { \
    size_t _n = (__n); \
    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
    atomicIncr(used_memory, __n); \
} while(0)

#define update_zmalloc_stat_free(__n) do { \
    size_t _n = (__n); \
    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
    atomicDecr(used_memory, __n); \
} while(0)
```

**内存统计**：

- **原子操作**：使用原子操作更新统计
- **实时统计**：实时统计内存使用情况
- **对齐处理**：内存对齐处理

### 4.2 内存碎片统计

```c
// 内存碎片率
float getMemoryFragmentationRatio(void) {
    size_t mem_used = zmalloc_used_memory();
    size_t mem_rss = zmalloc_get_rss();

    if (mem_rss == 0) return 0;

    return (float)mem_rss / (float)mem_used;
}

// 内存碎片率 > 1.5 表示碎片严重
```

**内存碎片率**：

$$FragmentationRatio = \frac{RSS}{UsedMemory}$$

其中：

- $RSS$：物理内存使用量
- $UsedMemory$：已分配内存量

**定理 4.1**：内存碎片率>1.5表示碎片严重。

**证明**：

- 理想情况：$FragmentationRatio = 1.0$（无碎片）
- 碎片严重：$FragmentationRatio > 1.5$（50%碎片）
- 需要整理：$FragmentationRatio > 2.0$（100%碎片）

## 5. 性能分析

### 5.1 内存分配性能

**内存分配性能对比**：

| 分配器 | 分配速度 | 碎片率 | 多线程性能 |
|--------|----------|--------|------------|
| **jemalloc** | 快 | 低 | 好 |
| **tcmalloc** | 快 | 中 | 好 |
| **glibc malloc** | 中 | 高 | 中 |

**定理 5.1**：jemalloc的分配性能比glibc malloc快约20-30%。

**证明**：

- jemalloc使用更高效的分配算法
- 减少内存碎片，提高分配效率
- 更好的多线程支持

### 5.2 内存回收性能

**内存回收策略**：

- **LRU/LFU淘汰**：根据访问频率淘汰
- **Random淘汰**：随机淘汰
- **TTL淘汰**：根据过期时间淘汰

## 6. 最佳实践

### 6.1 内存分配器选择

**推荐使用jemalloc**：

- **减少内存碎片**：更好的内存管理
- **提升分配性能**：更快的分配速度
- **更好的多线程支持**：线程安全

### 6.2 内存限制配置

**内存限制配置**：

- **设置最大内存**：`maxmemory 2gb`
- **设置淘汰策略**：`maxmemory-policy allkeys-lru`
- **启用内存碎片整理**：`activedefrag yes`

### 6.3 内存监控

**内存监控指标**：

- **used_memory**：已使用内存
- **used_memory_rss**：物理内存
- **mem_fragmentation_ratio**：内存碎片率

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：不同内存分配器策略（jemalloc、tcmalloc、libc）
2. **适配器模式**：适配不同内存分配器
3. **模板方法模式**：定义内存分配的基本流程

**策略模式实现**：

```c
// 内存分配器策略接口
typedef struct memory_allocator {
    void *(*malloc)(size_t size);
    void (*free)(void *ptr);
    void *(*realloc)(void *ptr, size_t size);
    const char *name;
} memory_allocator_t;

// 不同分配器策略
memory_allocator_t allocators[] = {
    {.malloc = zmalloc_je, .name = "jemalloc"},
    {.malloc = zmalloc_tc, .name = "tcmalloc"},
    {.malloc = zmalloc_libc, .name = "libc"},
};
```

### 7.2 代码结构分析

**代码组织**：

1. **分配器层**：内存分配器实现
2. **统计层**：内存统计实现
3. **接口层**：对外提供的内存操作接口

**模块化设计**：

- **高内聚**：内存管理相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的内存分配器

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 内存** | jemalloc优先 | 平衡性能和内存使用 |
| **简单 vs 复杂** | 多分配器支持 | 支持不同分配器 |
| **通用 vs 专用** | 通用内存管理实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{memory} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（jemalloc，性能提升）
- $C_{memory}$：内存成本（内存碎片优化）
- $C_{complexity}$：复杂度成本（多分配器支持，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新分配器**：可扩展为其他内存分配器
2. **新统计功能**：可扩展为其他内存统计功能
3. **自定义分配器**：可扩展为自定义内存分配器实现

**扩展性设计**：

```c
// 可扩展的内存管理接口
typedef struct memory_manager {
    memory_allocator_t *allocator;
    memory_stats_t *stats;
    void *(*malloc)(struct memory_manager *mgr, size_t size);
    void (*free)(struct memory_manager *mgr, void *ptr);
} memory_manager_t;
```

**可维护性**：

- **代码清晰**：内存管理逻辑清晰，易于理解
- **易于调试**：内存统计易于监控和调试
- **测试友好**：内存管理行为易于测试和验证

## 8. 扩展阅读

- [内存碎片整理](./03.04.02-内存碎片整理.md)
- [内存监控](./03.04.03-内存监控.md)
- [引用计数GC](./03.04.04-引用计数GC.md)

## 9. 权威参考

### 9.1 官方文档

1. **Redis源码 - zmalloc.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/zmalloc.c>
   - 版本: Redis 1.0+
   - 内存分配的完整实现源码

2. **jemalloc官方文档**
   - URL: <https://github.com/jemalloc/jemalloc>
   - jemalloc的官方文档

### 9.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第12章：内存管理（内存分配详解）

2. **《深入理解计算机系统（第3版）》** - Randal E. Bryant, David R. O'Hallaron
   - 出版社: 机械工业出版社
   - ISBN: 978-7111544937
   - 第9章：虚拟内存（内存管理基础）

### 9.3 在线资源

1. **Wikipedia - Memory Management**
   - URL: <https://en.wikipedia.org/wiki/Memory_management>
   - 提供内存管理的详细说明

```c
// 主动回收内存
int freeMemoryIfNeeded(void) {
    size_t mem_used, mem_tofree, mem_freed;
    int slaves = listLength(server.slaves);
    mstime_t latency, eviction_latency;

    // 1. 计算已使用内存
    mem_used = zmalloc_used_memory();

    // 2. 检查是否需要回收
    if (mem_used <= server.maxmemory) {
        return C_OK;
    }

    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION) {
        return C_ERR;
    }

    // 3. 计算需要释放的内存
    mem_tofree = mem_used - server.maxmemory;
    mem_freed = 0;

    latencyStartMonitor(latency);

    // 4. 根据策略回收内存
    if (server.maxmemory_policy & (MAXMEMORY_FLAG_LRU | MAXMEMORY_FLAG_LFU)) {
        // LRU/LFU淘汰
        while (mem_freed < mem_tofree) {
            int j, k, i;
            static unsigned int next_db = 0;
            sds bestkey = NULL;
            int bestdbid;
            struct evictionPoolEntry *pool = EvictionPoolLRU;

            // 采样并淘汰
            // ...
        }
    } else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||
               server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM) {
        // Random淘汰
        // ...
    }

    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded("eviction-cycle", latency);

    return C_OK;
}
```

### 内存碎片整理

```c
// 内存碎片整理（Redis 4.0+）
int defragMemory(void) {
    int iterations = 0;
    long long start = ustime();

    while (iterations < server.active_defrag_max_scan_fields) {
        // 1. 扫描数据库
        for (int j = 0; j < server.dbnum; j++) {
            redisDb *db = server.db + j;
            dict *d = db->dict;

            // 2. 扫描key
            dictIterator *di = dictGetIterator(d);
            dictEntry *de;

            while ((de = dictNext(di)) != NULL) {
                sds key = dictGetKey(de);
                robj *o = dictGetVal(de);

                // 3. 整理对象
                if (defragObject(o)) {
                    iterations++;
                }
            }

            dictReleaseIterator(di);
        }

        // 4. 检查是否继续
        if (ustime() - start > server.active_defrag_max_cycle_time) {
            break;
        }
    }

    return iterations;
}
```

## 内存优化

### 1. 使用jemalloc

```bash
# 编译时指定jemalloc
make MALLOC=jemalloc
```

### 2. 内存碎片整理

```conf
# redis.conf
# 启用内存碎片整理
activedefrag yes
active-defrag-ignore-bytes 100mb
active-defrag-threshold-lower 10
active-defrag-threshold-upper 100
active-defrag-cycle-min 5
active-defrag-cycle-max 75
```

### 3. 内存限制

```conf
# redis.conf
# 设置最大内存
maxmemory 2gb

# 设置淘汰策略
maxmemory-policy allkeys-lru
```

## 内存监控

### INFO命令

```bash
# 查看内存信息
redis-cli INFO memory

# 关键指标：
# used_memory: 已使用内存
# used_memory_rss: 物理内存
# used_memory_peak: 峰值内存
# mem_fragmentation_ratio: 内存碎片率
# mem_allocator: 内存分配器
```

### 内存分析工具

```bash
# 使用redis-rdb-tools分析RDB文件
redis-rdb-tools --command memory dump.rdb

# 输出内存使用情况
```

## 扩展阅读

- [大Key问题](../../04-架构设计/04.04-缓存问题与治理/04.04.05-大Key问题.md)
- [内存碎片](../../04-架构设计/04.04-缓存问题与治理/04.04.06-内存碎片.md)
- [Redis内存管理总览](./README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **jemalloc文档** - <https://github.com/jemalloc/jemalloc>
