# 03.04.01 内存分配与回收

## 概述

Redis使用自定义的内存分配器jemalloc，优化内存分配和回收性能。理解Redis的内存管理机制对于优化内存使用和性能至关重要。

## 内存分配器

### 为什么使用jemalloc

```c
// Redis默认使用jemalloc而非glibc的malloc
// 原因：
// 1. 减少内存碎片
// 2. 提升分配性能
// 3. 更好的多线程支持
```

### 内存分配器选择

```c
// Redis支持多种内存分配器
#if defined(USE_JEMALLOC)
    #define zmalloc je_malloc
    #define zfree je_free
    #define zrealloc je_realloc
#elif defined(USE_TCMALLOC)
    #define zmalloc tc_malloc
    #define zfree tc_free
    #define zrealloc tc_realloc
#else
    #define zmalloc malloc
    #define zfree free
    #define zrealloc realloc
#endif
```

## 内存分配函数

### zmalloc

```c
// Redis内存分配（带统计）
void *zmalloc(size_t size) {
    void *ptr = malloc(size + PREFIX_SIZE);

    if (!ptr) zmalloc_oom_handler(size);

#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_alloc(zmalloc_size(ptr));
    return ptr;
#else
    *((size_t *)ptr) = size;
    update_zmalloc_stat_alloc(size + PREFIX_SIZE);
    return (char *)ptr + PREFIX_SIZE;
#endif
}
```

### zfree

```c
// Redis内存释放（带统计）
void zfree(void *ptr) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
    size_t oldsize;
#endif

    if (ptr == NULL) return;

#ifdef HAVE_MALLOC_SIZE
    update_zmalloc_stat_free(zmalloc_size(ptr));
    free(ptr);
#else
    realptr = (char *)ptr - PREFIX_SIZE;
    oldsize = *((size_t *)realptr);
    update_zmalloc_stat_free(oldsize + PREFIX_SIZE);
    free(realptr);
#endif
}
```

### zrealloc

```c
// Redis内存重分配
void *zrealloc(void *ptr, size_t size) {
#ifndef HAVE_MALLOC_SIZE
    void *realptr;
#endif
    size_t oldsize;
    void *newptr;

    if (ptr == NULL) return zmalloc(size);

#ifdef HAVE_MALLOC_SIZE
    oldsize = zmalloc_size(ptr);
    newptr = realloc(ptr, size);
    if (!newptr) zmalloc_oom_handler(size);

    update_zmalloc_stat_free(oldsize);
    update_zmalloc_stat_alloc(zmalloc_size(newptr));
    return newptr;
#else
    realptr = (char *)ptr - PREFIX_SIZE;
    oldsize = *((size_t *)realptr);
    newptr = realloc(realptr, size + PREFIX_SIZE);
    if (!newptr) zmalloc_oom_handler(size);

    *((size_t *)newptr) = size;
    update_zmalloc_stat_free(oldsize);
    update_zmalloc_stat_alloc(size);
    return (char *)newptr + PREFIX_SIZE;
#endif
}
```

## 内存统计

### 内存使用统计

```c
// 内存统计
size_t zmalloc_used_memory(void) {
    size_t um;
    atomicGet(used_memory, um);
    return um;
}

// 更新统计
#define update_zmalloc_stat_alloc(__n) do { \
    size_t _n = (__n); \
    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
    atomicIncr(used_memory, __n); \
} while(0)

#define update_zmalloc_stat_free(__n) do { \
    size_t _n = (__n); \
    if (_n&(sizeof(long)-1)) _n += sizeof(long)-(_n&(sizeof(long)-1)); \
    atomicDecr(used_memory, __n); \
} while(0)
```

### 内存碎片统计

```c
// 内存碎片率
float getMemoryFragmentationRatio(void) {
    size_t mem_used = zmalloc_used_memory();
    size_t mem_rss = zmalloc_get_rss();

    if (mem_rss == 0) return 0;

    return (float)mem_rss / (float)mem_used;
}

// 内存碎片率 > 1.5 表示碎片严重
```

## 内存回收

### 主动回收

```c
// 主动回收内存
int freeMemoryIfNeeded(void) {
    size_t mem_used, mem_tofree, mem_freed;
    int slaves = listLength(server.slaves);
    mstime_t latency, eviction_latency;

    // 1. 计算已使用内存
    mem_used = zmalloc_used_memory();

    // 2. 检查是否需要回收
    if (mem_used <= server.maxmemory) {
        return C_OK;
    }

    if (server.maxmemory_policy == MAXMEMORY_NO_EVICTION) {
        return C_ERR;
    }

    // 3. 计算需要释放的内存
    mem_tofree = mem_used - server.maxmemory;
    mem_freed = 0;

    latencyStartMonitor(latency);

    // 4. 根据策略回收内存
    if (server.maxmemory_policy & (MAXMEMORY_FLAG_LRU | MAXMEMORY_FLAG_LFU)) {
        // LRU/LFU淘汰
        while (mem_freed < mem_tofree) {
            int j, k, i;
            static unsigned int next_db = 0;
            sds bestkey = NULL;
            int bestdbid;
            struct evictionPoolEntry *pool = EvictionPoolLRU;

            // 采样并淘汰
            // ...
        }
    } else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||
               server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM) {
        // Random淘汰
        // ...
    }

    latencyEndMonitor(latency);
    latencyAddSampleIfNeeded("eviction-cycle", latency);

    return C_OK;
}
```

### 内存碎片整理

```c
// 内存碎片整理（Redis 4.0+）
int defragMemory(void) {
    int iterations = 0;
    long long start = ustime();

    while (iterations < server.active_defrag_max_scan_fields) {
        // 1. 扫描数据库
        for (int j = 0; j < server.dbnum; j++) {
            redisDb *db = server.db + j;
            dict *d = db->dict;

            // 2. 扫描key
            dictIterator *di = dictGetIterator(d);
            dictEntry *de;

            while ((de = dictNext(di)) != NULL) {
                sds key = dictGetKey(de);
                robj *o = dictGetVal(de);

                // 3. 整理对象
                if (defragObject(o)) {
                    iterations++;
                }
            }

            dictReleaseIterator(di);
        }

        // 4. 检查是否继续
        if (ustime() - start > server.active_defrag_max_cycle_time) {
            break;
        }
    }

    return iterations;
}
```

## 内存优化

### 1. 使用jemalloc

```bash
# 编译时指定jemalloc
make MALLOC=jemalloc
```

### 2. 内存碎片整理

```conf
# redis.conf
# 启用内存碎片整理
activedefrag yes
active-defrag-ignore-bytes 100mb
active-defrag-threshold-lower 10
active-defrag-threshold-upper 100
active-defrag-cycle-min 5
active-defrag-cycle-max 75
```

### 3. 内存限制

```conf
# redis.conf
# 设置最大内存
maxmemory 2gb

# 设置淘汰策略
maxmemory-policy allkeys-lru
```

## 内存监控

### INFO命令

```bash
# 查看内存信息
redis-cli INFO memory

# 关键指标：
# used_memory: 已使用内存
# used_memory_rss: 物理内存
# used_memory_peak: 峰值内存
# mem_fragmentation_ratio: 内存碎片率
# mem_allocator: 内存分配器
```

### 内存分析工具

```bash
# 使用redis-rdb-tools分析RDB文件
redis-rdb-tools --command memory dump.rdb

# 输出内存使用情况
```

## 扩展阅读

- [大Key问题](../../04-架构设计/04.04-缓存问题与治理/04.04.05-大Key问题.md)
- [内存碎片](../../04-架构设计/04.04-缓存问题与治理/04.04.06-内存碎片.md)
- [Redis内存管理总览](./README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **jemalloc文档** - <https://github.com/jemalloc/jemalloc>
