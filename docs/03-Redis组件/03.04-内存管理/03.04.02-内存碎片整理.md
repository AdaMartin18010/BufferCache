# 03.04.02 内存碎片整理

## 概述

内存碎片整理是Redis 4.0+引入的重要特性，通过主动整理内存碎片，提升内存利用率。理解内存碎片整理的机制和优化策略对于Redis内存管理至关重要。

## 碎片整理机制

### 触发条件

```c
// Redis内存碎片整理触发条件
// 1. 碎片率 > active-defrag-threshold-lower（默认10%）
// 2. 碎片大小 > active-defrag-ignore-bytes（默认100MB）

float getMemoryFragmentationRatio(void) {
    size_t mem_used = zmalloc_used_memory();
    size_t mem_rss = zmalloc_get_rss();

    if (mem_used == 0) return 0;

    return (float)mem_rss / (float)mem_used;
}

// 碎片率计算：
// 碎片率 = RSS / 已使用内存
// 碎片率 = 1.0：无碎片（理想）
// 碎片率 = 1.5：50%碎片
// 碎片率 = 2.0：100%碎片
```

### 整理流程

```c
// Redis内存碎片整理主流程
void activeDefragCycle(void) {
    int iterations = 0;
    long long start = ustime();

    // 1. 检查是否应该整理
    if (!server.active_defrag_enabled) return;

    // 2. 计算碎片率
    float frag_pct = getMemoryFragmentationRatio() - 1.0;

    if (frag_pct < server.active_defrag_threshold_lower) {
        return;  // 碎片率太低，不需要整理
    }

    // 3. 计算CPU使用率
    int cpu_pct = getCpuUsagePercent();
    int cpu_limit = server.active_defrag_cycle_min;

    if (frag_pct > server.active_defrag_threshold_upper) {
        cpu_limit = server.active_defrag_cycle_max;  // 积极整理
    }

    if (cpu_pct > cpu_limit) {
        return;  // CPU使用率太高，暂停整理
    }

    // 4. 执行整理
    while (iterations < server.active_defrag_max_scan_fields) {
        int scanned = defragDatabase();
        iterations += scanned;

        // 检查时间限制
        if (ustime() - start > server.active_defrag_max_cycle_time) {
            break;
        }

        // 检查CPU限制
        if (getCpuUsagePercent() > cpu_limit) {
            break;
        }
    }
}
```

## 数据库整理

### 扫描数据库

```c
// 整理数据库
int defragDatabase(void) {
    int iterations = 0;

    // 遍历所有数据库
    for (int j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db + j;
        dict *d = db->dict;

        // 扫描字典
        dictIterator *di = dictGetIterator(d);
        dictEntry *de;

        while ((de = dictNext(di)) != NULL) {
            sds key = dictGetKey(de);
            robj *o = dictGetVal(de);

            // 整理对象
            if (defragObject(o)) {
                iterations++;
            }

            // 检查是否应该暂停
            if (iterations > server.active_defrag_max_scan_fields) {
                dictReleaseIterator(di);
                return iterations;
            }
        }

        dictReleaseIterator(di);
    }

    return iterations;
}
```

### 对象整理

```c
// 整理对象
int defragObject(robj *o) {
    if (o->type == OBJ_STRING) {
        return defragStringObject(o);
    } else if (o->type == OBJ_LIST) {
        return defragListObject(o);
    } else if (o->type == OBJ_SET) {
        return defragSetObject(o);
    } else if (o->type == OBJ_ZSET) {
        return defragZsetObject(o);
    } else if (o->type == OBJ_HASH) {
        return defragHashObject(o);
    }
    return 0;
}
```

## 各类型对象整理

### 1. 字符串对象

```c
// 整理字符串对象
int defragStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        // SDS字符串：移除空闲空间
        sds newsds = sdsRemoveFreeSpace(o->ptr);
        if (newsds) {
            o->ptr = newsds;
            return 1;
        }
    } else if (o->encoding == OBJ_ENCODING_EMBSTR) {
        // 嵌入式字符串：不需要整理
        return 0;
    }
    return 0;
}
```

### 2. 列表对象

```c
// 整理列表对象（quicklist）
int defragListObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        quicklistNode *node;
        int defragged = 0;

        // 遍历quicklist节点
        for (node = ql->head; node; node = node->next) {
            // 整理ziplist
            if (defragQuicklistNode(node)) {
                defragged++;
            }
        }

        return defragged;
    }
    return 0;
}
```

### 3. 哈希对象

```c
// 整理哈希对象
int defragHashObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *d = o->ptr;
        dictIterator *di = dictGetIterator(d);
        dictEntry *de;
        int defragged = 0;

        while ((de = dictNext(di)) != NULL) {
            // 整理key和value
            sds key = dictGetKey(de);
            robj *val = dictGetVal(de);

            if (defragSds(key)) defragged++;
            if (defragObject(val)) defragged++;
        }

        dictReleaseIterator(di);
        return defragged;
    }
    return 0;
}
```

## 配置参数

### 基本配置

```conf
# redis.conf

# 启用内存碎片整理
activedefrag yes

# 碎片整理阈值
active-defrag-ignore-bytes 100mb      # 忽略小于100MB的碎片
active-defrag-threshold-lower 10      # 碎片率>10%时开始整理
active-defrag-threshold-upper 100     # 碎片率>100%时积极整理

# CPU使用率限制
active-defrag-cycle-min 5             # 最小CPU使用率（5%）
active-defrag-cycle-max 75            # 最大CPU使用率（75%）

# 扫描限制
active-defrag-max-scan-fields 1000    # 每次扫描最多1000个字段
active-defrag-max-cycle-time 25      # 每次循环最多25ms
```

### 参数调优

```conf
# 激进整理（碎片严重时）
active-defrag-threshold-lower 5       # 降低阈值
active-defrag-threshold-upper 50      # 降低上限
active-defrag-cycle-max 90            # 提高CPU上限

# 保守整理（碎片不严重时）
active-defrag-threshold-lower 20      # 提高阈值
active-defrag-threshold-upper 200     # 提高上限
active-defrag-cycle-max 50            # 降低CPU上限
```

## 性能影响

### CPU开销

```python
# 内存碎片整理的CPU开销
# 整理时CPU使用率：5-75%（可配置）
# 对Redis性能影响：轻微（后台整理）

# 示例：
# 碎片率：1.5（50%碎片）
# CPU使用率：20%（整理时）
# 性能影响：<5%（轻微）
```

### 内存优化

```python
# 内存碎片整理效果
# 整理前：RSS = 1.5GB，Used = 1GB，碎片 = 0.5GB
# 整理后：RSS = 1.1GB，Used = 1GB，碎片 = 0.1GB
# 节省内存：0.4GB（40%）
```

## 监控与告警

### 监控指标

```python
import redis

class FragmentationMonitor:
    def __init__(self, redis_client):
        self.redis = redis_client

    def get_fragmentation_info(self):
        """获取碎片信息"""
        info = self.redis.info('memory')

        return {
            'fragmentation_ratio': info.get('mem_fragmentation_ratio', 0),
            'used_memory': info.get('used_memory', 0),
            'used_memory_rss': info.get('used_memory_rss', 0),
            'active_defrag_running': info.get('active_defrag_running', 0),
        }

    def check_fragmentation(self):
        """检查碎片情况"""
        info = self.get_fragmentation_info()
        ratio = info['fragmentation_ratio']

        if ratio > 1.5:
            send_alert(f"High fragmentation: {ratio}")
            return True
        return False
```

### 告警规则

```python
# 告警规则
# 1. 碎片率 > 1.5：警告
# 2. 碎片率 > 2.0：严重警告
# 3. 碎片大小 > 500MB：警告
# 4. 整理运行时间 > 1小时：警告
```

## 最佳实践

### 1. 合理配置阈值

```conf
# 根据实际情况调整阈值
# 内存充足：提高阈值（减少整理频率）
# 内存紧张：降低阈值（增加整理频率）
active-defrag-threshold-lower 10
active-defrag-threshold-upper 100
```

### 2. 控制CPU使用率

```conf
# 避免影响Redis性能
# 低负载：提高CPU上限（加快整理）
# 高负载：降低CPU上限（减少影响）
active-defrag-cycle-min 5
active-defrag-cycle-max 50
```

### 3. 定期监控

```python
# 定期监控碎片情况
def monitor_fragmentation():
    while True:
        info = get_fragmentation_info()
        if info['fragmentation_ratio'] > 1.5:
            send_alert("High fragmentation detected")
        time.sleep(300)  # 每5分钟检查一次
```

## 扩展阅读

- [内存分配与回收](./03.04.01-内存分配与回收.md)
- [内存碎片](../../04-架构设计/04.04-缓存问题与治理/04.04.06-内存碎片.md)
- [大Key问题](../../04-架构设计/04.04-缓存问题与治理/04.04.05-大Key问题.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/optimization/>
