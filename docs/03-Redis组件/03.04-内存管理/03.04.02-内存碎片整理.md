# 03.04.02 内存碎片整理

## 目录

- [03.04.02 内存碎片整理](#030402-内存碎片整理)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 碎片整理机制](#2-碎片整理机制)
    - [2.1 触发条件](#21-触发条件)
    - [2.2 整理流程](#22-整理流程)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 数据库整理](#3-数据库整理)
    - [扫描数据库](#扫描数据库)
    - [对象整理](#对象整理)
  - [各类型对象整理](#各类型对象整理)
    - [1. 字符串对象](#1-字符串对象)
    - [2. 列表对象](#2-列表对象)
    - [3. 哈希对象](#3-哈希对象)
  - [4. 性能分析](#4-性能分析)
    - [4.1 CPU开销分析](#41-cpu开销分析)
    - [4.2 内存优化效果](#42-内存优化效果)
  - [5. 配置与使用](#5-配置与使用)
    - [5.1 基本配置](#51-基本配置)
    - [5.2 参数调优](#52-参数调优)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 合理配置阈值](#61-合理配置阈值)
    - [6.2 控制CPU使用率](#62-控制cpu使用率)
    - [6.3 定期监控](#63-定期监控)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

内存碎片整理是Redis 4.0+引入的重要特性，通过主动整理内存碎片，提升内存利用率。理解内存碎片整理的机制和优化策略对于Redis内存管理至关重要。

**历史发展**：

- **2017年**：Redis 4.0引入内存碎片整理
- **2020年代**：内存碎片整理成为Redis内存管理的标准特性

### 1.2 应用价值

内存碎片整理在Redis中具有重要价值：

1. **提升内存利用率**：减少内存碎片
2. **降低内存占用**：减少RSS内存占用
3. **提高性能**：减少内存分配失败
4. **自动管理**：自动整理内存碎片

## 2. 碎片整理机制

### 2.1 触发条件

```c
// Redis内存碎片整理触发条件
// 1. 碎片率 > active-defrag-threshold-lower（默认10%）
// 2. 碎片大小 > active-defrag-ignore-bytes（默认100MB）

float getMemoryFragmentationRatio(void) {
    size_t mem_used = zmalloc_used_memory();
    size_t mem_rss = zmalloc_get_rss();

    if (mem_used == 0) return 0;

    return (float)mem_rss / (float)mem_used;
}

// 碎片率计算：
// 碎片率 = RSS / 已使用内存
// 碎片率 = 1.0：无碎片（理想）
// 碎片率 = 1.5：50%碎片
// 碎片率 = 2.0：100%碎片
```

**触发条件**：

- **碎片率 > active-defrag-threshold-lower（默认10%）**
- **碎片大小 > active-defrag-ignore-bytes（默认100MB）**

**碎片率计算**：

$$FragmentationRatio = \frac{RSS}{UsedMemory}$$

其中：

- $RSS$：物理内存使用量
- $UsedMemory$：已分配内存量

### 2.2 整理流程

```c
// Redis内存碎片整理主流程
void activeDefragCycle(void) {
    int iterations = 0;
    long long start = ustime();

    // 1. 检查是否应该整理
    if (!server.active_defrag_enabled) return;

    // 2. 计算碎片率
    float frag_pct = getMemoryFragmentationRatio() - 1.0;

    if (frag_pct < server.active_defrag_threshold_lower) {
        return;  // 碎片率太低，不需要整理
    }

    // 3. 计算CPU使用率
    int cpu_pct = getCpuUsagePercent();
    int cpu_limit = server.active_defrag_cycle_min;

    if (frag_pct > server.active_defrag_threshold_upper) {
        cpu_limit = server.active_defrag_cycle_max;  // 积极整理
    }

    if (cpu_pct > cpu_limit) {
        return;  // CPU使用率太高，暂停整理
    }

    // 4. 执行整理
    while (iterations < server.active_defrag_max_scan_fields) {
        int scanned = defragDatabase();
        iterations += scanned;

        // 检查时间限制
        if (ustime() - start > server.active_defrag_max_cycle_time) {
            break;
        }

        // 检查CPU限制
        if (getCpuUsagePercent() > cpu_limit) {
            break;
        }
    }
}
```

**整理流程**：

1. **检查是否应该整理**：检查碎片率和CPU使用率
2. **计算CPU使用率**：根据碎片率调整CPU使用率限制
3. **执行整理**：扫描数据库，整理内存碎片

### 2.3 形式化定义

设碎片率为$f$，CPU使用率为$c$。

**碎片整理触发条件**：

$$f > threshold\_lower \land FragmentationSize > ignore\_bytes$$

其中：

- $threshold\_lower$：碎片率下限（默认10%）
- $ignore\_bytes$：忽略的碎片大小（默认100MB）

**CPU使用率限制**：

$$
c\_limit = \begin{cases}
cycle\_min & \text{如果 } f < threshold\_upper \\
cycle\_max & \text{如果 } f \geq threshold\_upper
\end{cases}
$$

## 3. 数据库整理

### 扫描数据库

```c
// 整理数据库
int defragDatabase(void) {
    int iterations = 0;

    // 遍历所有数据库
    for (int j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db + j;
        dict *d = db->dict;

        // 扫描字典
        dictIterator *di = dictGetIterator(d);
        dictEntry *de;

        while ((de = dictNext(di)) != NULL) {
            sds key = dictGetKey(de);
            robj *o = dictGetVal(de);

            // 整理对象
            if (defragObject(o)) {
                iterations++;
            }

            // 检查是否应该暂停
            if (iterations > server.active_defrag_max_scan_fields) {
                dictReleaseIterator(di);
                return iterations;
            }
        }

        dictReleaseIterator(di);
    }

    return iterations;
}
```

### 对象整理

```c
// 整理对象
int defragObject(robj *o) {
    if (o->type == OBJ_STRING) {
        return defragStringObject(o);
    } else if (o->type == OBJ_LIST) {
        return defragListObject(o);
    } else if (o->type == OBJ_SET) {
        return defragSetObject(o);
    } else if (o->type == OBJ_ZSET) {
        return defragZsetObject(o);
    } else if (o->type == OBJ_HASH) {
        return defragHashObject(o);
    }
    return 0;
}
```

## 各类型对象整理

### 1. 字符串对象

```c
// 整理字符串对象
int defragStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        // SDS字符串：移除空闲空间
        sds newsds = sdsRemoveFreeSpace(o->ptr);
        if (newsds) {
            o->ptr = newsds;
            return 1;
        }
    } else if (o->encoding == OBJ_ENCODING_EMBSTR) {
        // 嵌入式字符串：不需要整理
        return 0;
    }
    return 0;
}
```

### 2. 列表对象

```c
// 整理列表对象（quicklist）
int defragListObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklist *ql = o->ptr;
        quicklistNode *node;
        int defragged = 0;

        // 遍历quicklist节点
        for (node = ql->head; node; node = node->next) {
            // 整理ziplist
            if (defragQuicklistNode(node)) {
                defragged++;
            }
        }

        return defragged;
    }
    return 0;
}
```

### 3. 哈希对象

```c
// 整理哈希对象
int defragHashObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dict *d = o->ptr;
        dictIterator *di = dictGetIterator(d);
        dictEntry *de;
        int defragged = 0;

        while ((de = dictNext(di)) != NULL) {
            // 整理key和value
            sds key = dictGetKey(de);
            robj *val = dictGetVal(de);

            if (defragSds(key)) defragged++;
            if (defragObject(val)) defragged++;
        }

        dictReleaseIterator(di);
        return defragged;
    }
    return 0;
}
```

## 4. 性能分析

### 4.1 CPU开销分析

**CPU开销**：

- **整理时CPU使用率**：5-75%（可配置）
- **对Redis性能影响**：轻微（后台整理）

**定理 4.1**：内存碎片整理的CPU开销可控制在5-75%之间。

**证明**：

- CPU使用率限制：$cycle\_min \leq CPU \leq cycle\_max$
- 默认值：$cycle\_min = 5\%$，$cycle\_max = 75\%$
- 因此：CPU开销可控制在5-75%之间

### 4.2 内存优化效果

**内存优化效果**：

| 指标 | 整理前 | 整理后 | 优化 |
|------|--------|--------|------|
| **RSS** | 1.5GB | 1.1GB | -0.4GB |
| **Used** | 1GB | 1GB | 0 |
| **碎片** | 0.5GB | 0.1GB | -0.4GB |

**定理 4.2**：内存碎片整理可以节省20-40%的RSS内存。

**证明**：

- 整理前：$RSS = 1.5GB$，$Used = 1GB$，碎片 = $0.5GB$
- 整理后：$RSS = 1.1GB$，$Used = 1GB$，碎片 = $0.1GB$
- 节省内存：$\frac{0.4GB}{1.5GB} \approx 27\%$

## 5. 配置与使用

### 5.1 基本配置

```conf
# redis.conf

# 启用内存碎片整理
activedefrag yes

# 碎片整理阈值
active-defrag-ignore-bytes 100mb      # 忽略小于100MB的碎片
active-defrag-threshold-lower 10      # 碎片率>10%时开始整理
active-defrag-threshold-upper 100     # 碎片率>100%时积极整理

# CPU使用率限制
active-defrag-cycle-min 5             # 最小CPU使用率（5%）
active-defrag-cycle-max 75            # 最大CPU使用率（75%）

# 扫描限制
active-defrag-max-scan-fields 1000    # 每次扫描最多1000个字段
active-defrag-max-cycle-time 25      # 每次循环最多25ms
```

**推荐配置**：

- **启用内存碎片整理**：`activedefrag yes`
- **碎片整理阈值**：`active-defrag-threshold-lower 10`
- **CPU使用率限制**：`active-defrag-cycle-max 75`

### 5.2 参数调优

```conf
# 激进整理（碎片严重时）
active-defrag-threshold-lower 5       # 降低阈值
active-defrag-threshold-upper 50      # 降低上限
active-defrag-cycle-max 90            # 提高CPU上限

# 保守整理（碎片不严重时）
active-defrag-threshold-lower 20      # 提高阈值
active-defrag-threshold-upper 200     # 提高上限
active-defrag-cycle-max 50            # 降低CPU上限
```

**参数调优建议**：

- **激进整理**：碎片严重时降低阈值，提高CPU上限
- **保守整理**：碎片不严重时提高阈值，降低CPU上限

## 6. 最佳实践

### 6.1 合理配置阈值

**配置建议**：

- **内存充足**：提高阈值（减少整理频率）
- **内存紧张**：降低阈值（增加整理频率）

### 6.2 控制CPU使用率

**CPU使用率控制**：

- **低负载**：提高CPU上限（加快整理）
- **高负载**：降低CPU上限（减少影响）

### 6.3 定期监控

**监控建议**：

- **定期检查碎片率**：每5分钟检查一次
- **设置告警规则**：碎片率>1.5时告警

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：不同碎片整理策略
2. **迭代器模式**：遍历数据库和对象
3. **模板方法模式**：定义碎片整理的基本流程

**策略模式实现**：

```c
// 碎片整理策略接口
typedef struct defrag_strategy {
    void (*defrag_string)(robj *o);
    void (*defrag_list)(robj *o);
    void (*defrag_hash)(robj *o);
    const char *name;
} defrag_strategy_t;
```

### 7.2 代码结构分析

**代码组织**：

1. **扫描层**：数据库和对象扫描实现
2. **整理层**：不同类型对象整理实现
3. **控制层**：碎片整理控制实现

**模块化设计**：

- **高内聚**：碎片整理相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的整理策略

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 内存** | 平衡 | 平衡CPU开销和内存优化 |
| **简单 vs 复杂** | 增量整理 | 支持增量整理 |
| **通用 vs 专用** | 通用碎片整理实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{memory} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（CPU开销）
- $C_{memory}$：内存成本（内存优化）
- $C_{complexity}$：复杂度成本（增量整理，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新整理策略**：可扩展为其他整理策略
2. **新对象类型**：可扩展为其他对象类型整理
3. **分布式碎片整理**：可扩展为分布式碎片整理实现

**扩展性设计**：

```c
// 可扩展的碎片整理接口
typedef struct defrag_manager {
    defrag_strategy_t *strategy;
    int (*defrag)(struct defrag_manager *mgr);
} defrag_manager_t;
```

**可维护性**：

- **代码清晰**：碎片整理逻辑清晰，易于理解
- **易于调试**：整理状态易于监控和调试
- **测试友好**：碎片整理行为易于测试和验证

## 8. 扩展阅读

- [内存分配与回收](./03.04.01-内存分配与回收.md)
- [内存监控](./03.04.03-内存监控.md)
- [引用计数GC](./03.04.04-引用计数GC.md)

## 9. 权威参考

### 9.1 官方文档

1. **Redis源码 - defrag.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/defrag.c>
   - 版本: Redis 4.0+
   - 内存碎片整理的完整实现源码

2. **Redis官方文档 - Memory Optimization**
   - URL: <https://redis.io/docs/manual/optimization/>
   - 版本: Redis 7.0+
   - Redis内存优化的官方文档

### 9.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第12章：内存管理（内存碎片整理详解）

### 9.3 在线资源

1. **Wikipedia - Memory Fragmentation**
   - URL: <https://en.wikipedia.org/wiki/Memory_fragmentation>
   - 提供内存碎片的详细说明
