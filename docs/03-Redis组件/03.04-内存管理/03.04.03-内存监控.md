# 03.04.03 内存监控

## 目录

- [03.04.03 内存监控](#030403-内存监控)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 监控指标](#2-监控指标)
    - [2.1 核心指标](#21-核心指标)
    - [2.2 指标说明](#22-指标说明)
  - [3. 监控工具](#3-监控工具)
    - [3.1 INFO命令](#31-info命令)
    - [3.2 redis-cli --stat](#32-redis-cli---stat)
    - [3.3 redis-cli --bigkeys](#33-redis-cli---bigkeys)
    - [3.4 redis-cli --memkeys](#34-redis-cli---memkeys)
  - [4. 监控实践](#4-监控实践)
    - [4.1 Python监控脚本](#41-python监控脚本)
    - [4.2 Shell监控脚本](#42-shell监控脚本)
  - [5. 告警规则](#5-告警规则)
    - [5.1 碎片率告警](#51-碎片率告警)
    - [5.2 内存使用告警](#52-内存使用告警)
    - [5.3 峰值内存告警](#53-峰值内存告警)
    - [5.4 监控面板](#54-监控面板)
      - [5.4.1 Grafana集成](#541-grafana集成)
      - [5.4.2 Prometheus指标](#542-prometheus指标)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 定期监控](#61-定期监控)
    - [6.2 告警阈值](#62-告警阈值)
    - [6.3 历史数据](#63-历史数据)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与背景

内存监控是Redis运维的重要组成部分，通过实时监控内存使用情况，及时发现内存问题，优化内存配置。
本文档详细介绍Redis内存监控的方法和工具。

**监控背景**：

- **内存使用**：实时监控内存使用情况
- **内存碎片**：监控内存碎片率
- **内存泄漏**：及时发现内存泄漏问题

### 1.2 应用价值

内存监控在Redis中具有重要价值：

1. **及时发现问题**：及时发现内存问题
2. **优化内存配置**：优化内存配置
3. **预防内存溢出**：预防内存溢出
4. **提升性能**：优化内存使用，提升性能

## 2. 监控指标

### 2.1 核心指标

```bash
# INFO memory命令输出
redis-cli INFO memory

# 关键指标：
# used_memory: 已使用内存（字节）
# used_memory_human: 已使用内存（人类可读）
# used_memory_rss: 物理内存（RSS）
# used_memory_peak: 峰值内存
# used_memory_peak_perc: 峰值内存百分比
# used_memory_overhead: 内存开销
# used_memory_startup: 启动时内存
# used_memory_dataset: 数据集内存
# used_memory_dataset_perc: 数据集内存百分比
# mem_fragmentation_ratio: 内存碎片率
# mem_allocator: 内存分配器
# active_defrag_running: 碎片整理是否运行
# lazyfree_pending_objects: 延迟释放对象数
```

**核心指标**：

- **used_memory**：已使用内存（字节）
- **used_memory_rss**：物理内存（RSS）
- **mem_fragmentation_ratio**：内存碎片率
- **used_memory_peak**：峰值内存

### 2.2 指标说明

```python
# 内存使用指标
class MemoryMetrics:
    def __init__(self, redis_client):
        self.redis = redis_client

    def get_memory_info(self):
        """获取内存信息"""
        info = self.redis.info('memory')

        return {
            'used_memory': info.get('used_memory', 0),
            'used_memory_rss': info.get('used_memory_rss', 0),
            'used_memory_peak': info.get('used_memory_peak', 0),
            'mem_fragmentation_ratio': info.get('mem_fragmentation_ratio', 0),
            'used_memory_dataset': info.get('used_memory_dataset', 0),
            'used_memory_overhead': info.get('used_memory_overhead', 0),
        }

    def calculate_memory_stats(self):
        """计算内存统计"""
        info = self.get_memory_info()

        return {
            'fragmentation_bytes': info['used_memory_rss'] - info['used_memory'],
            'dataset_percentage': (info['used_memory_dataset'] / info['used_memory']) * 100 if info['used_memory'] > 0 else 0,
            'overhead_percentage': (info['used_memory_overhead'] / info['used_memory']) * 100 if info['used_memory'] > 0 else 0,
        }
```

## 3. 监控工具

### 3.1 INFO命令

```bash
# 实时监控内存
watch -n 1 'redis-cli INFO memory | grep -E "used_memory|mem_fragmentation"'

# 输出示例：
# used_memory:1048576
# used_memory_human:1.00M
# used_memory_rss:1572864
# mem_fragmentation_ratio:1.50
```

**INFO命令**：实时监控内存使用情况。

### 3.2 redis-cli --stat

```bash
# 统计信息
redis-cli --stat

# 输出示例：
# ------- data ------ --------------------- load -------------------- - child -
# keys       mem      clients blocked requests            connections
# 1000       1.00M    50       0       1000000              100
```

**redis-cli --stat**：统计信息，包括内存使用。

### 3.3 redis-cli --bigkeys

```bash
# 查找大Key
redis-cli --bigkeys

# 输出示例：
# [00.00%] Biggest string found so far 'key:1000' with 1024 bytes
# [00.00%] Biggest list   found so far 'list:1000' with 10000 items
```

**redis-cli --bigkeys**：查找大Key，分析内存占用。

### 3.4 redis-cli --memkeys

```bash
# 查找内存占用大的Key（Redis 4.0+）
redis-cli --memkeys

# 输出示例：
# key:1000    1024 bytes
# key:2000    2048 bytes
```

**redis-cli --memkeys**：查找内存占用大的Key（Redis 4.0+）。

## 4. 监控实践

### 4.1 Python监控脚本

```python
import redis
import time
import json

class RedisMemoryMonitor:
    def __init__(self, host='localhost', port=6379):
        self.redis = redis.Redis(host=host, port=port)

    def monitor_memory(self, interval=5):
        """监控内存"""
        while True:
            info = self.redis.info('memory')

            metrics = {
                'timestamp': time.time(),
                'used_memory': info.get('used_memory', 0),
                'used_memory_rss': info.get('used_memory_rss', 0),
                'mem_fragmentation_ratio': info.get('mem_fragmentation_ratio', 0),
                'used_memory_peak': info.get('used_memory_peak', 0),
            }

            print(json.dumps(metrics, indent=2))

            # 检查告警
            self.check_alerts(metrics)

            time.sleep(interval)

    def check_alerts(self, metrics):
        """检查告警"""
        # 碎片率告警
        if metrics['mem_fragmentation_ratio'] > 1.5:
            print(f"ALERT: High fragmentation: {metrics['mem_fragmentation_ratio']}")

        # 内存使用告警
        if metrics['used_memory'] > metrics['used_memory_peak'] * 0.9:
            print(f"ALERT: Memory usage high: {metrics['used_memory']}")
```

**Python监控脚本**：使用Python实现内存监控。

### 4.2 Shell监控脚本

```bash
#!/bin/bash
# redis_memory_monitor.sh

REDIS_HOST="localhost"
REDIS_PORT="6379"
ALERT_FRAGMENTATION=1.5
ALERT_MEMORY_PERCENT=90

while true; do
    MEMORY_INFO=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory)

    USED_MEMORY=$(echo "$MEMORY_INFO" | grep "used_memory:" | cut -d: -f2 | tr -d '\r')
    USED_MEMORY_RSS=$(echo "$MEMORY_INFO" | grep "used_memory_rss:" | cut -d: -f2 | tr -d '\r')
    FRAGMENTATION=$(echo "$MEMORY_INFO" | grep "mem_fragmentation_ratio:" | cut -d: -f2 | tr -d '\r')

    # 计算碎片率
    FRAG_RATIO=$(echo "scale=2; $USED_MEMORY_RSS / $USED_MEMORY" | bc)

    # 告警检查
    if (( $(echo "$FRAG_RATIO > $ALERT_FRAGMENTATION" | bc -l) )); then
        echo "ALERT: High fragmentation: $FRAG_RATIO"
    fi

    sleep 5
done
```

**Shell监控脚本**：使用Shell脚本实现内存监控。

## 5. 告警规则

### 5.1 碎片率告警

```python
# 碎片率告警规则
def check_fragmentation_alert(fragmentation_ratio):
    if fragmentation_ratio > 2.0:
        return "CRITICAL", "Fragmentation ratio > 2.0"
    elif fragmentation_ratio > 1.5:
        return "WARNING", "Fragmentation ratio > 1.5"
    return "OK", None
```

**告警规则**：

- **碎片率 > 2.0**：严重告警
- **碎片率 > 1.5**：警告

### 5.2 内存使用告警

```python
# 内存使用告警规则
def check_memory_usage_alert(used_memory, max_memory):
    if max_memory == 0:
        return "OK", None

    usage_percent = (used_memory / max_memory) * 100

    if usage_percent > 95:
        return "CRITICAL", f"Memory usage > 95%: {usage_percent}%"
    elif usage_percent > 85:
        return "WARNING", f"Memory usage > 85%: {usage_percent}%"
    return "OK", None
```

**告警规则**：

- **内存使用 > 95%**：严重告警
- **内存使用 > 85%**：警告

### 5.3 峰值内存告警

```python
# 峰值内存告警规则
def check_peak_memory_alert(used_memory, peak_memory):
    if peak_memory == 0:
        return "OK", None

    peak_percent = (used_memory / peak_memory) * 100

    if peak_percent > 90:
        return "WARNING", f"Memory usage near peak: {peak_percent}%"
    return "OK", None
```

**告警规则**：

- **接近峰值 > 90%**：警告

### 5.4 监控面板

#### 5.4.1 Grafana集成

```json
{
  "dashboard": {
    "title": "Redis Memory Monitoring",
    "panels": [
      {
        "title": "Memory Usage",
        "targets": [
          {
            "expr": "redis_memory_used_bytes",
            "legendFormat": "Used Memory"
          },
          {
            "expr": "redis_memory_used_rss_bytes",
            "legendFormat": "RSS Memory"
          }
        ]
      },
      {
        "title": "Fragmentation Ratio",
        "targets": [
          {
            "expr": "redis_memory_fragmentation_ratio",
            "legendFormat": "Fragmentation"
          }
        ]
      }
    ]
  }
}
```

**Grafana集成**：使用Grafana可视化内存监控数据。

#### 5.4.2 Prometheus指标

```python
# Prometheus exporter
from prometheus_client import Gauge, start_http_server

memory_used = Gauge('redis_memory_used_bytes', 'Used memory in bytes')
memory_rss = Gauge('redis_memory_rss_bytes', 'RSS memory in bytes')
fragmentation_ratio = Gauge('redis_memory_fragmentation_ratio', 'Memory fragmentation ratio')

def update_metrics():
    info = redis_client.info('memory')
    memory_used.set(info['used_memory'])
    memory_rss.set(info['used_memory_rss'])
    fragmentation_ratio.set(info['mem_fragmentation_ratio'])

# 启动HTTP服务器
start_http_server(8000)

# 定期更新指标
while True:
    update_metrics()
    time.sleep(5)
```

**Prometheus指标**：使用Prometheus收集和存储内存监控指标。

## 6. 最佳实践

### 6.1 定期监控

**监控频率**：

- **生产环境**：每5秒
- **测试环境**：每30秒
- **开发环境**：每60秒

### 6.2 告警阈值

**推荐告警阈值**：

- **碎片率 > 1.5**：警告
- **内存使用 > 85%**：警告
- **接近峰值 > 90%**：警告

### 6.3 历史数据

**历史数据保留**：

- **详细数据**：保留7天
- **汇总数据**：保留30天
- **统计数据**：保留1年

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **观察者模式**：监控指标变化通知
2. **策略模式**：不同监控策略
3. **模板方法模式**：定义监控的基本流程

**观察者模式实现**：

```python
# 监控观察者接口
class MemoryMonitorObserver:
    def on_memory_change(self, metrics):
        raise NotImplementedError

class AlertObserver(MemoryMonitorObserver):
    def on_memory_change(self, metrics):
        if metrics['fragmentation_ratio'] > 1.5:
            send_alert("内存碎片率过高")
```

### 7.2 代码结构分析

**代码组织**：

1. **采集层**：内存指标采集实现
2. **处理层**：指标处理和计算实现
3. **通知层**：告警和通知实现

**模块化设计**：

- **高内聚**：内存监控相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的监控指标

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 准确性** | 平衡 | 平衡监控开销和准确性 |
| **简单 vs 复杂** | 多指标监控 | 支持多种监控指标 |
| **通用 vs 专用** | 通用内存监控实现 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{accuracy} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（监控开销）
- $C_{accuracy}$：准确性成本（监控准确性）
- $C_{complexity}$：复杂度成本（多指标监控，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新监控指标**：可扩展为其他监控指标
2. **新告警策略**：可扩展为其他告警策略
3. **分布式监控**：可扩展为分布式监控实现

**扩展性设计**：

```python
# 可扩展的内存监控接口
class MemoryMonitor:
    def __init__(self, observers: List[MemoryMonitorObserver]):
        self.observers = observers

    def collect_metrics(self):
        metrics = self._collect()
        for observer in self.observers:
            observer.on_memory_change(metrics)
```

**可维护性**：

- **代码清晰**：内存监控逻辑清晰，易于理解
- **易于调试**：监控状态易于监控和调试
- **测试友好**：内存监控行为易于测试和验证

## 8. 扩展阅读

- [内存分配与回收](./03.04.01-内存分配与回收.md)
- [内存碎片整理](./03.04.02-内存碎片整理.md)
- [引用计数GC](./03.04.04-引用计数GC.md)

## 9. 权威参考

### 9.1 官方文档

1. **Redis官方文档 - Memory Optimization**
   - URL: <https://redis.io/docs/manual/optimization/>
   - 版本: Redis 7.0+
   - Redis内存优化的官方文档

2. **Prometheus官方文档**
   - URL: <https://prometheus.io/docs/>
   - Prometheus的官方文档

### 9.2 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第12章：内存管理（内存监控详解）

2. **《Redis运维实战》** - 付磊, 张益军
   - 出版社: 机械工业出版社
   - ISBN: 978-7111544937
   - 第5章：内存监控（内存监控实践）

### 9.3 在线资源

1. **Grafana官方文档**
   - URL: <https://grafana.com/docs/>
   - Grafana的官方文档
