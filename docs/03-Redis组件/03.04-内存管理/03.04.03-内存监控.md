# 03.04.03 内存监控

## 概述

内存监控是Redis运维的重要组成部分，通过实时监控内存使用情况，及时发现内存问题，优化内存配置。本文档详细介绍Redis内存监控的方法和工具。

## 监控指标

### 核心指标

```bash
# INFO memory命令输出
redis-cli INFO memory

# 关键指标：
# used_memory: 已使用内存（字节）
# used_memory_human: 已使用内存（人类可读）
# used_memory_rss: 物理内存（RSS）
# used_memory_peak: 峰值内存
# used_memory_peak_perc: 峰值内存百分比
# used_memory_overhead: 内存开销
# used_memory_startup: 启动时内存
# used_memory_dataset: 数据集内存
# used_memory_dataset_perc: 数据集内存百分比
# mem_fragmentation_ratio: 内存碎片率
# mem_allocator: 内存分配器
# active_defrag_running: 碎片整理是否运行
# lazyfree_pending_objects: 延迟释放对象数
```

### 指标说明

```python
# 内存使用指标
class MemoryMetrics:
    def __init__(self, redis_client):
        self.redis = redis_client

    def get_memory_info(self):
        """获取内存信息"""
        info = self.redis.info('memory')

        return {
            'used_memory': info.get('used_memory', 0),
            'used_memory_rss': info.get('used_memory_rss', 0),
            'used_memory_peak': info.get('used_memory_peak', 0),
            'mem_fragmentation_ratio': info.get('mem_fragmentation_ratio', 0),
            'used_memory_dataset': info.get('used_memory_dataset', 0),
            'used_memory_overhead': info.get('used_memory_overhead', 0),
        }

    def calculate_memory_stats(self):
        """计算内存统计"""
        info = self.get_memory_info()

        return {
            'fragmentation_bytes': info['used_memory_rss'] - info['used_memory'],
            'dataset_percentage': (info['used_memory_dataset'] / info['used_memory']) * 100 if info['used_memory'] > 0 else 0,
            'overhead_percentage': (info['used_memory_overhead'] / info['used_memory']) * 100 if info['used_memory'] > 0 else 0,
        }
```

## 监控工具

### 1. INFO命令

```bash
# 实时监控内存
watch -n 1 'redis-cli INFO memory | grep -E "used_memory|mem_fragmentation"'

# 输出示例：
# used_memory:1048576
# used_memory_human:1.00M
# used_memory_rss:1572864
# mem_fragmentation_ratio:1.50
```

### 2. redis-cli --stat

```bash
# 统计信息
redis-cli --stat

# 输出示例：
# ------- data ------ --------------------- load -------------------- - child -
# keys       mem      clients blocked requests            connections
# 1000       1.00M    50       0       1000000              100
```

### 3. redis-cli --bigkeys

```bash
# 查找大Key
redis-cli --bigkeys

# 输出示例：
# [00.00%] Biggest string found so far 'key:1000' with 1024 bytes
# [00.00%] Biggest list   found so far 'list:1000' with 10000 items
```

### 4. redis-cli --memkeys

```bash
# 查找内存占用大的Key（Redis 4.0+）
redis-cli --memkeys

# 输出示例：
# key:1000    1024 bytes
# key:2000    2048 bytes
```

## 监控脚本

### Python监控脚本

```python
import redis
import time
import json

class RedisMemoryMonitor:
    def __init__(self, host='localhost', port=6379):
        self.redis = redis.Redis(host=host, port=port)

    def monitor_memory(self, interval=5):
        """监控内存"""
        while True:
            info = self.redis.info('memory')

            metrics = {
                'timestamp': time.time(),
                'used_memory': info.get('used_memory', 0),
                'used_memory_rss': info.get('used_memory_rss', 0),
                'mem_fragmentation_ratio': info.get('mem_fragmentation_ratio', 0),
                'used_memory_peak': info.get('used_memory_peak', 0),
            }

            print(json.dumps(metrics, indent=2))

            # 检查告警
            self.check_alerts(metrics)

            time.sleep(interval)

    def check_alerts(self, metrics):
        """检查告警"""
        # 碎片率告警
        if metrics['mem_fragmentation_ratio'] > 1.5:
            print(f"ALERT: High fragmentation: {metrics['mem_fragmentation_ratio']}")

        # 内存使用告警
        if metrics['used_memory'] > metrics['used_memory_peak'] * 0.9:
            print(f"ALERT: Memory usage high: {metrics['used_memory']}")
```

### Shell监控脚本

```bash
#!/bin/bash
# redis_memory_monitor.sh

REDIS_HOST="localhost"
REDIS_PORT="6379"
ALERT_FRAGMENTATION=1.5
ALERT_MEMORY_PERCENT=90

while true; do
    MEMORY_INFO=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory)

    USED_MEMORY=$(echo "$MEMORY_INFO" | grep "used_memory:" | cut -d: -f2 | tr -d '\r')
    USED_MEMORY_RSS=$(echo "$MEMORY_INFO" | grep "used_memory_rss:" | cut -d: -f2 | tr -d '\r')
    FRAGMENTATION=$(echo "$MEMORY_INFO" | grep "mem_fragmentation_ratio:" | cut -d: -f2 | tr -d '\r')

    # 计算碎片率
    FRAG_RATIO=$(echo "scale=2; $USED_MEMORY_RSS / $USED_MEMORY" | bc)

    # 告警检查
    if (( $(echo "$FRAG_RATIO > $ALERT_FRAGMENTATION" | bc -l) )); then
        echo "ALERT: High fragmentation: $FRAG_RATIO"
    fi

    sleep 5
done
```

## 告警规则

### 碎片率告警

```python
# 碎片率告警规则
def check_fragmentation_alert(fragmentation_ratio):
    if fragmentation_ratio > 2.0:
        return "CRITICAL", "Fragmentation ratio > 2.0"
    elif fragmentation_ratio > 1.5:
        return "WARNING", "Fragmentation ratio > 1.5"
    return "OK", None
```

### 内存使用告警

```python
# 内存使用告警规则
def check_memory_usage_alert(used_memory, max_memory):
    if max_memory == 0:
        return "OK", None

    usage_percent = (used_memory / max_memory) * 100

    if usage_percent > 95:
        return "CRITICAL", f"Memory usage > 95%: {usage_percent}%"
    elif usage_percent > 85:
        return "WARNING", f"Memory usage > 85%: {usage_percent}%"
    return "OK", None
```

### 峰值内存告警

```python
# 峰值内存告警规则
def check_peak_memory_alert(used_memory, peak_memory):
    if peak_memory == 0:
        return "OK", None

    peak_percent = (used_memory / peak_memory) * 100

    if peak_percent > 90:
        return "WARNING", f"Memory usage near peak: {peak_percent}%"
    return "OK", None
```

## 监控面板

### Grafana集成

```json
{
  "dashboard": {
    "title": "Redis Memory Monitoring",
    "panels": [
      {
        "title": "Memory Usage",
        "targets": [
          {
            "expr": "redis_memory_used_bytes",
            "legendFormat": "Used Memory"
          },
          {
            "expr": "redis_memory_used_rss_bytes",
            "legendFormat": "RSS Memory"
          }
        ]
      },
      {
        "title": "Fragmentation Ratio",
        "targets": [
          {
            "expr": "redis_memory_fragmentation_ratio",
            "legendFormat": "Fragmentation"
          }
        ]
      }
    ]
  }
}
```

### Prometheus指标

```python
# Prometheus exporter
from prometheus_client import Gauge, start_http_server

memory_used = Gauge('redis_memory_used_bytes', 'Used memory in bytes')
memory_rss = Gauge('redis_memory_rss_bytes', 'RSS memory in bytes')
fragmentation_ratio = Gauge('redis_memory_fragmentation_ratio', 'Memory fragmentation ratio')

def update_metrics():
    info = redis_client.info('memory')
    memory_used.set(info['used_memory'])
    memory_rss.set(info['used_memory_rss'])
    fragmentation_ratio.set(info['mem_fragmentation_ratio'])

# 启动HTTP服务器
start_http_server(8000)

# 定期更新指标
while True:
    update_metrics()
    time.sleep(5)
```

## 最佳实践

### 1. 定期监控

```python
# 设置监控频率
# - 生产环境：每5秒
# - 测试环境：每30秒
# - 开发环境：每60秒
```

### 2. 告警阈值

```python
# 推荐告警阈值
ALERT_THRESHOLDS = {
    'fragmentation_ratio': 1.5,  # 碎片率 > 1.5
    'memory_usage_percent': 85,   # 内存使用 > 85%
    'peak_memory_percent': 90,    # 接近峰值 > 90%
}
```

### 3. 历史数据

```python
# 保存历史数据
# - 保留7天详细数据
# - 保留30天汇总数据
# - 保留1年统计数据
```

## 扩展阅读

- [内存分配与回收](./03.04.01-内存分配与回收.md)
- [内存碎片整理](./03.04.02-内存碎片整理.md)
- [大Key问题](../../04-架构设计/04.04-缓存问题与治理/04.04.05-大Key问题.md)

## 权威参考

- **Redis官方文档** - <https://redis.io/docs/manual/optimization/>
- **《Redis运维实战》** - Redis运维经典教材
- **Prometheus文档** - <https://prometheus.io/docs/>
