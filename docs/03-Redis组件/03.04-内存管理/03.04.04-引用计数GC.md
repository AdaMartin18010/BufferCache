# 03.04.04 引用计数GC

## 目录

- [03.04.04 引用计数GC](#030404-引用计数gc)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 引用计数原理](#2-引用计数原理)
    - [2.1 基本概念](#21-基本概念)
    - [2.2 引用计数操作](#22-引用计数操作)
    - [2.3 形式化定义](#23-形式化定义)
  - [3. 共享对象](#3-共享对象)
    - [3.1 共享对象机制](#31-共享对象机制)
    - [3.2 共享对象限制](#32-共享对象限制)
  - [4. 性能分析](#4-性能分析)
    - [4.1 引用计数开销](#41-引用计数开销)
    - [4.2 内存占用分析](#42-内存占用分析)
    - [4.3 优缺点分析](#43-优缺点分析)
  - [5. 最佳实践](#5-最佳实践)
    - [5.1 减少引用计数操作](#51-减少引用计数操作)
    - [5.2 延迟释放](#52-延迟释放)
  - [6. 扩展阅读](#6-扩展阅读)
  - [7. 权威参考](#7-权威参考)
    - [7.1 学术论文](#71-学术论文)
    - [7.2 官方文档](#72-官方文档)
    - [7.3 经典书籍](#73-经典书籍)
    - [7.4 在线资源](#74-在线资源)
    - [2. 延迟释放](#2-延迟释放)
  - [引用计数优化](#引用计数优化)
    - [1. 减少引用计数操作](#1-减少引用计数操作)
    - [2. 批量操作优化](#2-批量操作优化)
  - [内存泄漏检测](#内存泄漏检测)
    - [1. 引用计数检查](#1-引用计数检查)
    - [2. 内存统计](#2-内存统计)
  - [性能分析](#性能分析)
    - [1. 引用计数开销](#1-引用计数开销)
    - [2. 内存占用](#2-内存占用)
  - [扩展阅读](#扩展阅读)
  - [权威参考](#权威参考)

---

## 1. 概述

### 1.1 定义与历史背景

Redis使用引用计数（Reference Counting）作为内存管理机制，通过计数对象的引用次数来决定何时释放内存。理解引用计数GC对于优化Redis内存使用和性能至关重要。

**历史发展**：

- **1960年**：引用计数算法提出
- **2009年**：Redis 1.0使用引用计数
- **2020年代**：引用计数仍是Redis的主要GC机制

### 1.2 应用价值

引用计数GC在Redis中具有重要价值：

1. **简单高效**：实现简单，性能高
2. **实时回收**：引用计数为0时立即回收
3. **内存共享**：支持共享对象，节省内存
4. **无停顿**：不需要Stop-The-World

## 2. 引用计数原理

### 2.1 基本概念

```c
// 引用计数基本概念
// 1. 每个对象维护引用计数
// 2. 引用时计数+1
// 3. 解引用时计数-1
// 4. 计数为0时释放内存

// Redis对象结构
typedef struct redisObject {
    unsigned type:4;        // 对象类型
    unsigned encoding:4;    // 编码方式
    unsigned lru:LRU_BITS; // LRU时间戳
    int refcount;          // 引用计数
    void *ptr;             // 数据指针
} robj;
```

**引用计数基本概念**：

- **每个对象维护引用计数**：记录被引用的次数
- **引用时计数+1**：增加引用时计数加1
- **解引用时计数-1**：减少引用时计数减1
- **计数为0时释放内存**：引用计数为0时立即释放

### 2.2 引用计数操作

```c
// 增加引用计数
robj *incrRefCount(robj *o) {
    if (o->refcount != OBJ_SHARED_REFCOUNT) {
        o->refcount++;
    }
    return o;
}

// 减少引用计数
void decrRefCount(robj *o) {
    if (o->refcount == 1) {
        // 计数为1，释放对象
        switch(o->type) {
            case OBJ_STRING: freeStringObject(o); break;
            case OBJ_LIST: freeListObject(o); break;
            case OBJ_SET: freeSetObject(o); break;
            case OBJ_ZSET: freeZsetObject(o); break;
            case OBJ_HASH: freeHashObject(o); break;
            default: serverPanic("Unknown object type");
        }
        zfree(o);
    } else {
        if (o->refcount != OBJ_SHARED_REFCOUNT) {
            o->refcount--;
        }
    }
}
```

**定理 2.1**：引用计数操作的时间复杂度为O(1)。

**证明**：

- incrRefCount：O(1)（增加计数）
- decrRefCount：O(1)（减少计数）
- 释放对象：O(1)（平均情况）
- 总时间复杂度：O(1)

### 2.3 形式化定义

设对象为$o$，引用计数为$refcount(o)$。

**引用计数形式化定义**：

$$refcount(o) = \text{引用对象$o$的次数}$$

**引用计数规则**：

- **创建对象**：$refcount(o) = 1$
- **增加引用**：$refcount(o) = refcount(o) + 1$
- **减少引用**：$refcount(o) = refcount(o) - 1$
- **释放对象**：如果$refcount(o) = 0$，则释放$o$

## 3. 共享对象

### 3.1 共享对象机制

```c
// Redis使用共享对象减少内存占用
// 1. 小整数对象共享
// 2. 常用字符串对象共享
// 3. 引用计数为OBJ_SHARED_REFCOUNT（INT_MAX）

// 共享对象池
robj *sharedObjects[OBJ_SHARED_INTEGERS];

// 创建共享整数对象
robj *createStringObjectFromLongLong(long long value) {
    robj *o;

    // 小整数使用共享对象
    if (value >= 0 && value < OBJ_SHARED_INTEGERS) {
        incrRefCount(shared.integers[value]);
        return shared.integers[value];
    }

    // 大整数创建新对象
    if (value >= LONG_MIN && value <= LONG_MAX) {
        o = createObject(OBJ_STRING, NULL);
        o->encoding = OBJ_ENCODING_INT;
        o->ptr = (void*)((long)value);
    } else {
        o = createObject(OBJ_STRING, sdsfromlonglong(value));
    }
    return o;
}
```

**共享对象机制**：

- **小整数对象共享**：0-9999的小整数共享
- **引用计数为INT_MAX**：共享对象引用计数为INT_MAX
- **节省内存**：减少内存占用

**定理 3.1**：共享对象可以节省约40KB内存（10000个小整数）。

**证明**：

- 每个小整数对象：~40字节
- 10000个小整数：$10000 \times 40 = 400KB$
- 共享对象：只需40KB
- 节省内存：$400KB - 40KB = 360KB$

### 3.2 共享对象限制

```c
// 共享对象限制
// 1. 只共享小整数（0-9999）
// 2. 不共享字符串对象（避免修改）
// 3. 共享对象引用计数为INT_MAX

#define OBJ_SHARED_INTEGERS 10000
#define OBJ_SHARED_REFCOUNT INT_MAX
```

**共享对象限制**：

- **只共享小整数（0-9999）**：避免内存浪费
- **不共享字符串对象**：避免修改问题
- **共享对象引用计数为INT_MAX**：永不释放

## 4. 性能分析

### 4.1 引用计数开销

**引用计数开销**：

| 操作 | 开销 | 说明 |
|------|------|------|
| **incrRefCount** | ~1ns | 增加计数 |
| **decrRefCount** | ~1ns | 减少计数 |
| **object_free** | ~10-100ns | 释放对象 |

**定理 4.1**：引用计数操作的开销为O(1)，非常小。

**证明**：

- incrRefCount：O(1)（原子操作）
- decrRefCount：O(1)（原子操作）
- 总开销：O(1)

### 4.2 内存占用分析

**内存占用**：

| 组件 | 内存占用 | 说明 |
|------|----------|------|
| **每个对象** | 4字节 | refcount字段 |
| **共享对象** | ~40KB | 10000个小整数 |

### 4.3 优缺点分析

**优点**：

- **简单高效**：实现简单，性能高
- **实时回收**：引用计数为0时立即回收
- **无停顿**：不需要Stop-The-World

**缺点**：

- **循环引用**：无法处理循环引用
- **引用计数开销**：每次引用都需要更新计数

## 5. 最佳实践

### 5.1 减少引用计数操作

**优化建议**：

- **函数内部临时使用不增加引用**：减少不必要的操作
- **返回值才增加引用**：避免过度引用
- **避免循环引用**：设计时避免循环引用

### 5.2 延迟释放

**延迟释放**：

- **大对象延迟释放**：避免阻塞主线程
- **使用后台线程释放**：提高性能

## 6. 扩展阅读

- [内存分配与回收](./03.04.01-内存分配与回收.md)
- [内存碎片整理](./03.04.02-内存碎片整理.md)
- [内存监控](./03.04.03-内存监控.md)

## 7. 权威参考

### 7.1 学术论文

1. **"Reference Counting Garbage Collection"** - George E. Collins, Communications of the ACM, 1960
   - 引用计数算法的原始论文
   - DOI: 10.1145/367177.367190
   - 详细描述了引用计数的设计和实现

### 7.2 官方文档

1. **Redis源码 - object.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/object.c>
   - 版本: Redis 1.0+
   - 引用计数的完整实现源码

### 7.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111464747
   - 第12章：内存管理（引用计数GC详解）

2. **《垃圾回收算法手册：自动内存管理的艺术》** - Richard Jones, Antony Hosking, Eliot Moss
   - 出版社: 机械工业出版社
   - ISBN: 978-7111544937
   - 第2章：引用计数（引用计数算法详解）

### 7.4 在线资源

1. **Wikipedia - Reference Counting**
   - URL: <https://en.wikipedia.org/wiki/Reference_counting>
   - 提供引用计数的详细说明

```c
// 字符串对象释放
void freeStringObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_RAW) {
        sdsfree(o->ptr);
    }
}

// 列表对象释放
void freeListObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_QUICKLIST) {
        quicklistRelease(o->ptr);
    } else if (o->encoding == OBJ_ENCODING_ZIPLIST) {
        zfree(o->ptr);
    }
}

// 哈希对象释放
void freeHashObject(robj *o) {
    if (o->encoding == OBJ_ENCODING_HT) {
        dictRelease((dict*)o->ptr);
    } else if (o->encoding == OBJ_ENCODING_ZIPLIST) {
        zfree(o->ptr);
    }
}
```

### 2. 延迟释放

```c
// 延迟释放（BIO）
// 1. 大对象延迟释放
// 2. 避免阻塞主线程
// 3. 使用后台线程释放

void lazyfreeFreeObject(robj *o) {
    if (sdslen(o->ptr) > LAZYFREE_THRESHOLD) {
        // 大对象延迟释放
        bioCreateBackgroundJob(BIO_LAZY_FREE, o, NULL, NULL);
    } else {
        // 小对象立即释放
        decrRefCount(o);
    }
}
```

## 引用计数优化

### 1. 减少引用计数操作

```c
// 优化：减少不必要的引用计数操作
// 1. 函数内部临时使用不增加引用
// 2. 返回值才增加引用
// 3. 避免循环引用

// 好的实践
robj *getObject(robj *o) {
    return incrRefCount(o);  // 返回时增加引用
}

// 避免循环引用
// 对象A引用对象B，对象B不引用对象A
```

### 2. 批量操作优化

```c
// 批量操作优化
// 1. 减少中间对象的引用计数
// 2. 使用对象池
// 3. 延迟释放

// 批量操作示例
void batchOperation(robj **objects, int count) {
    // 批量处理，减少引用计数操作
    for (int i = 0; i < count; i++) {
        processObject(objects[i]);
        // 不立即释放，批量释放
    }
    // 批量释放
    for (int i = 0; i < count; i++) {
        decrRefCount(objects[i]);
    }
}
```

## 内存泄漏检测

### 1. 引用计数检查

```c
// 引用计数检查
void checkRefCount(robj *o) {
    if (o->refcount < 0) {
        serverLog(LL_WARNING, "Object refcount < 0: %d", o->refcount);
    }
    if (o->refcount > OBJ_SHARED_REFCOUNT && o->refcount > 1000) {
        serverLog(LL_WARNING, "Object refcount too high: %d", o->refcount);
    }
}
```

### 2. 内存统计

```c
// 内存统计
void memoryStats(void) {
    // 统计对象数量
    // 统计引用计数分布
    // 检测内存泄漏
}
```

## 性能分析

### 1. 引用计数开销

```python
# 引用计数开销
class RefCountOverhead:
    def analyze(self):
        return {
            'incr_refcount': '~1ns',
            'decr_refcount': '~1ns',
            'object_free': '~10-100ns',
        }
```

### 2. 内存占用

```python
# 引用计数内存占用
class RefCountMemory:
    def analyze(self):
        return {
            'per_object': '4 bytes (refcount字段)',
            'shared_objects': '~40KB (10000个小整数)',
        }
```

## 扩展阅读

- [内存分配与回收](./03.04.01-内存分配与回收.md)
- [内存碎片整理](./03.04.02-内存碎片整理.md)
- [内存监控](./03.04.03-内存监控.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **引用计数GC** - Reference Counting Garbage Collection
