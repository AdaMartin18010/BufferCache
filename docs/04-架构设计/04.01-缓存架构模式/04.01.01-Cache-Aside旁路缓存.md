# 04.01.01 Cache-Aside旁路缓存

## 概述

Cache-Aside（旁路缓存）是最常用的缓存模式，应用程序负责维护缓存和数据库的一致性。缓存不作为数据源，而是作为数据库的"旁路"加速层。

## 核心思想

### 设计原则

1. **缓存不作为数据源**：数据始终存储在数据库中
2. **应用程序控制缓存**：由应用代码决定何时读取/写入缓存
3. **缓存失效策略**：数据更新时删除缓存，下次读取时重新加载

### 工作流程

```
┌─────────┐         ┌─────────┐         ┌─────────┐
│  应用   │────────▶│  缓存   │         │  数据库  │
└─────────┘         └─────────┘         └─────────┘
     │                   │                   │
     │  1. 读取缓存       │                   │
     │◀──────────────────│                   │
     │                   │                   │
     │  2. 缓存未命中     │                   │
     │──────────────────────────────────────▶│
     │                   │  3. 查询数据库      │
     │◀──────────────────────────────────────│
     │                   │  4. 返回数据       │
     │                   │                   │
     │  5. 写入缓存       │                   │
     │──────────────────▶│                   │
     │                   │                   │
```

## 实现模式

### 读取流程

```python
def get_user(user_id):
    # 1. 先查缓存
    cache_key = f"user:{user_id}"
    user = cache.get(cache_key)

    if user is not None:
        return user  # 缓存命中

    # 2. 缓存未命中，查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if user is None:
        return None  # 数据不存在

    # 3. 写入缓存
    cache.set(cache_key, user, ttl=3600)

    return user
```

### 写入流程

```python
def update_user(user_id, user_data):
    # 1. 更新数据库
    db.execute("UPDATE users SET ... WHERE id = ?", user_id, user_data)

    # 2. 删除缓存（让下次读取时重新加载）
    cache_key = f"user:{user_id}"
    cache.delete(cache_key)

    return True
```

### 删除流程

```python
def delete_user(user_id):
    # 1. 删除数据库记录
    db.execute("DELETE FROM users WHERE id = ?", user_id)

    # 2. 删除缓存
    cache_key = f"user:{user_id}"
    cache.delete(cache_key)

    return True
```

## 一致性保证

### 最终一致性模型

Cache-Aside保证**最终一致性**，而非强一致性：

1. **写入时**：先更新数据库，再删除缓存
2. **读取时**：缓存未命中则从数据库加载
3. **时间窗口**：更新到缓存失效之间存在短暂不一致窗口

### 一致性风险场景

#### 场景1：并发更新

```
时间线：
T1: 线程A更新数据库 user.name = "Alice"
T2: 线程A删除缓存
T3: 线程B更新数据库 user.name = "Bob"
T4: 线程B删除缓存
T5: 线程C读取缓存（未命中）
T6: 线程C从数据库读取（可能是Alice或Bob）
T7: 线程C写入缓存
```

**问题**：如果T6读取到旧值，缓存会被旧数据污染。

**解决方案**：

- 使用版本号或时间戳
- 使用分布式锁保证更新顺序

#### 场景2：缓存穿透

```python
# 问题：大量请求查询不存在的数据
def get_user(user_id):
    user = cache.get(f"user:{user_id}")
    if user is None:
        user = db.query("SELECT * FROM users WHERE id = ?", user_id)
        if user:
            cache.set(f"user:{user_id}", user)
        # 问题：如果user为None，每次都会查询数据库
    return user

# 解决方案：缓存空值
def get_user(user_id):
    user = cache.get(f"user:{user_id}")
    if user is not None:
        if user == "NULL":  # 空值标记
            return None
        return user

    user = db.query("SELECT * FROM users WHERE id = ?", user_id)
    if user:
        cache.set(f"user:{user_id}", user, ttl=3600)
    else:
        cache.set(f"user:{user_id}", "NULL", ttl=60)  # 短TTL缓存空值

    return user
```

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **读取性能** | 缓存命中时延迟极低（<1ms） |
| **写入性能** | 只更新数据库，不阻塞写入 |
| **实现简单** | 逻辑清晰，易于理解和维护 |
| **灵活性高** | 可以针对不同数据设置不同策略 |

### 劣势

| 特性 | 说明 |
|------|------|
| **一致性** | 只能保证最终一致性 |
| **缓存穿透** | 需要额外处理空值情况 |
| **双写问题** | 需要同时操作缓存和数据库 |
| **缓存雪崩** | 大量缓存同时失效可能导致数据库压力 |

## 优化策略

### 1. 预热缓存

```python
# 系统启动时预热热点数据
def warmup_cache():
    hot_users = db.query("SELECT * FROM users WHERE is_hot = 1")
    for user in hot_users:
        cache.set(f"user:{user.id}", user, ttl=3600)
```

### 2. 异步更新

```python
# 使用消息队列异步更新缓存
def update_user(user_id, user_data):
    # 1. 更新数据库
    db.execute("UPDATE users SET ... WHERE id = ?", user_id, user_data)

    # 2. 发送消息到队列
    message_queue.publish("user_updated", {"user_id": user_id})

    return True

# 消费者异步删除缓存
def cache_update_consumer(message):
    user_id = message["user_id"]
    cache.delete(f"user:{user_id}")
```

### 3. 批量操作

```python
# 批量读取，减少缓存访问次数
def get_users(user_ids):
    # 1. 批量从缓存读取
    cache_keys = [f"user:{uid}" for uid in user_ids]
    cached_users = cache.mget(cache_keys)

    # 2. 找出未命中的ID
    missing_ids = [uid for uid, user in zip(user_ids, cached_users) if user is None]

    # 3. 批量查询数据库
    if missing_ids:
        db_users = db.query("SELECT * FROM users WHERE id IN ?", missing_ids)
        # 批量写入缓存
        for user in db_users:
            cache.set(f"user:{user.id}", user, ttl=3600)
        # 更新cached_users
        # ...

    return cached_users
```

## 适用场景

### 优势场景

1. **读多写少**
   - 缓存命中率高
   - 写入不阻塞

2. **数据更新频率低**
   - 减少缓存失效
   - 提升缓存命中率

3. **对一致性要求不高**
   - 可以容忍短暂不一致
   - 最终一致性可接受

### 不适用场景

1. **强一致性要求**
   - 金融支付场景
   - 建议使用Write-Through

2. **写入密集型**
   - 频繁更新导致缓存频繁失效
   - 建议使用Write-Behind

## 与其他模式对比

详见：[多维概念矩阵对比](../../00-项目总览/多维概念矩阵对比.md#3-缓存架构模式决策矩阵)

## 扩展阅读

- [Read-Through透读缓存](./04.01.02-Read-Through透读缓存.md)
- [Write-Through透写缓存](./04.01.03-Write-Through透写缓存.md)
- [缓存问题与治理](../04.04-缓存问题与治理/README.md)

## 权威参考

- **《企业应用架构模式》** - Martin Fowler
- **《分布式系统概念与设计》** - 分布式系统经典教材
- **AWS架构最佳实践** - Cache-Aside模式
