# 04.01.03 Write-Through透写缓存

## 概述

Write-Through（透写缓存）是一种缓存模式，应用程序写入数据时，同时写入缓存和数据库，保证数据一致性。这种模式适用于对一致性要求极高的场景，如金融支付系统。

## 核心思想

### 设计原则

1. **双写保证**：同时写入缓存和数据库
2. **强一致性**：保证缓存和数据库数据一致
3. **同步写入**：写入操作同步完成

### 工作流程

```
┌─────────┐         ┌─────────┐         ┌─────────┐
│  应用   │────────▶│  缓存   │         │  数据库  │
└─────────┘         └─────────┘         └─────────┘
     │                   │                   │
     │  1. 写入请求       │                   │
     │──────────────────▶│                   │
     │                   │  2. 写入数据库     │
     │                   │──────────────────▶│
     │                   │  3. 写入成功       │
     │                   │◀──────────────────│
     │                   │                   │
     │  4. 写入缓存       │                   │
     │                   │──────────────────▶│
     │                   │                   │
     │  5. 返回成功       │                   │
     │◀──────────────────│                   │
```

## 实现模式

### 基础实现

```python
class WriteThroughCache:
    def __init__(self, cache_client, db_client):
        self.cache = cache_client
        self.db = db_client

    def set(self, key, value):
        # 1. 先写数据库
        try:
            self.db.set(key, value)
        except Exception as e:
            # 数据库写入失败，不写缓存
            raise e

        # 2. 数据库写入成功，再写缓存
        try:
            self.cache.set(key, value, ttl=3600)
        except Exception as e:
            # 缓存写入失败，记录日志但不影响整体
            logger.warning(f"Cache write failed: {e}")

        return True
```

### 事务保证实现

```python
class WriteThroughCacheWithTransaction:
    def __init__(self, cache_client, db_client):
        self.cache = cache_client
        self.db = db_client

    def set(self, key, value):
        # 使用数据库事务保证一致性
        with self.db.transaction():
            # 1. 写入数据库
            self.db.set(key, value)

            # 2. 写入缓存（在同一事务中）
            # 注意：Redis不支持事务，这里需要特殊处理
            self.cache.set(key, value, ttl=3600)

            # 3. 提交事务
            self.db.commit()

        return True
```

### 金融场景实现（XA事务）

```python
class FinancialWriteThroughCache:
    def __init__(self, cache_client, db_client):
        self.cache = cache_client
        self.db = db_client

    def transfer(self, from_account, to_account, amount):
        # 使用XA事务保证强一致性
        xid = self.db.xa_start()

        try:
            # 1. 扣减转出账户
            self.db.execute(
                "UPDATE accounts SET balance = balance - ? WHERE id = ?",
                amount, from_account
            )

            # 2. 增加转入账户
            self.db.execute(
                "UPDATE accounts SET balance = balance + ? WHERE id = ?",
                amount, to_account
            )

            # 3. 写入Redis（在XA事务中）
            self.cache.decrby(f"balance:{from_account}", amount)
            self.cache.incrby(f"balance:{to_account}", amount)

            # 4. 准备阶段
            self.db.xa_prepare(xid)

            # 5. 提交阶段
            self.db.xa_commit(xid)

            return True

        except Exception as e:
            # 回滚
            self.db.xa_rollback(xid)
            raise e
```

## 一致性保证

### 强一致性模型

Write-Through保证**强一致性**：

1. **写入时**：先写数据库，成功后再写缓存
2. **读取时**：缓存未命中则从数据库加载
3. **失败处理**：数据库写入失败，不写缓存

### 一致性风险场景

#### 场景1：数据库写入成功，缓存写入失败

```
时间线：
T1: 写入数据库成功
T2: 写入缓存失败
T3: 读取缓存（未命中）
T4: 从数据库读取（数据正确）
```

**影响**：缓存不一致，但数据正确。下次读取会重新加载到缓存。

**解决方案**：
- 重试机制
- 监控告警
- 定期校验

#### 场景2：并发写入

```
时间线：
T1: 线程A写入 key=1, value=A
T2: 线程B写入 key=1, value=B
T3: 线程A写数据库完成
T4: 线程B写数据库完成
T5: 线程A写缓存完成（value=A）
T6: 线程B写缓存完成（value=B）
```

**问题**：最终缓存值是B，但可能不是期望的顺序。

**解决方案**：
- 使用分布式锁
- 使用版本号
- 使用CAS操作

## 性能特征

### 优势

| 特性 | 说明 |
|------|------|
| **强一致性** | 缓存和数据库数据一致 |
| **数据安全** | 数据始终在数据库中 |
| **简化逻辑** | 写入逻辑统一 |

### 劣势

| 特性 | 说明 |
|------|------|
| **写入延迟** | 需要等待数据库写入完成 |
| **性能影响** | 写入性能受数据库限制 |
| **复杂度** | 需要处理失败场景 |

## 适用场景

### 优势场景

1. **金融支付系统**
   - 强一致性要求
   - 数据不能丢失
   - 可以接受性能损失

2. **账务系统**
   - 账户余额必须准确
   - 需要审计追踪
   - 强一致性必需

3. **配置管理**
   - 配置变更需要立即生效
   - 缓存和数据库必须一致

### 不适用场景

1. **高性能写入场景**
   - 写入QPS要求高
   - 建议使用Write-Behind

2. **最终一致性可接受**
   - 可以容忍短暂不一致
   - Cache-Aside更合适

## 优化策略

### 1. 异步写入缓存

```python
import asyncio

async def async_set(self, key, value):
    # 1. 同步写数据库
    await self.db.set(key, value)

    # 2. 异步写缓存（不阻塞）
    asyncio.create_task(self.cache.set(key, value))

    return True
```

**注意**：这会降低一致性保证，需要根据场景权衡。

### 2. 批量写入

```python
def batch_set(self, items):
    # 1. 批量写数据库
    self.db.batch_set(items)

    # 2. 批量写缓存
    self.cache.mset(items)

    return True
```

### 3. 写入队列

```python
from queue import Queue

class WriteThroughCacheWithQueue:
    def __init__(self, cache_client, db_client):
        self.cache = cache_client
        self.db = db_client
        self.write_queue = Queue()
        self.start_worker()

    def set(self, key, value):
        # 1. 写数据库
        self.db.set(key, value)

        # 2. 加入写入队列
        self.write_queue.put((key, value))

        return True

    def start_worker(self):
        def worker():
            while True:
                key, value = self.write_queue.get()
                try:
                    self.cache.set(key, value)
                except Exception as e:
                    logger.error(f"Cache write failed: {e}")
                finally:
                    self.write_queue.task_done()

        threading.Thread(target=worker, daemon=True).start()
```

## 与其他模式对比

详见：[多维概念矩阵对比](../../00-项目总览/多维概念矩阵对比.md#3-缓存架构模式决策矩阵)

## 扩展阅读

- [Cache-Aside旁路缓存](./04.01.01-Cache-Aside旁路缓存.md)
- [Read-Through透读缓存](./04.01.02-Read-Through透读缓存.md)
- [Write-Behind异步写缓存](./04.01.04-Write-Behind异步写缓存.md)
- [金融科技支付架构](../04.03-行业应用场景/04.03.02-金融科技支付架构.md)

## 权威参考

- **《企业应用架构模式》** - Martin Fowler
- **《分布式系统概念与设计》** - 分布式系统经典教材
- **XA事务规范** - X/Open组织
