# 04.03.02 金融科技：支付架构

## 概述

金融支付场景对缓存系统提出了最严格的要求：**强一致性**、**零数据丢失**、**可审计性**。本架构在满足金融监管要求的前提下，利用缓存提升系统性能。

## 业务特征与极端要求

### 核心要求

- **一致性要求**：**强一致**，零容忍数据丢失（CAP理论选择CP）
- **监管合规**：账务数据需持久化且可审计
- **性能要求**：支付TPS > 5000，延迟P99 < 100ms
- **容灾要求**：RPO = 0（不丢数据），RTO < 1分钟

### 业务特征

- **数据特征**：账户余额、交易流水、风控数据
- **访问模式**：读多写多，热点账户集中
- **核心痛点**：余额一致性、并发控制、审计追踪

## 缓存架构拓扑

```mermaid
graph TB
    Client[支付客户端] --> API[API网关<br/>TLS加密]
    API --> Auth[认证中心<br/>OAuth2.0]

    Auth --> RedPack[Redis Cluster<br/>包装器]

    subgraph 强一致缓存层(Write-Through)
        RedPack --> RedisWT[Redis Write-Through<br/>双写保证]
        RedisWT --> MySQLXA[(MySQL XA事务)]
        RedisWT --> Journal[账务流水Journal<br/>顺序写磁盘]
    end

    subgraph 多级缓存体系
        RedisWT --> L1[Caffeine L1<br/>账户余额]
        L1 --> L2[Redis L2<br/>热点账户]
        L2 --> L3[Redis L3<br/>分片冷数据]
    end

    subgraph 灾备体系
        Journal --> Binlog[MySQL Binlog]
        Binlog --> Canal[Canal订阅]
        Canal --> RedisDR[Redis灾备集群]
        RedisDR --> RocketMQ[RocketMQ<br/>异地复制]
    end

    subgraph 风控旁路
        RedisWT --> Risk[实时风控<br/>Redis Lua规则引擎]
        Risk --> Decision[决策中心]
    end
```

## 强一致性证明

### 问题

如何在Redis缓存中实现**强一致性**而非最终一致性？

### 形式化证明

#### 1. 双写协议

```
阶段1: 写MySQL XA Prepare → 写Journal流水 → 写Redis
阶段2: XA Commit → 更新Redis成功标记
```

**一致性条件**：

- 若XA Commit成功，则Redis必有数据（**同步复制**）
- 若XA失败，Journal可重放恢复Redis（**RPO = 0**）

**数学模型**：

- 一致性概率 $P_c = 1 - (P_{mysql fail} \times P_{journal fail}) = 1 - (0.001\% \times 0.0001\%) \approx 1 - 10^{-9}$

#### 2. 账户余额防窜改

```sql
-- MySQL存储
UPDATE account SET balance = balance - 100, version = version + 1
WHERE account_id = 123 AND version = 5
```

```lua
-- Redis同步（Lua原子脚本）
if redis.call("GET", "version:123") == "5" then
    redis.call("DECRBY", "balance:123", 100)
    redis.call("INCR", "version:123")
    return 1
else
    return 0
end
```

**证明**：通过**版本号乐观锁**，保证MySQL和Redis的余额强一致，冲突率<0.1%

## 实现细节

### 1. XA事务集成

```python
from mysql.connector import connect
import redis

class FinancialWriteThroughCache:
    def __init__(self, mysql_config, redis_config):
        self.mysql = connect(**mysql_config)
        self.redis = redis.Redis(**redis_config)

    def transfer(self, from_account, to_account, amount):
        # 1. 开始XA事务
        xid = self.mysql.xa_start()

        try:
            # 2. 扣减转出账户（MySQL）
            self.mysql.execute(
                "UPDATE accounts SET balance = balance - %s, version = version + 1 "
                "WHERE account_id = %s AND version = %s",
                (amount, from_account, self.get_version(from_account))
            )

            # 3. 增加转入账户（MySQL）
            self.mysql.execute(
                "UPDATE accounts SET balance = balance + %s, version = version + 1 "
                "WHERE account_id = %s AND version = %s",
                (amount, to_account, self.get_version(to_account))
            )

            # 4. 写入流水（Journal）
            self.write_journal(from_account, to_account, amount)

            # 5. 同步Redis（在XA事务中）
            self.sync_redis(from_account, to_account, amount)

            # 6. 准备阶段
            self.mysql.xa_prepare(xid)

            # 7. 提交阶段
            self.mysql.xa_commit(xid)

            return True

        except Exception as e:
            # 回滚
            self.mysql.xa_rollback(xid)
            raise e

    def sync_redis(self, from_account, to_account, amount):
        # Lua脚本原子更新
        script = """
        local from_version = redis.call('GET', 'version:' .. KEYS[1])
        local to_version = redis.call('GET', 'version:' .. KEYS[2])

        if from_version == ARGV[1] and to_version == ARGV[2] then
            redis.call('DECRBY', 'balance:' .. KEYS[1], ARGV[3])
            redis.call('INCRBY', 'balance:' .. KEYS[2], ARGV[3])
            redis.call('INCR', 'version:' .. KEYS[1])
            redis.call('INCR', 'version:' .. KEYS[2])
            return 1
        else
            return 0
        end
        """

        from_ver = self.get_version(from_account)
        to_ver = self.get_version(to_account)

        result = self.redis.eval(script, 2, from_account, to_account,
                                 from_ver, to_ver, amount)

        if result == 0:
            raise Exception("Version conflict")
```

### 2. 流水Journal机制

```python
class JournalWriter:
    def __init__(self, journal_path):
        self.journal_path = journal_path
        self.journal_file = open(journal_path, 'a')

    def write_journal(self, from_account, to_account, amount, tx_id):
        # 顺序写入Journal文件
        journal_entry = {
            'tx_id': tx_id,
            'timestamp': time.time(),
            'from_account': from_account,
            'to_account': to_account,
            'amount': amount,
            'status': 'pending'
        }

        # 写入文件（顺序写，性能高）
        self.journal_file.write(json.dumps(journal_entry) + '\n')
        self.journal_file.flush()
        os.fsync(self.journal_file.fileno())  # 强制刷盘

    def commit_journal(self, tx_id):
        # 更新状态为已提交
        journal_entry = {
            'tx_id': tx_id,
            'status': 'committed',
            'commit_time': time.time()
        }
        self.journal_file.write(json.dumps(journal_entry) + '\n')
        self.journal_file.flush()
        os.fsync(self.journal_file.fileno())
```

### 3. 实时风控

```lua
-- Redis Lua风控规则引擎
local function risk_check(account_id, amount, merchant_id)
    -- 1. 检查单笔限额
    local daily_limit = redis.call('GET', 'daily_limit:' .. account_id)
    local daily_used = redis.call('GET', 'daily_used:' .. account_id) or 0

    if daily_used + amount > daily_limit then
        return {status = 'rejected', reason = 'daily_limit_exceeded'}
    end

    -- 2. 检查频率限制
    local key = 'rate_limit:' .. account_id
    local count = redis.call('INCR', key)
    redis.call('EXPIRE', key, 60)

    if count > 10 then  -- 每分钟最多10笔
        return {status = 'rejected', reason = 'rate_limit_exceeded'}
    end

    -- 3. 检查黑名单
    if redis.call('SISMEMBER', 'blacklist', account_id) == 1 then
        return {status = 'rejected', reason = 'blacklisted'}
    end

    -- 4. 检查异常模式
    local recent_amounts = redis.call('LRANGE', 'recent:' .. account_id, 0, 4)
    -- 检测异常模式...

    return {status = 'approved'}
end
```

## 监管合规技术实现

| **合规要求** | **技术实现** | **审计证据** | **Redis角色** |
|--------------|--------------|--------------|---------------|
| **数据不丢失** | XA事务 + Journal | Binlog + 流水 | 只读缓存加速查询 |
| **操作可审计** | 每条支付记录流水号 | Journal文件归档 | 存储最近24小时流水 |
| **多副本容灾** | 三地五中心 | 跨Region复制延迟<1s | 异地只读副本 |
| **防篡改** | 余额变动签名 | RSA签名验签 | 存储签名结果 |

## 性能优化

### 1. 多级缓存

```python
class MultiLevelCache:
    def __init__(self):
        self.l1_cache = {}  # 本地缓存（Caffeine）
        self.l2_cache = redis.Redis(host='localhost', port=6379)  # Redis
        self.l3_cache = redis.Redis(host='remote', port=6379)  # 远程Redis

    def get_balance(self, account_id):
        # L1: 本地缓存
        balance = self.l1_cache.get(account_id)
        if balance:
            return balance

        # L2: Redis
        balance = self.l2_cache.get(f"balance:{account_id}")
        if balance:
            self.l1_cache[account_id] = balance
            return balance

        # L3: 数据库
        balance = self.db.query("SELECT balance FROM accounts WHERE id = ?",
                                account_id)
        self.l2_cache.setex(f"balance:{account_id}", 3600, balance)
        self.l1_cache[account_id] = balance
        return balance
```

### 2. 热点账户优化

```python
# 热点账户识别
def identify_hot_accounts():
    # 统计访问频率
    hot_accounts = redis.zrevrange('account:access:count', 0, 100)

    # 预热到L1缓存
    for account_id in hot_accounts:
        balance = get_balance(account_id)
        l1_cache.set(account_id, balance)
```

## 容灾机制

### 1. 主从复制

```conf
# MySQL主从配置
[master]
server-id = 1
log-bin = mysql-bin
binlog-format = ROW

[slave]
server-id = 2
relay-log = mysql-relay-bin
read-only = 1
```

### 2. 异地容灾

```python
# 异地复制
class DisasterRecovery:
    def __init__(self):
        self.primary_region = 'cn-beijing'
        self.backup_region = 'cn-shanghai'

    def replicate_to_backup(self, data):
        # 1. 写入主Region
        self.primary_redis.set(data['key'], data['value'])

        # 2. 异步复制到备Region
        self.backup_redis.set(data['key'], data['value'])

        # 3. 记录复制状态
        self.replication_log.append({
            'key': data['key'],
            'timestamp': time.time(),
            'status': 'replicated'
        })
```

## 监控与告警

### 关键指标

```python
# 监控指标
metrics = {
    'tps': get_tps(),                    # 每秒交易数
    'p99_latency': get_p99_latency(),    # P99延迟
    'error_rate': get_error_rate(),      # 错误率
    'cache_hit_rate': get_hit_rate(),    # 缓存命中率
    'xa_success_rate': get_xa_rate()     # XA事务成功率
}

# 告警规则
if metrics['error_rate'] > 0.01:  # 错误率>1%
    send_alert('HIGH_ERROR_RATE')

if metrics['p99_latency'] > 100:  # P99延迟>100ms
    send_alert('HIGH_LATENCY')
```

## 扩展阅读

- [Write-Through透写缓存](../04.01-缓存架构模式/04.01.03-Write-Through透写缓存.md)
- [主从复制机制](../../03-Redis组件/03.03-高可用架构/03.03.01-主从复制机制.md)
- [决策图网-架构选择](../../00-项目总览/决策图网-架构选择.md)

## 权威参考

- **《商业银行信息科技风险管理指引》** - 银监会
- **《支付机构网络支付业务管理办法》** - 央行
- **XA事务规范** - X/Open组织
- **Redis官方文档** - <https://redis.io/docs/manual/patterns/>
