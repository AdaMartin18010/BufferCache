# 04.04.01 缓存穿透

## 目录

- [04.04.01 缓存穿透](#040401-缓存穿透)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 问题影响](#12-问题影响)
  - [2. 问题场景](#2-问题场景)
    - [2.1 典型场景](#21-典型场景)
    - [2.2 风险传导](#22-风险传导)
  - [3. 问题原因](#3-问题原因)
    - [3.1 根本原因](#31-根本原因)
    - [3.2 示例代码](#32-示例代码)
  - [4. 解决方案](#4-解决方案)
    - [4.1 方案1：缓存空值](#41-方案1缓存空值)
    - [4.2 方案2：布隆过滤器](#42-方案2布隆过滤器)
    - [方案3：Redis布隆过滤器（Redis 4.0+）](#方案3redis布隆过滤器redis-40)
  - [性能对比](#性能对比)
  - [5. 性能分析](#5-性能分析)
    - [5.1 方案对比](#51-方案对比)
    - [5.2 性能影响](#52-性能影响)
  - [6. 最佳实践](#6-最佳实践)
    - [6.1 组合方案](#61-组合方案)
    - [6.2 预热布隆过滤器](#62-预热布隆过滤器)
    - [6.3 监控告警](#63-监控告警)
  - [7. 程序设计分析](#7-程序设计分析)
    - [7.1 设计模式应用](#71-设计模式应用)
    - [7.2 代码结构分析](#72-代码结构分析)
    - [7.3 设计权衡](#73-设计权衡)
    - [7.4 可扩展性分析](#74-可扩展性分析)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [8.1 经典书籍](#81-经典书籍)
    - [8.2 在线资源](#82-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**缓存穿透**是指查询一个**不存在的数据**，由于缓存未命中，请求穿透到数据库，如果大量这样的请求，可能导致数据库压力过大甚至崩溃。

**历史发展**：

- **2000年代**：缓存穿透问题在大型网站中出现
- **2010年代**：布隆过滤器成为解决缓存穿透的标准方案
- **2020年代**：缓存穿透成为缓存架构设计的核心问题

### 1.2 问题影响

缓存穿透的影响：

1. **数据库压力**：大量请求穿透到数据库
2. **服务不可用**：数据库连接池耗尽
3. **性能下降**：响应时间增加
4. **资源浪费**：无效查询浪费资源

## 2. 问题场景

### 2.1 典型场景

```text
用户请求 → 缓存查询（未命中） → 数据库查询（不存在） → 返回空结果
         ↓
    大量并发请求
         ↓
    数据库压力过大
```

### 2.2 风险传导

```text
缓存穿透 → 数据库QPS激增 → 数据库连接池耗尽 → 服务不可用
```

## 3. 问题原因

### 3.1 根本原因

1. **业务逻辑**：查询不存在的数据（如不存在的用户ID）
2. **恶意攻击**：故意查询不存在的数据
3. **缓存未命中**：缓存中没有对应数据

### 3.2 示例代码

```python
# 问题代码
def get_user(user_id):
    # 1. 查询缓存
    user = cache.get(f"user:{user_id}")
    if user:
        return user

    # 2. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if user:
        # 3. 写入缓存
        cache.set(f"user:{user_id}", user, ttl=3600)
    else:
        # 问题：不存在的数据不缓存，下次请求还会穿透
        pass

    return user  # 返回None
```

## 4. 解决方案

### 4.1 方案1：缓存空值

```python
# 解决方案：缓存空值
def get_user(user_id):
    # 1. 查询缓存
    user = cache.get(f"user:{user_id}")
    if user is not None:
        if user == "NULL":  # 空值标记
            return None
        return user

    # 2. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if user:
        # 3. 缓存真实数据
        cache.set(f"user:{user_id}", user, ttl=3600)
    else:
        # 4. 缓存空值（短TTL）
        cache.set(f"user:{user_id}", "NULL", ttl=60)  # 60秒TTL

    return user
```

**优势**：

- 实现简单
- 有效防止穿透

**劣势**：

- 占用缓存空间
- 需要定期清理

**定理 4.1**：缓存空值可以将缓存穿透的数据库查询减少到0（在TTL内）。

**证明**：

- 不存在的数据查询：缓存空值，TTL内不再查询数据库
- 数据库查询次数：0（在TTL内）
- 因此：缓存穿透的数据库查询减少到0

### 4.2 方案2：布隆过滤器

```python
from pybloom_live import BloomFilter

class CacheWithBloomFilter:
    def __init__(self, cache_client, db_client, capacity=1000000, error_rate=0.001):
        self.cache = cache_client
        self.db = db_client
        self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate)
        self.init_bloom_filter()

    def init_bloom_filter(self):
        # 初始化：将所有存在的key加入布隆过滤器
        all_keys = self.db.query("SELECT id FROM users")
        for key in all_keys:
            self.bloom.add(f"user:{key}")

    def get_user(self, user_id):
        cache_key = f"user:{user_id}"

        # 1. 布隆过滤器检查
        if cache_key not in self.bloom:
            # 肯定不存在，直接返回
            return None

        # 2. 查询缓存
        user = self.cache.get(cache_key)
        if user:
            return user

        # 3. 查询数据库
        user = self.db.query("SELECT * FROM users WHERE id = ?", user_id)

        if user:
            # 4. 写入缓存
            self.cache.set(cache_key, user, ttl=3600)
        else:
            # 5. 缓存空值
            self.cache.set(cache_key, "NULL", ttl=60)

        return user
```

**优势**：

- 内存占用小
- 查询速度快（O(1)）
- 误判率可控

**劣势**：

- 需要初始化
- 不支持删除（需要重建）

### 方案3：Redis布隆过滤器（Redis 4.0+）

```python
import redis

class CacheWithRedisBloom:
    def __init__(self, redis_client, db_client):
        self.redis = redis_client
        self.db = db_client
        self.init_bloom_filter()

    def init_bloom_filter(self):
        # 创建布隆过滤器
        self.redis.execute_command('BF.RESERVE', 'users', '0.001', '1000000')

        # 初始化数据
        all_keys = self.db.query("SELECT id FROM users")
        for key in all_keys:
            self.redis.execute_command('BF.ADD', 'users', f"user:{key}")

    def get_user(self, user_id):
        cache_key = f"user:{user_id}"

        # 1. 布隆过滤器检查
        exists = self.redis.execute_command('BF.EXISTS', 'users', cache_key)
        if not exists:
            return None

        # 2. 查询缓存
        user = self.redis.get(cache_key)
        if user:
            return json.loads(user)

        # 3. 查询数据库
        user = self.db.query("SELECT * FROM users WHERE id = ?", user_id)

        if user:
            self.redis.setex(cache_key, 3600, json.dumps(user))
        else:
            self.redis.setex(cache_key, 60, "NULL")

        return user
```

## 性能对比

| 方案 | 内存占用 | 查询性能 | 实现复杂度 | 适用场景 |
|------|----------|----------|------------|----------|
| **缓存空值** | 高 | O(1) | 低 | 小规模数据 |
| **布隆过滤器** | 低 | O(1) | 中 | 大规模数据 |
| **Redis布隆过滤器** | 低 | O(1) | 低 | Redis 4.0+ |

**参数校验**：在应用层进行参数校验，过滤无效请求。

## 5. 性能分析

### 5.1 方案对比

| 方案 | 数据库查询减少 | 内存占用 | 实现复杂度 |
|------|----------------|----------|------------|
| **缓存空值** | 100%（TTL内） | 低 | 低 |
| **布隆过滤器** | 99.9% | 中 | 中 |
| **参数校验** | 取决于校验规则 | 低 | 低 |

### 5.2 性能影响

**性能影响**：

- **缓存穿透前**：数据库QPS = 请求QPS
- **缓存穿透后**：数据库QPS = 请求QPS（无防护）
- **使用缓存空值**：数据库QPS = 0（TTL内）
- **使用布隆过滤器**：数据库QPS = 请求QPS × 0.1%（误判率）

## 6. 最佳实践

### 6.1 组合方案

```python
# 组合使用：布隆过滤器 + 缓存空值
class CachePenetrationPrevention:
    def __init__(self):
        self.bloom = BloomFilter(capacity=1000000)
        self.cache = redis.Redis()
        self.db = MySQL()

    def get_user(self, user_id):
        cache_key = f"user:{user_id}"

        # 1. 布隆过滤器（第一道防线）
        if cache_key not in self.bloom:
            return None

        # 2. 缓存查询（第二道防线）
        cached = self.cache.get(cache_key)
        if cached:
            if cached == "NULL":
                return None
            return json.loads(cached)

        # 3. 数据库查询（最后一道防线）
        user = self.db.query("SELECT * FROM users WHERE id = ?", user_id)

        if user:
            self.cache.setex(cache_key, 3600, json.dumps(user))
        else:
            self.cache.setex(cache_key, 60, "NULL")

        return user
```

**组合方案**：布隆过滤器 + 缓存空值，双重防护。

### 6.2 预热布隆过滤器

```python
# 系统启动时预热
def warmup_bloom_filter():
    # 批量查询所有存在的key
    batch_size = 10000
    offset = 0

    while True:
        keys = db.query(f"SELECT id FROM users LIMIT {batch_size} OFFSET {offset}")
        if not keys:
            break

        for key in keys:
            bloom.add(f"user:{key}")

        offset += batch_size
```

**预热布隆过滤器**：系统启动时预热，提高过滤效率。

### 6.3 监控告警

```python
# 监控缓存穿透
class CachePenetrationMonitor:
    def __init__(self):
        self.penetration_count = 0
        self.threshold = 100  # 每分钟100次

    def check_penetration(self, cache_miss, db_miss):
        if cache_miss and db_miss:
            self.penetration_count += 1

            if self.penetration_count > self.threshold:
                send_alert("CACHE_PENETRATION_DETECTED")
                self.penetration_count = 0
```

**监控告警**：监控缓存穿透情况，及时告警。

## 7. 程序设计分析

### 7.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：不同缓存穿透处理策略（空值缓存、布隆过滤器）
2. **过滤器模式**：布隆过滤器实现
3. **模板方法模式**：定义缓存穿透处理的基本流程

**策略模式实现**：

```python
# 缓存穿透处理策略接口
class CachePenetrationStrategy:
    def handle(self, key):
        raise NotImplementedError

class NullValueStrategy(CachePenetrationStrategy):
    def handle(self, key):
        # 空值缓存处理
        pass

class BloomFilterStrategy(CachePenetrationStrategy):
    def handle(self, key):
        # 布隆过滤器处理
        pass
```

### 7.2 代码结构分析

**代码组织**：

1. **过滤层**：布隆过滤器实现
2. **缓存层**：空值缓存实现
3. **策略层**：不同处理策略实现

**模块化设计**：

- **高内聚**：缓存穿透相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的处理策略

### 7.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 准确性** | 布隆过滤器 | 平衡性能和准确性 |
| **简单 vs 复杂** | 组合方案 | 支持多种场景 |
| **通用 vs 专用** | 通用缓存穿透处理 | 适用多种场景 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{accuracy} + C_{complexity}$$

其中：

- $C_{performance}$：性能成本（布隆过滤器，性能提升）
- $C_{accuracy}$：准确性成本（误判率）
- $C_{complexity}$：复杂度成本（布隆过滤器，复杂度较高）

### 7.4 可扩展性分析

**扩展点**：

1. **新处理策略**：可扩展为其他处理策略
2. **新过滤器**：可扩展为其他过滤器实现
3. **分布式布隆过滤器**：可扩展为分布式布隆过滤器实现

**扩展性设计**：

```python
# 可扩展的缓存穿透处理接口
class CachePenetrationManager:
    def __init__(self, strategies: List[CachePenetrationStrategy]):
        self.strategies = strategies

    def handle(self, key):
        for strategy in self.strategies:
            strategy.handle(key)
```

**可维护性**：

- **代码清晰**：缓存穿透处理逻辑清晰，易于理解
- **易于调试**：过滤器状态易于监控和调试
- **测试友好**：缓存穿透处理行为易于测试和验证

## 8. 扩展阅读

- [缓存雪崩](./04.04.02-缓存雪崩.md)
- [缓存击穿](./04.04.03-缓存击穿.md)
- [布隆过滤器原理](../../01-理论基础/01.03-分布式缓存算法/01.03.01-一致性哈希原理.md)

## 9. 权威参考

### 9.1 经典书籍

1. **《大型网站技术架构：核心原理与案例分析》** - 李智慧
   - 出版社: 电子工业出版社
   - ISBN: 978-7121207451
   - 第4章：缓存架构（缓存穿透详解）

2. **《高并发系统设计40问》** - 沈剑
   - 出版社: 电子工业出版社
   - ISBN: 978-7121407010
   - 第10章：缓存问题（缓存穿透详解）

### 9.2 在线资源

1. **Redis官方文档 - Bloom Filter**
   - URL: <https://redis.io/docs/manual/patterns/bloom-filter/>
   - Redis布隆过滤器的官方文档

2. **Wikipedia - Bloom Filter**
   - URL: <https://en.wikipedia.org/wiki/Bloom_filter>
   - 提供布隆过滤器的详细说明
