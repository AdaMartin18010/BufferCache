# 04.04.01 缓存穿透

## 概述

缓存穿透是指查询一个**不存在的数据**，由于缓存未命中，请求穿透到数据库，如果大量这样的请求，可能导致数据库压力过大甚至崩溃。

## 问题场景

### 典型场景

```
用户请求 → 缓存查询（未命中） → 数据库查询（不存在） → 返回空结果
         ↓
    大量并发请求
         ↓
    数据库压力过大
```

### 风险传导

```
缓存穿透 → 数据库QPS激增 → 数据库连接池耗尽 → 服务不可用
```

## 问题原因

### 根本原因

1. **业务逻辑**：查询不存在的数据（如不存在的用户ID）
2. **恶意攻击**：故意查询不存在的数据
3. **缓存未命中**：缓存中没有对应数据

### 示例代码

```python
# 问题代码
def get_user(user_id):
    # 1. 查询缓存
    user = cache.get(f"user:{user_id}")
    if user:
        return user

    # 2. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if user:
        # 3. 写入缓存
        cache.set(f"user:{user_id}", user, ttl=3600)
    else:
        # 问题：不存在的数据不缓存，下次请求还会穿透
        pass

    return user  # 返回None
```

## 解决方案

### 方案1：缓存空值

```python
# 解决方案：缓存空值
def get_user(user_id):
    # 1. 查询缓存
    user = cache.get(f"user:{user_id}")
    if user is not None:
        if user == "NULL":  # 空值标记
            return None
        return user

    # 2. 查询数据库
    user = db.query("SELECT * FROM users WHERE id = ?", user_id)

    if user:
        # 3. 缓存真实数据
        cache.set(f"user:{user_id}", user, ttl=3600)
    else:
        # 4. 缓存空值（短TTL）
        cache.set(f"user:{user_id}", "NULL", ttl=60)  # 60秒TTL

    return user
```

**优势**：
- 实现简单
- 有效防止穿透

**劣势**：
- 占用缓存空间
- 需要定期清理

### 方案2：布隆过滤器

```python
from pybloom_live import BloomFilter

class CacheWithBloomFilter:
    def __init__(self, cache_client, db_client, capacity=1000000, error_rate=0.001):
        self.cache = cache_client
        self.db = db_client
        self.bloom = BloomFilter(capacity=capacity, error_rate=error_rate)
        self.init_bloom_filter()

    def init_bloom_filter(self):
        # 初始化：将所有存在的key加入布隆过滤器
        all_keys = self.db.query("SELECT id FROM users")
        for key in all_keys:
            self.bloom.add(f"user:{key}")

    def get_user(self, user_id):
        cache_key = f"user:{user_id}"

        # 1. 布隆过滤器检查
        if cache_key not in self.bloom:
            # 肯定不存在，直接返回
            return None

        # 2. 查询缓存
        user = self.cache.get(cache_key)
        if user:
            return user

        # 3. 查询数据库
        user = self.db.query("SELECT * FROM users WHERE id = ?", user_id)

        if user:
            # 4. 写入缓存
            self.cache.set(cache_key, user, ttl=3600)
        else:
            # 5. 缓存空值
            self.cache.set(cache_key, "NULL", ttl=60)

        return user
```

**优势**：
- 内存占用小
- 查询速度快（O(1)）
- 误判率可控

**劣势**：
- 需要初始化
- 不支持删除（需要重建）

### 方案3：Redis布隆过滤器（Redis 4.0+）

```python
import redis

class CacheWithRedisBloom:
    def __init__(self, redis_client, db_client):
        self.redis = redis_client
        self.db = db_client
        self.init_bloom_filter()

    def init_bloom_filter(self):
        # 创建布隆过滤器
        self.redis.execute_command('BF.RESERVE', 'users', '0.001', '1000000')

        # 初始化数据
        all_keys = self.db.query("SELECT id FROM users")
        for key in all_keys:
            self.redis.execute_command('BF.ADD', 'users', f"user:{key}")

    def get_user(self, user_id):
        cache_key = f"user:{user_id}"

        # 1. 布隆过滤器检查
        exists = self.redis.execute_command('BF.EXISTS', 'users', cache_key)
        if not exists:
            return None

        # 2. 查询缓存
        user = self.redis.get(cache_key)
        if user:
            return json.loads(user)

        # 3. 查询数据库
        user = self.db.query("SELECT * FROM users WHERE id = ?", user_id)

        if user:
            self.redis.setex(cache_key, 3600, json.dumps(user))
        else:
            self.redis.setex(cache_key, 60, "NULL")

        return user
```

## 性能对比

| 方案 | 内存占用 | 查询性能 | 实现复杂度 | 适用场景 |
|------|----------|----------|------------|----------|
| **缓存空值** | 高 | O(1) | 低 | 小规模数据 |
| **布隆过滤器** | 低 | O(1) | 中 | 大规模数据 |
| **Redis布隆过滤器** | 低 | O(1) | 低 | Redis 4.0+ |

## 最佳实践

### 1. 组合方案

```python
# 组合使用：布隆过滤器 + 缓存空值
class CachePenetrationPrevention:
    def __init__(self):
        self.bloom = BloomFilter(capacity=1000000)
        self.cache = redis.Redis()
        self.db = MySQL()

    def get_user(self, user_id):
        cache_key = f"user:{user_id}"

        # 1. 布隆过滤器（第一道防线）
        if cache_key not in self.bloom:
            return None

        # 2. 缓存查询（第二道防线）
        cached = self.cache.get(cache_key)
        if cached:
            if cached == "NULL":
                return None
            return json.loads(cached)

        # 3. 数据库查询（最后一道防线）
        user = self.db.query("SELECT * FROM users WHERE id = ?", user_id)

        if user:
            self.cache.setex(cache_key, 3600, json.dumps(user))
        else:
            self.cache.setex(cache_key, 60, "NULL")

        return user
```

### 2. 预热布隆过滤器

```python
# 系统启动时预热
def warmup_bloom_filter():
    # 批量查询所有存在的key
    batch_size = 10000
    offset = 0

    while True:
        keys = db.query(f"SELECT id FROM users LIMIT {batch_size} OFFSET {offset}")
        if not keys:
            break

        for key in keys:
            bloom.add(f"user:{key}")

        offset += batch_size
```

### 3. 监控告警

```python
# 监控缓存穿透
class CachePenetrationMonitor:
    def __init__(self):
        self.penetration_count = 0
        self.threshold = 100  # 每分钟100次

    def check_penetration(self, cache_miss, db_miss):
        if cache_miss and db_miss:
            self.penetration_count += 1

            if self.penetration_count > self.threshold:
                send_alert("CACHE_PENETRATION_DETECTED")
                self.penetration_count = 0
```

## 扩展阅读

- [缓存雪崩](./04.04.02-缓存雪崩.md)
- [缓存击穿](./04.04.03-缓存击穿.md)
- [布隆过滤器原理](../../01-理论基础/01.03-分布式缓存算法/01.03.01-一致性哈希原理.md)

## 权威参考

- **《大型网站技术架构》** - 李智慧著
- **《高并发系统设计》** - 大型互联网公司技术博客
- **Redis官方文档** - <https://redis.io/docs/manual/patterns/bloom-filter/>
