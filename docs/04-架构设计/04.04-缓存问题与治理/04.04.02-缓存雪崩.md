# 04.04.02 缓存雪崩

## 概述

缓存雪崩是指**大量缓存同时失效**，导致所有请求都穿透到数据库，造成数据库压力激增甚至崩溃。

## 问题场景

### 典型场景

```
时间T0: 大量缓存设置相同TTL（如3600秒）
时间T0+3600: 所有缓存同时过期
时间T0+3600: 大量请求穿透到数据库
结果: 数据库崩溃
```

### 风险传导

```
缓存同时失效 → 大量请求穿透 → 数据库QPS激增 → 数据库崩溃 → 服务不可用
```

## 问题原因

### 根本原因

1. **相同TTL**：大量缓存使用相同的过期时间
2. **缓存预热**：系统启动时批量设置缓存，TTL相同
3. **定时任务**：定时刷新缓存，同时失效

### 示例代码

```python
# 问题代码
def warmup_cache():
    # 批量预热缓存，使用相同TTL
    products = db.query("SELECT * FROM products")
    for product in products:
        cache.set(f"product:{product.id}", product, ttl=3600)  # 相同TTL
```

## 解决方案

### 方案1：随机TTL

```python
import random

def set_cache_with_random_ttl(key, value, base_ttl=3600, variance=300):
    # 随机TTL：base_ttl ± variance
    ttl = base_ttl + random.randint(-variance, variance)
    cache.set(key, value, ttl=ttl)
    return ttl

# 使用示例
def warmup_cache():
    products = db.query("SELECT * FROM products")
    for product in products:
        set_cache_with_random_ttl(
            f"product:{product.id}",
            product,
            base_ttl=3600,
            variance=300  # ±5分钟
        )
```

**数学证明**：详见[证明图网-缓存雪崩防护数学模型](../../00-项目总览/证明图网-核心机制证明.md#3-缓存雪崩防护数学模型)

**效果**：
- 原始：100万请求在1秒内集中
- 优化后：100万请求分散到600秒内
- **压力降低600倍**

### 方案2：缓存预热分散

```python
import time
import random

def warmup_cache_distributed():
    products = db.query("SELECT * FROM products")

    # 分散预热时间
    for i, product in enumerate(products):
        # 延迟预热，分散失效时间
        delay = random.uniform(0, 3600)  # 0-1小时随机延迟
        time.sleep(delay / len(products))  # 平均分散

        # 随机TTL
        ttl = 3600 + random.randint(-300, 300)
        cache.set(f"product:{product.id}", product, ttl=ttl)
```

### 方案3：多级缓存

```python
class MultiLevelCache:
    def __init__(self):
        self.l1_cache = {}  # 本地缓存
        self.l2_cache = redis.Redis()  # Redis缓存
        self.db = MySQL()

    def get_product(self, product_id):
        cache_key = f"product:{product_id}"

        # L1: 本地缓存
        if cache_key in self.l1_cache:
            return self.l1_cache[cache_key]

        # L2: Redis缓存
        cached = self.l2_cache.get(cache_key)
        if cached:
            product = json.loads(cached)
            self.l1_cache[cache_key] = product
            return product

        # 数据库
        product = self.db.query("SELECT * FROM products WHERE id = ?", product_id)
        if product:
            # 写入L2（随机TTL）
            ttl = 3600 + random.randint(-300, 300)
            self.l2_cache.setex(cache_key, ttl, json.dumps(product))
            # 写入L1（短TTL）
            self.l1_cache[cache_key] = product

        return product
```

### 方案4：熔断降级

```python
from circuitbreaker import circuit

class CacheWithCircuitBreaker:
    def __init__(self):
        self.cache = redis.Redis()
        self.db = MySQL()
        self.circuit_open = False
        self.failure_count = 0
        self.threshold = 100

    @circuit(failure_threshold=100, recovery_timeout=60)
    def get_product(self, product_id):
        cache_key = f"product:{product_id}"

        # 查询缓存
        cached = self.cache.get(cache_key)
        if cached:
            return json.loads(cached)

        # 缓存未命中，查询数据库
        try:
            product = self.db.query("SELECT * FROM products WHERE id = ?", product_id)
            if product:
                ttl = 3600 + random.randint(-300, 300)
                self.cache.setex(cache_key, ttl, json.dumps(product))
            return product
        except Exception as e:
            # 数据库异常，返回默认值
            self.failure_count += 1
            if self.failure_count > self.threshold:
                self.circuit_open = True
            return self.get_default_product(product_id)

    def get_default_product(self, product_id):
        # 返回默认值，避免数据库压力
        return {"id": product_id, "name": "默认商品", "price": 0}
```

## 预防策略

### 1. 缓存永不过期

```python
# 缓存永不过期，通过后台任务更新
def get_product(product_id):
    cache_key = f"product:{product_id}"

    # 查询缓存
    cached = self.cache.get(cache_key)
    if cached:
        return json.loads(cached)

    # 缓存未命中，查询数据库
    product = self.db.query("SELECT * FROM products WHERE id = ?", product_id)
    if product:
        # 永不过期
        self.cache.set(cache_key, json.dumps(product))

    return product

# 后台任务定期更新
def background_refresh():
    while True:
        products = db.query("SELECT * FROM products")
        for product in products:
            cache.set(f"product:{product.id}", json.dumps(product))
        time.sleep(3600)  # 每小时更新一次
```

### 2. 互斥锁重建

```python
import threading

class CacheWithMutex:
    def __init__(self):
        self.cache = redis.Redis()
        self.db = MySQL()
        self.locks = {}
        self.lock_lock = threading.Lock()

    def get_lock(self, key):
        with self.lock_lock:
            if key not in self.locks:
                self.locks[key] = threading.Lock()
            return self.locks[key]

    def get_product(self, product_id):
        cache_key = f"product:{product_id}"

        # 查询缓存
        cached = self.cache.get(cache_key)
        if cached:
            return json.loads(cached)

        # 获取锁
        lock = self.get_lock(cache_key)
        with lock:
            # 双重检查
            cached = self.cache.get(cache_key)
            if cached:
                return json.loads(cached)

            # 查询数据库
            product = self.db.query("SELECT * FROM products WHERE id = ?", product_id)
            if product:
                ttl = 3600 + random.randint(-300, 300)
                self.cache.setex(cache_key, ttl, json.dumps(product))

            return product
```

## 监控与告警

### 关键指标

```python
# 监控指标
metrics = {
    'cache_hit_rate': get_hit_rate(),        # 缓存命中率
    'db_qps': get_db_qps(),                  # 数据库QPS
    'cache_expire_count': get_expire_count(), # 缓存过期数量
    'error_rate': get_error_rate()           # 错误率
}

# 告警规则
if metrics['cache_hit_rate'] < 0.5:  # 命中率<50%
    send_alert('LOW_CACHE_HIT_RATE')

if metrics['db_qps'] > 10000:  # 数据库QPS>10000
    send_alert('HIGH_DB_QPS')
```

## 扩展阅读

- [缓存穿透](./04.04.01-缓存穿透.md)
- [缓存击穿](./04.04.03-缓存击穿.md)
- [证明图网-缓存雪崩防护数学模型](../../00-项目总览/证明图网-核心机制证明.md#3-缓存雪崩防护数学模型)

## 权威参考

- **《大型网站技术架构》** - 李智慧著
- **《高并发系统设计》** - 大型互联网公司技术博客
- **Redis官方文档** - <https://redis.io/docs/manual/patterns/>
