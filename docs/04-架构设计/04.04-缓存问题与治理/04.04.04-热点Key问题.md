# 04.04.04 热点Key问题

## 概述

热点Key（Hot Key）是指**访问频率极高的单个key**，当某个key的QPS超过单机Redis的处理能力时，会导致该Redis实例CPU和网络带宽耗尽，影响其他key的访问。

## 问题场景

### 典型场景

```
热点Key（如：秒杀商品库存） → 100万QPS → 单机Redis无法承受 → 服务不可用
```

### 风险传导

```
热点Key → Redis CPU 100% → 其他请求延迟增加 → 服务超时 → 业务受损
```

## 问题原因

### 根本原因

1. **业务特征**：秒杀、热门商品、热门话题等
2. **数据集中**：所有请求集中在单个key
3. **单机瓶颈**：单机Redis无法处理超高QPS

### 示例场景

```python
# 秒杀场景：所有请求都访问同一个key
def seckill(product_id):
    # 问题：100万用户同时访问这个key
    stock = redis.get(f"stock:{product_id}")
    if stock > 0:
        redis.decr(f"stock:{product_id}")
        return "success"
    return "sold_out"
```

## 解决方案

### 方案1：本地缓存+Redis

```python
from cachetools import TTLCache
import threading

class HotKeyCache:
    def __init__(self, redis_client, ttl=1):
        self.redis = redis_client
        self.local_cache = TTLCache(maxsize=1000, ttl=ttl)  # 1秒TTL
        self.lock = threading.Lock()

    def get(self, key):
        # 1. 先查本地缓存
        if key in self.local_cache:
            return self.local_cache[key]

        # 2. 查Redis
        value = self.redis.get(key)
        if value:
            # 3. 写入本地缓存
            with self.lock:
                self.local_cache[key] = value

        return value
```

**效果**：
- 原始：100万QPS全部打到Redis
- 优化后：假设1000个应用实例，每个实例本地缓存命中率90%
- Redis实际QPS：100万 × 10% = 10万QPS（降低10倍）

### 方案2：多级缓存

```python
class MultiLevelHotKeyCache:
    def __init__(self):
        self.l1_cache = {}  # 本地缓存（Caffeine）
        self.l2_cache = redis.Redis(host='localhost', port=6379)  # Redis
        self.l3_cache = redis.Redis(host='remote', port=6379)  # 远程Redis

    def get(self, key):
        # L1: 本地缓存
        if key in self.l1_cache:
            return self.l1_cache[key]

        # L2: 本地Redis
        value = self.l2_cache.get(key)
        if value:
            self.l1_cache[key] = value
            return value

        # L3: 远程Redis（降级）
        value = self.l3_cache.get(key)
        if value:
            self.l2_cache.setex(key, 60, value)
            self.l1_cache[key] = value

        return value
```

### 方案3：Key拆分

```python
class ShardedHotKeyCache:
    def __init__(self, redis_client, shard_count=10):
        self.redis = redis_client
        self.shard_count = shard_count

    def get_shard_key(self, key, shard_id):
        """获取分片key"""
        return f"{key}:shard:{shard_id}"

    def get(self, key):
        # 随机选择一个分片
        shard_id = hash(key) % self.shard_count
        shard_key = self.get_shard_key(key, shard_id)

        # 查询分片
        value = self.redis.get(shard_key)
        return value

    def set(self, key, value, ttl=3600):
        # 写入所有分片
        for shard_id in range(self.shard_count):
            shard_key = self.get_shard_key(key, shard_id)
            self.redis.setex(shard_key, ttl, value)

    def get_all(self, key):
        """获取所有分片的值（用于聚合）"""
        values = []
        for shard_id in range(self.shard_count):
            shard_key = self.get_shard_key(key, shard_id)
            value = self.redis.get(shard_key)
            if value:
                values.append(value)
        return values
```

**适用场景**：
- 可聚合的数据（如计数、库存）
- 需要分散访问压力

### 方案4：读写分离

```python
class ReadWriteSplitCache:
    def __init__(self):
        self.master = redis.Redis(host='master', port=6379)
        self.slaves = [
            redis.Redis(host='slave1', port=6379),
            redis.Redis(host='slave2', port=6379),
            redis.Redis(host='slave3', port=6379),
        ]
        self.slave_index = 0

    def get(self, key):
        # 读操作：轮询从节点
        slave = self.slaves[self.slave_index]
        self.slave_index = (self.slave_index + 1) % len(self.slaves)

        return slave.get(key)

    def set(self, key, value, ttl=3600):
        # 写操作：只写主节点
        return self.master.setex(key, ttl, value)
```

**效果**：
- 原始：100万QPS全部打到主节点
- 优化后：100万QPS分散到4个节点（1主3从）
- 每个节点：25万QPS（降低4倍）

### 方案5：Redis Cluster分片

```python
# 使用Redis Cluster自动分片
# 热点key会被分配到不同的节点
# 配置示例：
# redis-cli --cluster create \
#   127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 \
#   127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \
#   --cluster-replicas 1

import rediscluster

class ClusterHotKeyCache:
    def __init__(self):
        startup_nodes = [
            {"host": "127.0.0.1", "port": "7000"},
            {"host": "127.0.0.1", "port": "7001"},
            {"host": "127.0.0.1", "port": "7002"},
        ]
        self.cluster = rediscluster.RedisCluster(
            startup_nodes=startup_nodes,
            decode_responses=True
        )

    def get(self, key):
        return self.cluster.get(key)

    def set(self, key, value, ttl=3600):
        return self.cluster.setex(key, ttl, value)
```

**注意**：Redis Cluster使用CRC16分片，相同key会路由到同一节点，需要配合Key拆分使用。

## 热点Key识别

### 监控方案

```python
class HotKeyMonitor:
    def __init__(self, redis_client, threshold=10000):
        self.redis = redis_client
        self.threshold = threshold  # QPS阈值
        self.access_count = {}  # key访问计数

    def record_access(self, key):
        """记录访问"""
        if key not in self.access_count:
            self.access_count[key] = 0

        self.access_count[key] += 1

        # 检查是否超过阈值
        if self.access_count[key] > self.threshold:
            self.alert_hot_key(key)

    def alert_hot_key(self, key):
        """告警热点key"""
        print(f"Hot key detected: {key}, QPS: {self.access_count[key]}")
        # 发送告警
        send_alert(f"HOT_KEY:{key}")

    def reset_counters(self):
        """重置计数器（每分钟）"""
        self.access_count.clear()
```

### Redis监控命令

```bash
# 使用Redis MONITOR命令监控
redis-cli MONITOR | grep "GET stock:"

# 使用Redis INFO命令查看
redis-cli INFO stats

# 使用Redis SLOWLOG查看慢查询
redis-cli SLOWLOG GET 10
```

## 最佳实践

### 1. 预防性设计

```python
# 秒杀场景：使用本地缓存+Redis
class SeckillService:
    def __init__(self):
        self.local_cache = TTLCache(maxsize=100, ttl=0.1)  # 100ms TTL
        self.redis = redis.Redis()

    def get_stock(self, product_id):
        cache_key = f"stock:{product_id}"

        # 先查本地缓存
        if cache_key in self.local_cache:
            return self.local_cache[cache_key]

        # 查Redis
        stock = self.redis.get(cache_key)
        if stock:
            self.local_cache[cache_key] = int(stock)

        return int(stock) if stock else 0
```

### 2. 动态降级

```python
class AdaptiveHotKeyCache:
    def __init__(self):
        self.redis = redis.Redis()
        self.local_cache = {}
        self.hot_keys = set()
        self.access_count = {}

    def get(self, key):
        # 检查是否是热点key
        if key in self.hot_keys:
            # 热点key：使用本地缓存
            if key in self.local_cache:
                return self.local_cache[key]

        # 记录访问
        self.access_count[key] = self.access_count.get(key, 0) + 1

        # 检查是否成为热点
        if self.access_count[key] > 1000:
            self.hot_keys.add(key)

        # 查询Redis
        value = self.redis.get(key)
        if value and key in self.hot_keys:
            self.local_cache[key] = value

        return value
```

### 3. 限流保护

```python
from redis import Redis
from redis_rate_limit import RateLimiter

class RateLimitedHotKeyCache:
    def __init__(self):
        self.redis = Redis()
        self.rate_limiter = RateLimiter(self.redis)

    def get(self, key):
        # 限流：每个key每秒最多1000次
        if not self.rate_limiter.allow(key, limit=1000, window=1):
            # 超过限流，返回缓存值或默认值
            return self.get_cached_value(key)

        # 正常查询
        return self.redis.get(key)

    def get_cached_value(self, key):
        # 返回缓存值或默认值
        return self.redis.get(f"cached:{key}") or "default"
```

## 性能对比

| 方案 | Redis QPS降低 | 实现复杂度 | 适用场景 |
|------|---------------|------------|----------|
| **本地缓存** | 10-100倍 | 低 | 读多写少 |
| **多级缓存** | 10-100倍 | 中 | 读多写少 |
| **Key拆分** | N倍（N=分片数） | 中 | 可聚合数据 |
| **读写分离** | N倍（N=从节点数） | 中 | 读多写少 |
| **Cluster分片** | 自动分散 | 高 | 大规模场景 |

## 监控与告警

### 关键指标

```python
# 监控指标
metrics = {
    'hot_key_count': len(hot_keys),           # 热点key数量
    'max_key_qps': max(access_count.values()), # 最大key QPS
    'redis_cpu': get_redis_cpu(),             # Redis CPU使用率
    'redis_qps': get_redis_qps()              # Redis总QPS
}

# 告警规则
if metrics['max_key_qps'] > 10000:  # 单个key QPS>10000
    send_alert('HOT_KEY_DETECTED')

if metrics['redis_cpu'] > 80:  # Redis CPU>80%
    send_alert('HIGH_REDIS_CPU')
```

## 扩展阅读

- [缓存击穿](./04.04.03-缓存击穿.md)
- [大Key问题](./04.04.05-大Key问题.md)
- [Cluster集群模式](../../03-Redis组件/03.03-高可用架构/03.03.03-Cluster集群模式.md)

## 权威参考

- **《大型网站技术架构》** - 李智慧著
- **《高并发系统设计》** - 大型互联网公司技术博客
- **Redis官方文档** - <https://redis.io/docs/manual/patterns/>
