# 05.01.01 CPU缓存与伪共享

## 概述

CPU缓存是Redis性能的关键因素之一。理解CPU缓存的工作原理、缓存行（Cache Line）机制和伪共享（False Sharing）问题，对于优化Redis性能至关重要。

## CPU缓存层次结构

### 多级缓存

```
L1 Cache (32KB)  ← 最快，延迟1-3周期
    ↓
L2 Cache (256KB) ← 延迟10-20周期
    ↓
L3 Cache (8-32MB) ← 延迟40-75周期
    ↓
主内存 (RAM)      ← 延迟100-300周期
```

### 缓存行（Cache Line）

- **大小**：通常64字节（x86_64架构）
- **对齐**：数据按64字节对齐
- **一致性**：MESI协议保证多核一致性

## 伪共享问题

### 问题定义

伪共享是指**多个CPU核心访问同一缓存行的不同数据**，导致缓存行在核心间频繁无效化，造成性能下降。

### 问题场景

```c
// 问题代码：两个变量在同一缓存行
struct Counter {
    volatile long count1;  // 8字节
    volatile long count2;  // 8字节
    // 总共16字节，小于64字节，在同一缓存行
} counters[2];

// CPU 0 更新 count1
counters[0].count1++;

// CPU 1 更新 count2
counters[1].count2++;

// 问题：两个变量在同一缓存行，导致缓存行在CPU间频繁无效化
```

### 性能影响

```
正常情况：每次更新 ~10ns
伪共享情况：每次更新 ~100ns（10倍延迟）
```

## Redis中的伪共享

### 场景1：全局统计变量

```c
// Redis源码：server.c
struct redisServer {
    // ... 其他字段
    unsigned long long stat_keyspace_hits;    // 命中数
    unsigned long long stat_keyspace_misses; // 未命中数
    // 这两个变量可能在同一缓存行
} server;
```

### 场景2：客户端结构

```c
// Redis源码：server.h
typedef struct client {
    // ... 其他字段
    int argc;                    // 参数数量
    robj **argv;                 // 参数数组
    unsigned long long obuf_soft_limit_reached_time;
    // 多个字段可能在同一缓存行
} client;
```

## 解决方案

### 方案1：缓存行对齐

```c
// 使用编译器属性对齐到缓存行
struct Counter {
    volatile long count1 __attribute__((aligned(64)));
    char padding[56];  // 填充到64字节
    volatile long count2 __attribute__((aligned(64)));
};

// 或者使用C11标准
struct Counter {
    alignas(64) volatile long count1;
    alignas(64) volatile long count2;
};
```

### 方案2：结构体填充

```c
// Redis优化示例
struct redisServer {
    // ... 其他字段
    unsigned long long stat_keyspace_hits;
    char padding[56];  // 填充，避免与下一个变量在同一缓存行
    unsigned long long stat_keyspace_misses;
} server;
```

### 方案3：分离热点数据

```c
// 将热点数据分离到独立结构
struct HotStats {
    unsigned long long keyspace_hits;
    unsigned long long keyspace_misses;
    // ... 其他热点统计
} __attribute__((aligned(64)));

struct redisServer {
    struct HotStats *hot_stats;  // 指向独立结构
    // ... 其他字段
} server;
```

## 性能测试

### 测试代码

```c
#include <stdio.h>
#include <pthread.h>
#include <time.h>

#define CACHE_LINE_SIZE 64

// 未优化的结构（伪共享）
struct CounterBad {
    volatile long count1;
    volatile long count2;
};

// 优化的结构（缓存行对齐）
struct CounterGood {
    volatile long count1;
    char padding[CACHE_LINE_SIZE - sizeof(long)];
    volatile long count2;
};

void* increment_bad(void* arg) {
    struct CounterBad* c = (struct CounterBad*)arg;
    for (int i = 0; i < 100000000; i++) {
        c->count1++;
    }
    return NULL;
}

void* increment_good(void* arg) {
    struct CounterGood* c = (struct CounterGood*)arg;
    for (int i = 0; i < 100000000; i++) {
        c->count2++;
    }
    return NULL;
}

int main() {
    struct CounterBad bad = {0, 0};
    struct CounterGood good = {0, 0};

    pthread_t t1, t2;
    clock_t start, end;

    // 测试未优化版本
    start = clock();
    pthread_create(&t1, NULL, increment_bad, &bad);
    pthread_create(&t2, NULL, increment_bad, &bad);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    end = clock();
    printf("Bad: %f seconds\n", (double)(end - start) / CLOCKS_PER_SEC);

    // 测试优化版本
    start = clock();
    pthread_create(&t1, NULL, increment_good, &good);
    pthread_create(&t2, NULL, increment_good, &good);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    end = clock();
    printf("Good: %f seconds\n", (double)(end - start) / CLOCKS_PER_SEC);

    return 0;
}
```

### 测试结果

```
未优化（伪共享）：~2.5秒
优化后（缓存行对齐）：~0.3秒
性能提升：8倍
```

## Redis优化实践

### 1. 使用perf工具检测

```bash
# 安装perf
sudo apt-get install linux-perf

# 检测伪共享
perf c2c record -a -- sleep 10
perf c2c report
```

### 2. 使用valgrind检测

```bash
# 使用valgrind检测缓存未命中
valgrind --tool=cachegrind redis-server
```

### 3. 代码审查

```c
// 检查结构体大小和对齐
struct redisServer {
    // 使用offsetof检查字段偏移
    // 确保热点字段不在同一缓存行
};
```

## 缓存友好的数据结构

### 1. 数组vs链表

```c
// 数组：缓存友好
int array[1000];  // 连续内存，缓存命中率高

// 链表：缓存不友好
struct Node {
    int data;
    struct Node* next;  // 指针跳转，缓存命中率低
};
```

### 2. 结构体字段顺序

```c
// 好的顺序：按访问频率排序
struct Good {
    int hot_field1;      // 热点字段在前
    int hot_field2;
    int cold_field1;     // 冷字段在后
    int cold_field2;
};

// 差的顺序：热点字段分散
struct Bad {
    int cold_field1;
    int hot_field1;      // 热点字段分散
    int cold_field2;
    int hot_field2;
};
```

## 扩展阅读

- [NUMA架构影响](./05.01.02-NUMA架构影响.md)
- [内存带宽分析](./05.01.04-内存带宽分析.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 权威参考

- **《深入理解计算机系统》** - CSAPP
- **《性能之巅》** - Brendan Gregg
- **Intel Optimization Manual** - Intel官方文档
- **Redis源码** - <https://github.com/redis/redis>
