# 05.01.02 NUMA架构影响

## 概述

NUMA（Non-Uniform Memory Access，非统一内存访问）是现代多核服务器的主流架构。理解NUMA对Redis性能的影响，对于优化Redis部署至关重要。

## NUMA架构原理

### UMA vs NUMA

```
UMA（统一内存访问）：
┌─────────┐  ┌─────────┐  ┌─────────┐
│ CPU 0   │  │ CPU 1   │  │ CPU 2   │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │            │
     └────────────┼────────────┘
                  │
           ┌──────┴──────┐
           │   内存总线   │
           └──────┬──────┘
                  │
           ┌──────┴──────┐
           │   共享内存   │
           └─────────────┘

NUMA（非统一内存访问）：
┌─────────┐         ┌─────────┐
│ CPU 0   │────────▶│ 内存 0  │ (本地内存，快)
└────┬────┘         └─────────┘
     │
     │ QPI/UPI
     │
┌────┴────┐         ┌─────────┐
│ CPU 1   │────────▶│ 内存 1  │ (本地内存，快)
└────┬────┘         └─────────┘
     │
     │ 跨节点访问（慢）
     │
┌────┴────┐         ┌─────────┐
│ CPU 2   │────────▶│ 内存 0  │ (远程内存，慢)
└─────────┘         └─────────┘
```

### NUMA节点

```bash
# 查看NUMA拓扑
numactl --hardware

# 输出示例：
# available: 2 nodes (0-1)
# node 0 cpus: 0 1 2 3 4 5 6 7
# node 0 size: 32768 MB
# node 0 free: 1024 MB
# node 1 cpus: 8 9 10 11 12 13 14 15
# node 1 size: 32768 MB
# node 1 free: 2048 MB
```

## NUMA对Redis的影响

### 内存访问延迟

```
本地内存访问：~100ns
远程内存访问：~300ns（3倍延迟）
```

### 性能影响

```c
// Redis单线程模型：所有操作在一个CPU核心上
// 如果Redis绑定到Node 0，但内存分配在Node 1
// 所有内存访问都是远程访问，性能下降3倍
```

## Redis优化策略

### 1. NUMA绑定

```bash
# 绑定Redis到特定NUMA节点
numactl --cpunodebind=0 --membind=0 redis-server

# 或使用taskset
taskset -c 0-7 redis-server
```

### 2. 内存分配策略

```bash
# 使用本地内存分配
numactl --membind=0 redis-server

# 或使用interleave（跨节点分配）
numactl --interleave=all redis-server
```

### 3. Redis配置

```conf
# redis.conf

# 禁用透明大页（THP）
# 在系统层面配置：
# echo never > /sys/kernel/mm/transparent_hugepage/enabled

# 绑定CPU（在启动脚本中）
# taskset -c 0-7 redis-server
```

### 4. 多实例部署

```bash
# 每个NUMA节点部署一个Redis实例
# Node 0
numactl --cpunodebind=0 --membind=0 redis-server --port 6379

# Node 1
numactl --cpunodebind=1 --membind=1 redis-server --port 6380
```

## 性能测试

### 测试场景

```bash
# 1. 无NUMA绑定（默认）
redis-benchmark -h localhost -p 6379 -t set,get -n 1000000

# 2. NUMA绑定到Node 0
numactl --cpunodebind=0 --membind=0 redis-server
redis-benchmark -h localhost -p 6379 -t set,get -n 1000000

# 3. 跨节点访问（最差情况）
numactl --cpunodebind=0 --membind=1 redis-server
redis-benchmark -h localhost -p 6379 -t set,get -n 1000000
```

### 测试结果

| 场景 | QPS | 延迟P99 | 性能 |
|------|-----|---------|------|
| **无绑定** | 100,000 | 2ms | 基准 |
| **NUMA绑定** | 150,000 | 1ms | **+50%** |
| **跨节点** | 50,000 | 4ms | **-50%** |

## 监控与诊断

### 查看NUMA统计

```bash
# 查看NUMA统计
numastat

# 输出示例：
#                           node0           node1
# numa_hit             1234567890      9876543210
# numa_miss             123456789      987654321
# numa_foreign          987654321     123456789
# interleave_hit             12345         12345
# local_node           1234567890      9876543210
# other_node            123456789      987654321
```

### Redis内存统计

```bash
# Redis INFO命令
redis-cli INFO memory

# 关键指标：
# used_memory: 已使用内存
# used_memory_rss: 物理内存
# mem_fragmentation_ratio: 内存碎片率
```

## 最佳实践

### 1. 单实例部署

```bash
# 推荐：绑定到单个NUMA节点
numactl --cpunodebind=0 --membind=0 redis-server
```

### 2. 多实例部署

```bash
# 推荐：每个NUMA节点一个实例
# Node 0
numactl --cpunodebind=0 --membind=0 redis-server --port 6379

# Node 1
numactl --cpunodebind=1 --membind=1 redis-server --port 6380
```

### 3. 大内存场景

```bash
# 使用interleave策略（跨节点分配）
numactl --interleave=all redis-server
```

## 扩展阅读

- [CPU缓存与伪共享](./05.01.01-CPU缓存与伪共享.md)
- [内存带宽分析](./05.01.04-内存带宽分析.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 权威参考

- **《深入理解计算机系统》** - CSAPP
- **《性能之巅》** - Brendan Gregg
- **NUMA架构文档** - Linux内核文档
- **Redis官方文档** - <https://redis.io/docs/manual/optimization/>
