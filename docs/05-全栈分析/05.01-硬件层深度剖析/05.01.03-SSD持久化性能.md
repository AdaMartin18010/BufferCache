# 05.01.03 SSD持久化性能

## 概述

SSD（Solid State Drive）作为Redis持久化的存储介质，其性能特征直接影响Redis的持久化性能。理解SSD的性能特征和优化策略对于提升Redis持久化性能至关重要。

## SSD性能特征

### 1. 读写性能

```python
# SSD性能特征
class SSDPerformance:
    def __init__(self):
        self.characteristics = {
            'sequential_read': {
                'speed': '500-3500 MB/s',
                'latency': '0.1-0.5ms',
            },
            'sequential_write': {
                'speed': '400-3000 MB/s',
                'latency': '0.1-0.5ms',
            },
            'random_read': {
                'speed': '100-600K IOPS',
                'latency': '0.1-0.3ms',
            },
            'random_write': {
                'speed': '50-200K IOPS',
                'latency': '0.2-0.5ms',
            },
        }
```

### 2. 写入放大

```python
# SSD写入放大（Write Amplification）
class WriteAmplification:
    def __init__(self):
        # 写入放大 = 实际写入量 / 逻辑写入量
        self.write_amplification = {
            'good': 1.1,      # 良好状态
            'normal': 1.5,    # 正常状态
            'bad': 3.0,       # 糟糕状态
        }

    def calculate(self, logical_writes, physical_writes):
        """计算写入放大"""
        return physical_writes / logical_writes if logical_writes > 0 else 0
```

### 3. 磨损均衡

```python
# SSD磨损均衡（Wear Leveling）
class WearLeveling:
    def __init__(self):
        # SSD通过磨损均衡延长寿命
        self.endurance = {
            'consumer': '300-3000 P/E cycles',  # 消费级
            'enterprise': '10000+ P/E cycles',   # 企业级
        }
```

## Redis持久化性能

### 1. RDB性能

```python
# RDB在SSD上的性能
class RDBPerformanceOnSSD:
    def analyze(self, data_size_gb):
        """分析RDB性能"""
        # RDB是顺序写入
        sequential_write_speed = 2000  # MB/s（假设）

        return {
            'write_time': (data_size_gb * 1024) / sequential_write_speed,  # 秒
            'io_type': 'sequential',
            'optimization': '使用SSD顺序写入优势',
        }
```

### 2. AOF性能

```python
# AOF在SSD上的性能
class AOFPerformanceOnSSD:
    def analyze(self, qps, avg_command_size):
        """分析AOF性能"""
        # AOF是追加写入（顺序写入）
        sequential_write_speed = 2000  # MB/s

        write_rate_mbps = (qps * avg_command_size) / (1024 * 1024)

        return {
            'write_rate_mbps': write_rate_mbps,
            'utilization': (write_rate_mbps / sequential_write_speed) * 100,
            'io_type': 'sequential',
            'optimization': 'AOF追加写入适合SSD',
        }
```

### 3. 混合持久化性能

```python
# 混合持久化在SSD上的性能
class MixedPersistencePerformanceOnSSD:
    def analyze(self):
        """分析混合持久化性能"""
        return {
            'rdb': {
                'io_type': 'sequential',
                'performance': 'excellent',
            },
            'aof': {
                'io_type': 'sequential',
                'performance': 'excellent',
            },
            'combined': {
                'performance': 'excellent',
                'optimization': '充分利用SSD顺序写入优势',
            },
        }
```

## SSD优化策略

### 1. 对齐优化

```bash
# SSD对齐优化
# 确保Redis数据文件对齐到SSD块大小（通常4KB）

# 检查对齐
fdisk -l /dev/sda

# 对齐优化
# 1. 使用fdisk创建对齐分区
# 2. 格式化时使用4KB对齐
mkfs.ext4 -E stride=4096,stripe-width=4096 /dev/sda1
```

### 2. TRIM支持

```bash
# 启用TRIM支持
# TRIM帮助SSD回收未使用的块，提升性能

# 检查TRIM支持
hdparm -I /dev/sda | grep TRIM

# 启用TRIM（fstrim）
fstrim -v /

# 自动TRIM（fstab）
# 添加 discard 选项
UUID=xxx / ext4 defaults,discard 0 1
```

### 3. I/O调度器优化

```bash
# I/O调度器优化
# SSD推荐使用noop或none调度器

# 查看当前调度器
cat /sys/block/sda/queue/scheduler

# 设置调度器
echo noop > /sys/block/sda/queue/scheduler

# 永久设置（grub）
# 添加 elevator=noop
```

### 4. 文件系统优化

```bash
# 文件系统优化
# 推荐使用ext4或xfs

# ext4优化
mkfs.ext4 -E lazy_itable_init=0,lazy_journal_init=0 /dev/sda1

# xfs优化（更适合SSD）
mkfs.xfs -f /dev/sda1
mount -o noatime,nodiratime /dev/sda1 /data
```

## Redis配置优化

### 1. AOF配置

```conf
# redis.conf
# AOF配置优化（SSD）

# 使用everysec（平衡性能和安全性）
appendfsync everysec

# 禁用no-appendfsync-on-rewrite（SSD性能足够）
no-appendfsync-on-rewrite no

# AOF重写配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

### 2. RDB配置

```conf
# redis.conf
# RDB配置优化（SSD）

# 使用后台保存（充分利用SSD性能）
save 900 1
save 300 10
save 60 10000

# 禁用RDB压缩（SSD顺序写入快，压缩可能不必要）
rdbcompression no  # 可选
```

### 3. 混合持久化

```conf
# redis.conf
# 混合持久化配置（SSD）

# 启用混合持久化
aof-use-rdb-preamble yes

# 充分利用SSD顺序写入优势
```

## 性能测试

### 1. 基准测试

```bash
# Redis持久化性能测试
redis-benchmark -t set -n 1000000 -d 100

# AOF性能测试
redis-cli --latency -h localhost -p 6379

# RDB性能测试
time redis-cli BGSAVE
```

### 2. I/O性能测试

```bash
# SSD I/O性能测试
# 顺序写入测试
dd if=/dev/zero of=/data/test bs=1M count=1024 oflag=direct

# 随机写入测试
fio --name=random-write --ioengine=libaio --iodepth=16 \
    --rw=randwrite --bs=4k --size=1G --runtime=60 --time_based

# 顺序读取测试
dd if=/data/test of=/dev/null bs=1M count=1024 iflag=direct
```

## 性能对比

### SSD vs HDD

```python
# SSD vs HDD性能对比
class SSDAgainstHDD:
    def compare(self):
        return {
            'sequential_read': {
                'ssd': '500-3500 MB/s',
                'hdd': '100-200 MB/s',
                'improvement': '5-17x',
            },
            'random_read': {
                'ssd': '100-600K IOPS',
                'hdd': '100-200 IOPS',
                'improvement': '500-3000x',
            },
            'latency': {
                'ssd': '0.1-0.5ms',
                'hdd': '5-15ms',
                'improvement': '10-150x',
            },
        }
```

## 扩展阅读

- [RDB快照机制](../../03-Redis组件/03.02-持久化机制/03.02.01-RDB快照机制.md)
- [AOF日志机制](../../03-Redis组件/03.02-持久化机制/03.02.02-AOF日志机制.md)
- [持久化数据流](../05.04-数据流分析/05.04.02-持久化数据流.md)

## 权威参考

- **《SSD性能优化指南》** - 存储系统经典教材
- **《Redis持久化最佳实践》** - Redis官方文档
- **Linux I/O调度器文档** - <https://www.kernel.org/doc/Documentation/block/>
