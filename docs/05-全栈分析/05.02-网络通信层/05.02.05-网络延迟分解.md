# 05.02.05 网络延迟分解

## 概述

网络延迟是Redis性能的关键指标，理解延迟的各个组成部分对于优化系统性能至关重要。本文将网络延迟分解到各个层次，识别优化重点。

## 延迟组成

### 总延迟公式

```
总延迟 = 应用延迟 + 内核延迟 + 网络延迟 + 硬件延迟
```

### 详细分解

```python
# 网络延迟分解
class NetworkLatency:
    def decompose(self):
        return {
            'application': {
                'request_processing': '1-10 μs',
                'response_preparation': '1-10 μs',
            },
            'kernel': {
                'syscall': '0.1-1 μs',
                'socket_buffer': '1-10 μs',
                'protocol_stack': '5-20 μs',
                'driver': '1-5 μs',
            },
            'network': {
                'propagation': '1-100 ms',  # 取决于距离
                'transmission': '10-100 μs',  # 取决于包大小
                'queuing': '0-10 ms',  # 取决于拥塞
            },
            'hardware': {
                'nic_processing': '1-10 μs',
                'dma': '1-5 μs',
            },
        }
```

## 应用层延迟

### 1. 请求处理

```c
// Redis请求处理延迟
void processCommand(client *c) {
    // 1. 解析命令：1-5 μs
    // 2. 查找命令：0.1-1 μs
    // 3. 执行命令：1-1000 μs（取决于命令）
    // 4. 准备响应：1-5 μs
}
```

### 2. 序列化延迟

```c
// RESP协议序列化
void addReply(client *c, robj *obj) {
    // 1. 对象序列化：1-10 μs
    // 2. 写入缓冲区：0.1-1 μs
}
```

## 内核层延迟

### 1. 系统调用

```c
// 系统调用开销
// read/write: 0.1-1 μs
// epoll_wait: 0.1-1 μs（无事件）
// sendmsg/recvmsg: 0.5-2 μs
```

### 2. 协议栈

```c
// TCP/IP协议栈延迟
// 1. TCP层处理：2-5 μs
//    - 序列号检查
//    - ACK生成
//    - 窗口管理
// 2. IP层处理：1-3 μs
//    - 路由查找
//    - 分片处理
// 3. 数据链路层：1-2 μs
```

### 3. Socket缓冲区

```c
// Socket缓冲区延迟
// 1. 数据拷贝：1-10 μs（取决于大小）
// 2. 缓冲区管理：0.1-1 μs
// 3. 队列操作：0.1-1 μs
```

## 网络层延迟

### 1. 传播延迟

```python
# 传播延迟（光速限制）
class PropagationDelay:
    def calculate(self, distance_km):
        speed_of_light = 200000  # km/s（光纤中）
        return (distance_km / speed_of_light) * 1000  # ms
```

### 2. 传输延迟

```python
# 传输延迟（包大小/带宽）
class TransmissionDelay:
    def calculate(self, packet_size_bytes, bandwidth_mbps):
        return (packet_size_bytes * 8) / (bandwidth_mbps * 1e6) * 1e6  # μs
```

### 3. 排队延迟

```python
# 排队延迟（取决于拥塞）
class QueuingDelay:
    def estimate(self, queue_length, service_rate):
        return (queue_length / service_rate) * 1000  # ms
```

## 硬件层延迟

### 1. 网卡处理

```c
// 网卡处理延迟
// 1. 接收处理：1-5 μs
// 2. DMA传输：1-5 μs
// 3. 中断处理：1-10 μs
```

### 2. DMA延迟

```c
// DMA延迟
// 1. DMA设置：1-2 μs
// 2. 数据传输：1-10 μs（取决于大小）
// 3. 中断通知：1-2 μs
```

## 延迟优化

### 1. 应用层优化

```c
// 1. 减少序列化开销
//    - 使用二进制协议
//    - 批量操作
// 2. 减少内存分配
//    - 对象池
//    - 预分配缓冲区
// 3. 优化算法
//    - 减少时间复杂度
//    - 缓存热点数据
```

### 2. 内核层优化

```c
// 1. 零拷贝
//    - sendfile
//    - splice
// 2. 批量IO
//    - readv/writev
//    - io_uring
// 3. 减少系统调用
//    - epoll批量处理
//    - io_uring轮询模式
```

### 3. 网络层优化

```c
// 1. 减少RTT
//    - 就近部署
//    - CDN加速
// 2. 增大带宽
//    - 10G/25G/100G网卡
// 3. 减少拥塞
//    - 流量控制
//    - 拥塞控制算法
```

## 延迟测量

### 1. 工具

```bash
# ping测量RTT
ping -c 10 redis-server

# traceroute追踪路径
traceroute redis-server

# tcpdump抓包分析
tcpdump -i eth0 -w capture.pcap

# perf分析内核延迟
perf record -e cycles,instructions -g ./redis-server
```

### 2. Redis延迟监控

```c
// Redis延迟监控
void latencyAddSample(char *event, mstime_t latency) {
    // 记录延迟样本
    // 计算P50/P95/P99延迟
    // 生成延迟报告
}

// 延迟命令
LATENCY LATEST
LATENCY HISTORY event
LATENCY GRAPH event
```

## 扩展阅读

- [TCP/IP协议栈开销](./05.02.01-TCP-IP协议栈开销.md)
- [epoll事件循环机制](./05.02.02-epoll事件循环机制.md)
- [数据流延迟分解](../05.04-数据流分析/05.04.04-数据流延迟分解.md)

## 权威参考

- **《性能之巅》** - Brendan Gregg著
- **Linux网络性能调优** - <https://www.kernel.org/doc/Documentation/networking/>
- **Redis延迟监控** - <https://redis.io/docs/manual/optimization/latency/>
