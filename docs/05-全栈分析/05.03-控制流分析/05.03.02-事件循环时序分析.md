# 05.03.02 事件循环时序分析

## 概述

事件循环时序分析深入分析Redis事件循环的时间序列特征，包括事件处理顺序、时间事件调度、文件事件优先级等，对于理解Redis的并发模型和性能特征至关重要。

## 事件循环时序

### 基本时序

```
事件循环一次迭代：
1. 处理文件事件（可读/可写）
2. 处理时间事件（定时任务）
3. 检查是否退出
4. 返回步骤1
```

### 时间线

```python
# 事件循环时序
class EventLoopTimeline:
    def __init__(self):
        self.events = []

    def add_event(self, event_type, timestamp, duration):
        """添加事件"""
        self.events.append({
            'type': event_type,
            'timestamp': timestamp,
            'duration': duration,
        })

    def analyze_timeline(self):
        """分析时间线"""
        timeline = []
        current_time = 0

        for event in sorted(self.events, key=lambda x: x['timestamp']):
            timeline.append({
                'time': event['timestamp'],
                'type': event['type'],
                'duration': event['duration'],
            })
            current_time = event['timestamp'] + event['duration']

        return timeline
```

## 文件事件处理

### 处理顺序

```c
// Redis文件事件处理顺序
int aeProcessEvents(aeEventLoop *eventLoop, int flags) {
    int processed = 0, numevents;

    // 1. 查找最早的时间事件
    if (flags & AE_TIME_EVENTS && !(flags & AE_DONT_WAIT))
        shortest = aeSearchNearestTimer(eventLoop);

    if (shortest) {
        long now_sec, now_ms;
        aeGetTime(&now_sec, &now_ms);
        tvp = &tv;

        long long ms = (shortest->when_sec - now_sec)*1000 +
                       shortest->when_ms - now_ms;

        if (ms > 0) {
            tvp->tv_sec = ms/1000;
            tvp->tv_usec = (ms % 1000)*1000;
        } else {
            tvp->tv_sec = 0;
            tvp->tv_usec = 0;
        }
    } else {
        if (flags & AE_DONT_WAIT) {
            tv.tv_sec = tv.tv_usec = 0;
            tvp = &tv;
        } else {
            tvp = NULL; /* wait forever */
        }
    }

    // 2. 等待文件事件（epoll_wait）
    numevents = aeApiPoll(eventLoop, tvp);

    // 3. 处理文件事件
    for (j = 0; j < numevents; j++) {
        aeFileEvent *fe = &eventLoop->events[eventLoop->fired[j].fd];
        int mask = eventLoop->fired[j].mask;
        int fd = eventLoop->fired[j].fd;
        int rfired = 0;

        // 先处理读事件
        if (fe->mask & mask & AE_READABLE) {
            rfired = 1;
            fe->rfileProc(eventLoop, fd, fe->clientData, mask);
        }

        // 再处理写事件
        if (fe->mask & mask & AE_WRITABLE) {
            if (!rfired || fe->wfileProc != fe->rfileProc)
                fe->wfileProc(eventLoop, fd, fe->clientData, mask);
        }

        processed++;
    }

    // 4. 处理时间事件
    if (flags & AE_TIME_EVENTS)
        processed += processTimeEvents(eventLoop);

    return processed;
}
```

### 事件优先级

```python
# 事件优先级
class EventPriority:
    def __init__(self):
        self.priorities = {
            'read': 1,   # 读事件优先级最高
            'write': 2,  # 写事件优先级次之
            'time': 3,   # 时间事件优先级最低
        }

    def process_events(self, events):
        """按优先级处理事件"""
        sorted_events = sorted(events, key=lambda x: self.priorities.get(x['type'], 99))

        for event in sorted_events:
            self.handle_event(event)
```

## 时间事件调度

### 时间事件处理

```c
// 时间事件处理
static int processTimeEvents(aeEventLoop *eventLoop) {
    int processed = 0;
    aeTimeEvent *te;
    long long maxId;
    time_t now = time(NULL);

    // 如果系统时间被调整，修正所有时间事件
    if (now < eventLoop->lastTime) {
        te = eventLoop->timeEventHead;
        while(te) {
            te->when_sec = 0;
            te = te->next;
        }
    }
    eventLoop->lastTime = now;

    te = eventLoop->timeEventHead;
    maxId = eventLoop->timeEventNextId-1;

    while(te) {
        long now_sec, now_ms;
        long long id;

        if (te->id > maxId) {
            te = te->next;
            continue;
        }

        aeGetTime(&now_sec, &now_ms);

        if (now_sec > te->when_sec ||
            (now_sec == te->when_sec && now_ms >= te->when_ms)) {
            int retval;

            id = te->id;
            retval = te->timeProc(eventLoop, id, te->clientData);
            processed++;

            // 如果返回AE_NOMORE，删除时间事件
            if (retval != AE_NOMORE) {
                aeAddMillisecondsToNow(te,retval*1000);
            } else {
                aeDeleteTimeEvent(eventLoop, id);
            }

            te = eventLoop->timeEventHead;
        } else {
            te = te->next;
        }
    }

    return processed;
}
```

### 定时任务调度

```python
# 定时任务调度
class TimerScheduler:
    def __init__(self):
        self.timers = []

    def add_timer(self, delay, callback):
        """添加定时器"""
        timer = {
            'when': time.time() + delay,
            'callback': callback,
        }
        self.timers.append(timer)
        self.timers.sort(key=lambda x: x['when'])

    def process_timers(self):
        """处理定时器"""
        now = time.time()
        expired = [t for t in self.timers if t['when'] <= now]

        for timer in expired:
            timer['callback']()
            self.timers.remove(timer)
```

## 性能分析

### 事件处理延迟

```python
# 事件处理延迟分析
class EventLatencyAnalysis:
    def __init__(self):
        self.latencies = []

    def measure_latency(self, event_type, start_time, end_time):
        """测量延迟"""
        latency = (end_time - start_time) * 1000  # 转换为毫秒
        self.latencies.append({
            'type': event_type,
            'latency': latency,
        })

    def analyze(self):
        """分析延迟"""
        if not self.latencies:
            return {}

        latencies_by_type = {}
        for item in self.latencies:
            if item['type'] not in latencies_by_type:
                latencies_by_type[item['type']] = []
            latencies_by_type[item['type']].append(item['latency'])

        result = {}
        for event_type, latencies in latencies_by_type.items():
            result[event_type] = {
                'p50': np.percentile(latencies, 50),
                'p95': np.percentile(latencies, 95),
                'p99': np.percentile(latencies, 99),
                'max': max(latencies),
            }

        return result
```

### 吞吐量分析

```python
# 吞吐量分析
class ThroughputAnalysis:
    def __init__(self):
        self.event_counts = {}
        self.start_time = time.time()

    def record_event(self, event_type):
        """记录事件"""
        if event_type not in self.event_counts:
            self.event_counts[event_type] = 0
        self.event_counts[event_type] += 1

    def get_throughput(self):
        """获取吞吐量"""
        elapsed = time.time() - self.start_time
        if elapsed == 0:
            return {}

        throughput = {}
        for event_type, count in self.event_counts.items():
            throughput[event_type] = count / elapsed

        return throughput
```

## 扩展阅读

- [aeEventLoop核心结构](./05.03.01-aeEventLoop核心结构.md)
- [epoll事件循环机制](../05.02-网络通信层/05.02.02-epoll事件循环机制.md)
- [请求-响应数据流](../05.04-数据流分析/05.04.01-请求-响应数据流.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **《高性能网络编程》** - 网络编程经典教材
