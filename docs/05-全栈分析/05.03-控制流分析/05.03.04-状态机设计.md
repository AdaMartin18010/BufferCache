# 05.03.04 状态机设计

## 概述

状态机是Redis核心控制流的重要设计模式，用于管理连接状态、复制状态、集群状态等。理解状态机设计对于深入理解Redis内部机制至关重要。

## 状态机基础

### 基本概念

```c
// 状态机基本概念
// 1. 状态（State）：系统当前状态
// 2. 事件（Event）：触发状态转换的事件
// 3. 转换（Transition）：状态之间的转换
// 4. 动作（Action）：状态转换时执行的动作

typedef enum {
    STATE_INIT,
    STATE_CONNECTING,
    STATE_CONNECTED,
    STATE_CLOSING,
    STATE_CLOSED,
} connection_state_t;
```

### 状态机模式

```c
// 状态机模式
typedef struct {
    connection_state_t current_state;
    void (*on_enter)(void *ctx);
    void (*on_exit)(void *ctx);
    void (*on_event)(void *ctx, event_t event);
} state_machine_t;
```

## Redis连接状态机

### 1. 客户端连接状态

```c
// 客户端连接状态
typedef enum {
    CLIENT_STATE_IDLE,        // 空闲
    CLIENT_STATE_READING,     // 读取请求
    CLIENT_STATE_PROCESSING,  // 处理请求
    CLIENT_STATE_WRITING,     // 写入响应
    CLIENT_STATE_CLOSING,     // 关闭中
} client_state_t;

// 状态转换
void clientStateTransition(client *c, client_state_t new_state) {
    client_state_t old_state = c->state;

    // 退出旧状态
    switch (old_state) {
        case CLIENT_STATE_READING:
            // 清理读取缓冲区
            break;
        case CLIENT_STATE_PROCESSING:
            // 清理处理上下文
            break;
    }

    // 进入新状态
    c->state = new_state;
    switch (new_state) {
        case CLIENT_STATE_READING:
            // 初始化读取缓冲区
            break;
        case CLIENT_STATE_PROCESSING:
            // 初始化处理上下文
            break;
    }
}
```

### 2. 状态转换图

```
IDLE → READING → PROCESSING → WRITING → IDLE
  ↓                                    ↑
  └────────────── CLOSING ─────────────┘
```

## Redis复制状态机

### 1. 复制状态

```c
// 复制状态
typedef enum {
    REPL_STATE_NONE,           // 无复制
    REPL_STATE_CONNECT,        // 连接中
    REPL_STATE_CONNECTING,     // 连接建立中
    REPL_STATE_RECEIVE_PONG,   // 等待PONG
    REPL_STATE_SEND_HANDSHAKE, // 发送握手
    REPL_STATE_RECEIVE_PORT,   // 接收端口
    REPL_STATE_RECEIVE_IP,     // 接收IP
    REPL_STATE_RECEIVE_CAPA,   // 接收能力
    REPL_STATE_RECEIVE_PSYNC,  // 接收PSYNC
    REPL_STATE_TRANSFER,       // 数据传输
    REPL_STATE_CONNECTED,      // 已连接
} repl_state_t;
```

### 2. 状态转换

```c
// 复制状态转换
void replicationStateTransition(repl_state_t new_state) {
    repl_state_t old_state = server.repl_state;

    // 状态转换逻辑
    switch (old_state) {
        case REPL_STATE_CONNECT:
            if (new_state == REPL_STATE_CONNECTING) {
                // 开始连接
                connectWithMaster();
            }
            break;
        case REPL_STATE_CONNECTING:
            if (new_state == REPL_STATE_RECEIVE_PONG) {
                // 等待PONG响应
                waitForPong();
            }
            break;
        // ... 其他状态转换
    }

    server.repl_state = new_state;
}
```

### 3. 状态转换图

```
NONE → CONNECT → CONNECTING → RECEIVE_PONG → SEND_HANDSHAKE
                                                      ↓
CONNECTED ← TRANSFER ← RECEIVE_PSYNC ← RECEIVE_CAPA ← RECEIVE_IP ← RECEIVE_PORT
```

## Redis集群状态机

### 1. 节点状态

```c
// 集群节点状态
typedef enum {
    CLUSTER_NODE_NONE,         // 无状态
    CLUSTER_NODE_HANDSHAKE,    // 握手中
    CLUSTER_NODE_MEET,         // MEET中
    CLUSTER_NODE_PFAIL,        // 疑似失败
    CLUSTER_NODE_FAIL,         // 失败
    CLUSTER_NODE_NOADDR,       // 无地址
    CLUSTER_NODE_MYSELF,       // 自己
} cluster_node_state_t;
```

### 2. 集群状态

```c
// 集群状态
typedef enum {
    CLUSTER_STATE_OK,          // 正常
    CLUSTER_STATE_FAIL,        // 失败
    CLUSTER_STATE_MIGRATING,   // 迁移中
    CLUSTER_STATE_IMPORTING,   // 导入中
} cluster_state_t;
```

## 状态机实现模式

### 1. 表驱动状态机

```c
// 表驱动状态机
typedef struct {
    client_state_t current_state;
    event_t event;
    client_state_t next_state;
    void (*action)(client *c);
} state_transition_t;

static state_transition_t transitions[] = {
    {CLIENT_STATE_IDLE, EVENT_READ, CLIENT_STATE_READING, startReading},
    {CLIENT_STATE_READING, EVENT_READ_COMPLETE, CLIENT_STATE_PROCESSING, processCommand},
    {CLIENT_STATE_PROCESSING, EVENT_PROCESS_COMPLETE, CLIENT_STATE_WRITING, startWriting},
    {CLIENT_STATE_WRITING, EVENT_WRITE_COMPLETE, CLIENT_STATE_IDLE, resetClient},
    // ...
};

void stateMachineTransition(client *c, event_t event) {
    for (int i = 0; i < sizeof(transitions)/sizeof(transitions[0]); i++) {
        if (transitions[i].current_state == c->state &&
            transitions[i].event == event) {
            transitions[i].action(c);
            c->state = transitions[i].next_state;
            return;
        }
    }
}
```

### 2. 状态模式

```c
// 状态模式
typedef struct client_state {
    void (*handle_read)(client *c);
    void (*handle_write)(client *c);
    void (*handle_close)(client *c);
} client_state_t;

static client_state_t idle_state = {
    .handle_read = idleHandleRead,
    .handle_write = idleHandleWrite,
    .handle_close = idleHandleClose,
};

static client_state_t reading_state = {
    .handle_read = readingHandleRead,
    .handle_write = readingHandleWrite,
    .handle_close = readingHandleClose,
};

void clientHandleEvent(client *c, event_t event) {
    switch (event) {
        case EVENT_READ:
            c->state->handle_read(c);
            break;
        case EVENT_WRITE:
            c->state->handle_write(c);
            break;
        case EVENT_CLOSE:
            c->state->handle_close(c);
            break;
    }
}
```

## 状态机测试

### 1. 状态转换测试

```c
// 状态转换测试
void testStateTransition(void) {
    client *c = createClient();

    // 测试状态转换
    assert(c->state == CLIENT_STATE_IDLE);

    triggerEvent(c, EVENT_READ);
    assert(c->state == CLIENT_STATE_READING);

    triggerEvent(c, EVENT_READ_COMPLETE);
    assert(c->state == CLIENT_STATE_PROCESSING);

    // ...
}
```

### 2. 状态一致性测试

```c
// 状态一致性测试
void testStateConsistency(void) {
    // 确保状态转换合法
    // 确保状态数据一致
    // 确保无死锁状态
}
```

## 扩展阅读

- [aeEventLoop核心结构](./05.03.01-aeEventLoop核心结构.md)
- [事件循环时序分析](./05.03.02-事件循环时序分析.md)
- [多IO线程控制流](./05.03.03-多IO线程控制流.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《设计模式》** - GoF著
- **《状态机设计模式》** - State Pattern
