# 05.04.01 请求-响应数据流

## 概述

本文档深入分析Redis请求-响应的完整数据流，从网络接收到命令执行再到响应返回，追踪数据在系统中的完整路径。

## 数据流概览

### 完整流程

```
客户端请求 → 网络接收 → 协议解析 → 命令查找 → 命令执行 → 结果返回 → 网络发送 → 客户端接收
```

### 关键路径

```
Socket接收 → 读缓冲区 → 协议解析 → 命令执行 → 写缓冲区 → Socket发送
```

## 网络接收阶段

### Socket接收

```c
// 客户端连接处理
void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &cport);
    if (cfd == ANET_ERR) return;

    // 创建客户端连接
    acceptCommonHandler(connCreateAcceptedSocket(cfd), 0, cip);
}

// 创建客户端
client *createClient(connection *conn) {
    client *c = zmalloc(sizeof(client));

    // 初始化字段
    c->conn = conn;
    c->fd = connGetFd(conn);
    c->name = NULL;
    c->bufpos = 0;
    c->querybuf = sdsempty();
    c->querybuf_peak = 0;
    c->reqtype = 0;
    c->argc = 0;
    c->argv = NULL;
    c->cmd = NULL;
    c->multibulklen = 0;
    c->bulklen = -1;
    c->sentlen = 0;
    c->flags = 0;
    c->ctime = c->lastinteraction = server.unixtime;
    c->authenticated = 0;
    c->replstate = REPL_STATE_NONE;
    c->reply = listCreate();
    c->reply_bytes = 0;
    c->obuf_soft_limit_reached_time = 0;
    c->watched_keys = listCreate();
    c->peerid = NULL;
    c->resp = 2;
    c->user = NULL;

    // 注册读事件
    connSetReadHandler(conn, readQueryFromClient);
    connSetWriteHandler(conn, NULL);

    return c;
}
```

### 数据读取

```c
// 从客户端读取数据
void readQueryFromClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    int nread, readlen;
    size_t qblen;

    // 1. 读取数据到查询缓冲区
    nread = connRead(c->conn, c->querybuf + sdslen(c->querybuf),
                     readlen);

    if (nread == -1) {
        if (errno == EAGAIN) {
            return;
        } else {
            serverLog(LL_VERBOSE, "Reading from client: %s", strerror(errno));
            freeClientAsync(c);
            return;
        }
    } else if (nread == 0) {
        serverLog(LL_VERBOSE, "Client closed connection");
        freeClientAsync(c);
        return;
    }

    // 2. 更新查询缓冲区
    sdsIncrLen(c->querybuf, nread);
    c->lastinteraction = server.unixtime;

    // 3. 处理查询缓冲区
    if (c->querybuf_peak < sdslen(c->querybuf))
        c->querybuf_peak = sdslen(c->querybuf);

    processInputBuffer(c);
}
```

## 协议解析阶段

### RESP协议解析

```c
// 处理输入缓冲区
void processInputBuffer(client *c) {
    server.current_client = c;

    // 1. 处理多命令（Pipeline）
    while (c->qb_pos < sdslen(c->querybuf)) {
        // 2. 解析命令
        if (c->reqtype == PROTO_REQ_INLINE) {
            if (processInlineBuffer(c) != C_OK) break;
        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {
            if (processMultibulkBuffer(c) != C_OK) break;
        } else {
            serverPanic("Unknown request type");
        }

        // 3. 执行命令
        if (c->argc == 0) {
            resetClient(c);
        } else {
            // 查找命令
            c->cmd = c->lastcmd = lookupCommand(c->argv[0]->ptr);
            if (!c->cmd) {
                addReplyErrorFormat(c, "unknown command '%s'",
                                   (char *)c->argv[0]->ptr);
                resetClient(c);
                continue;
            } else if ((c->cmd->arity > 0 && c->cmd->arity != c->argc) ||
                      (c->argc < -c->cmd->arity)) {
                addReplyErrorFormat(c, "wrong number of arguments for '%s' command",
                                   c->cmd->name);
                resetClient(c);
                continue;
            }

            // 执行命令
            call(c, CMD_CALL_FULL);
        }
    }

    server.current_client = NULL;
}
```

### 多命令解析

```c
// 解析多命令（RESP协议）
int processMultibulkBuffer(client *c) {
    char *newline = NULL;
    int pos = 0, ok;
    long long ll;

    // 1. 解析命令数量
    if (c->multibulklen == 0) {
        newline = strchr(c->querybuf + c->qb_pos, '\r');
        if (newline == NULL) {
            if (sdslen(c->querybuf) - c->qb_pos > PROTO_INLINE_MAX_SIZE) {
                addReplyError(c, "Protocol error: too big multibulk length string");
                setProtocolError(c, 0);
                return C_ERR;
            }
            return C_OK;
        }

        if (newline - (c->querybuf + c->qb_pos) > (ssize_t)(sdslen(c->querybuf) - c->qb_pos - 2))
            return C_OK;

        if (c->querybuf[c->qb_pos] != '*') {
            if (c->querybuf[c->qb_pos] == '\r' || c->querybuf[c->qb_pos] == '\n') {
                c->qb_pos++;
                return processMultibulkBuffer(c);
            }
            c->reqtype = PROTO_REQ_INLINE;
            return processInlineBuffer(c);
        }

        ok = string2ll(c->querybuf + c->qb_pos + 1, newline - (c->querybuf + c->qb_pos + 1), &ll);
        if (!ok || ll > 1024 * 1024) {
            addReplyError(c, "Protocol error: invalid multibulk length");
            setProtocolError(c, pos);
            return C_ERR;
        }

        pos = newline - c->querybuf + 2;
        if (ll <= 0) {
            c->qb_pos = pos;
            return C_OK;
        }

        c->multibulklen = ll;

        if (c->argv) zfree(c->argv);
        if (c->argv_len < c->multibulklen) {
            c->argv_len = c->multibulklen;
            c->argv = zmalloc(sizeof(robj *) * c->argv_len);
        }
    }

    // 2. 解析每个参数
    while (c->multibulklen) {
        if (c->bulklen == -1) {
            newline = strchr(c->querybuf + c->qb_pos, '\r');
            if (newline == NULL) {
                if (sdslen(c->querybuf) - c->qb_pos > PROTO_INLINE_MAX_SIZE) {
                    addReplyError(c, "Protocol error: too big bulk length string");
                    setProtocolError(c, 0);
                    return C_ERR;
                }
                break;
            }

            if (newline - (c->querybuf + c->qb_pos) > (ssize_t)(sdslen(c->querybuf) - c->qb_pos - 2))
                break;

            if (c->querybuf[c->qb_pos] != '$') {
                addReplyErrorFormat(c, "Protocol error: expected '$', got '%c'",
                                   c->querybuf[c->qb_pos]);
                setProtocolError(c, pos);
                return C_ERR;
            }

            ok = string2ll(c->querybuf + c->qb_pos + 1, newline - (c->querybuf + c->qb_pos + 1), &ll);
            if (!ok || ll < 0 || ll > server.proto_max_bulk_len) {
                addReplyError(c, "Protocol error: invalid bulk length");
                setProtocolError(c, pos);
                return C_ERR;
            }

            pos = newline - c->querybuf + 2;
            if (ll >= PROTO_MBULK_BIG_ARG) {
                size_t qblen = sdslen(c->querybuf);
                if (ll + 2 > SIZE_MAX - qblen ||
                    ll + 2 > SIZE_MAX - c->qb_pos) {
                    addReplyError(c, "Protocol error: invalid bulk length");
                    setProtocolError(c, pos);
                    return C_ERR;
                }
                c->querybuf = sdsMakeRoomFor(c->querybuf, ll + 2);
            }
            c->bulklen = ll;
        }

        // 3. 读取完整参数
        if (sdslen(c->querybuf) - c->qb_pos < (unsigned)(c->bulklen + 2)) {
            break;
        } else {
            if (pos == 0)
                pos = c->qb_pos;

            c->argv[c->argc++] = createStringObject(c->querybuf + c->qb_pos, c->bulklen);
            c->qb_pos += c->bulklen + 2;
            c->bulklen = -1;
            c->multibulklen--;
        }
    }

    if (c->multibulklen == 0) {
        c->qb_pos = pos;
        return C_OK;
    }

    return C_OK;
}
```

## 命令执行阶段

### 命令查找

```c
// 查找命令
struct redisCommand *lookupCommand(sds name) {
    return dictFetchValue(server.commands, name);
}

// 命令注册
void populateCommandTable(void) {
    int j;
    int numcommands = sizeof(redisCommandTable) / sizeof(struct redisCommand);

    for (j = 0; j < numcommands; j++) {
        struct redisCommand *c = redisCommandTable + j;
        int retval1, retval2;

        retval1 = dictAdd(server.commands, sdsnew(c->name), c);
        retval2 = dictAdd(server.orig_commands, sdsnew(c->name), c);

        serverAssert(retval1 == DICT_OK && retval2 == DICT_OK);
    }
}
```

### 命令执行

```c
// 执行命令
void call(client *c, int flags) {
    long long dirty, start, duration;
    int client_old_flags = c->flags;
    struct redisCommand *real_cmd = c->cmd;

    server.fixed_time_expire++;
    server.monotonic_time = mstime();

    // 1. 命令统计
    c->cmd->calls++;
    c->cmd->microseconds += duration;

    // 2. 执行前检查
    if (c->flags & CLIENT_MULTI &&
        c->cmd->proc != execCommand && c->cmd->proc != discardCommand &&
        c->cmd->proc != multiCommand && c->cmd->proc != watchCommand) {
        queueMultiCommand(c);
        addReply(c, shared.queued);
    } else {
        // 3. 执行命令
        c->flags &= ~(CLIENT_FORCE_AOF | CLIENT_FORCE_REPL);
        redisOpArrayInit(&c->cmd_oparray);
        dirty = server.dirty;
        start = ustime();

        c->cmd->proc(c);

        duration = ustime() - start;
        dirty = server.dirty - dirty;

        // 4. 命令后处理
        if (dirty) {
            if (server.aof_state != AOF_OFF)
                feedAppendOnlyFile(c->cmd, c->db->id, c->argv, c->argc);
            if (server.repl_backlog)
                replicationFeedSlaves(server.slaves, c->db->id, c->argv, c->argc);
        }

        // 5. 慢查询日志
        if (duration > server.slowlog_log_slower_than)
            slowlogPushEntryIfNeeded(c, c->argv, c->argc, duration);

        // 6. 命令传播
        if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {
            propagateNow(c);
        }
    }

    server.fixed_time_expire--;
    c->flags &= ~CLIENT_FORCE_AOF;
    c->flags &= ~CLIENT_FORCE_REPL;
    c->flags |= client_old_flags & (CLIENT_FORCE_AOF | CLIENT_FORCE_REPL);
}
```

## 响应返回阶段

### 响应构建

```c
// 添加响应
void addReply(client *c, robj *obj) {
    if (prepareClientToWrite(c) != C_OK) return;

    if (sdslen(c->buf) == 0 && listLength(c->reply) == 0 &&
        (c->reply_bytes < PROTO_REPLY_CHUNK_BYTES)) {
        c->buf = sdscatlen(c->buf, obj->ptr, sdslen(obj->ptr));
        c->reply_bytes += sdslen(obj->ptr);
        obj = NULL;
    } else {
        listAddNodeTail(c->reply, obj);
        c->reply_bytes += getStringObjectSdsUsedMemory(obj);
        incrRefCount(obj);
    }

    _addReplyToBufferOrList(c, obj);
}

// 准备写入
int prepareClientToWrite(client *c) {
    if (c->flags & (CLIENT_LUA | CLIENT_MODULE)) return C_OK;
    if (c->fd <= 0) return C_ERR;
    if (c->flags & (CLIENT_CLOSE_AFTER_REPLY | CLIENT_CLOSE_ASAP)) return C_ERR;

    if (!clientHasPendingReplies(c) && !(c->flags & CLIENT_PENDING_WRITE)) {
        c->flags |= CLIENT_PENDING_WRITE;
        listAddNodeHead(server.clients_pending_write, c);
    }

    return C_OK;
}
```

### 数据发送

```c
// 发送响应
void sendReplyToClient(connection *conn) {
    client *c = connGetPrivateData(conn);
    int nwritten = 0, totwritten = 0, objlen;
    size_t objmem;
    robj *o;

    while (clientHasPendingReplies(c)) {
        if (c->bufpos > 0) {
            // 1. 发送缓冲区数据
            nwritten = connWrite(c->conn, c->buf + c->sentlen,
                                c->bufpos - c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;

            if ((int)c->sentlen == c->bufpos) {
                c->bufpos = 0;
                c->sentlen = 0;
            }
        } else {
            // 2. 发送回复列表数据
            o = listNodeValue(listFirst(c->reply));
            objlen = sdslen(o->ptr);
            objmem = getStringObjectSdsUsedMemory(o);

            if (objlen == 0) {
                listDelNode(c->reply, listFirst(c->reply));
                c->reply_bytes -= objmem;
                continue;
            }

            nwritten = connWrite(c->conn, o->ptr + c->sentlen,
                                objlen - c->sentlen);
            if (nwritten <= 0) break;
            c->sentlen += nwritten;
            totwritten += nwritten;

            if (c->sentlen == objlen) {
                listDelNode(c->reply, listFirst(c->reply));
                c->sentlen = 0;
                c->reply_bytes -= objmem;
            }
        }

        if (totwritten > NET_MAX_WRITES_PER_EVENT) break;
    }

    if (c->sentlen > 0) {
        c->flags |= CLIENT_PENDING_WRITE;
    } else {
        c->sentlen = 0;
        c->flags &= ~CLIENT_PENDING_WRITE;
        if (listLength(c->reply) == 0)
            clientInstallWriteHandler(c);
    }
}
```

## 性能优化

### 1. Pipeline批处理

```c
// Pipeline：批量处理多个命令
// 客户端发送：
// *3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
// *3\r\n$3\r\nGET\r\n$3\r\nkey\r\n
// *3\r\n$3\r\nDEL\r\n$3\r\nkey\r\n

// 服务器批量执行，减少网络往返
```

### 2. 响应缓冲

```c
// 响应缓冲：累积多个响应后一起发送
if (sdslen(c->buf) == 0 && listLength(c->reply) == 0 &&
    (c->reply_bytes < PROTO_REPLY_CHUNK_BYTES)) {
    // 使用缓冲区
    c->buf = sdscatlen(c->buf, obj->ptr, sdslen(obj->ptr));
} else {
    // 使用回复列表
    listAddNodeTail(c->reply, obj);
}
```

### 3. 写事件延迟注册

```c
// 延迟注册写事件，避免不必要的epoll调用
int prepareClientToWrite(client *c) {
    if (!clientHasPendingReplies(c) && !(c->flags & CLIENT_PENDING_WRITE)) {
        c->flags |= CLIENT_PENDING_WRITE;
        listAddNodeHead(server.clients_pending_write, c);
    }
}
```

## 延迟分解

### 各阶段延迟

```
总延迟 = 网络延迟 + 内核延迟 + 协议解析延迟 + 命令执行延迟 + 响应构建延迟 + 网络发送延迟

典型值：
- 网络延迟：0.1-1ms（本地）或10-100ms（远程）
- 内核延迟：0.01-0.1ms
- 协议解析延迟：0.01-0.1ms
- 命令执行延迟：0.01-10ms（取决于命令复杂度）
- 响应构建延迟：0.01-0.1ms
- 网络发送延迟：0.1-1ms
```

## 扩展阅读

- [持久化数据流](./05.04.02-持久化数据流.md)
- [复制数据流](./05.04.03-复制数据流.md)
- [epoll事件循环机制](../05.02-网络通信层/05.02.02-epoll事件循环机制.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **RESP协议规范** - <https://redis.io/docs/reference/protocol-spec/>
