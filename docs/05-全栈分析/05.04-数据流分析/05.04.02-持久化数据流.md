# 05.04.02 持久化数据流

## 目录

- [05.04.02 持久化数据流](#050402-持久化数据流)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与历史背景](#11-定义与历史背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. RDB数据流](#2-rdb数据流)
    - [2.1 RDB生成流程](#21-rdb生成流程)
    - [数据流路径](#数据流路径)
  - [3. AOF数据流](#3-aof数据流)
    - [3.1 AOF写入流程](#31-aof写入流程)
    - [数据流路径](#数据流路径-1)
  - [4. 混合持久化数据流](#4-混合持久化数据流)
    - [4.1 混合持久化流程](#41-混合持久化流程)
    - [数据流路径](#数据流路径-2)
  - [5. 数据恢复流程](#5-数据恢复流程)
    - [5.1 RDB恢复](#51-rdb恢复)
    - [5.2 AOF恢复](#52-aof恢复)
  - [6. 性能优化](#6-性能优化)
    - [6.1 Copy-on-Write优化](#61-copy-on-write优化)
    - [6.2 增量同步](#62-增量同步)
    - [6.3 异步刷盘](#63-异步刷盘)
  - [7. 延迟分解](#7-延迟分解)
    - [7.1 各阶段延迟](#71-各阶段延迟)
  - [8. 程序设计分析](#8-程序设计分析)
    - [8.1 设计模式应用](#81-设计模式应用)
    - [8.2 代码结构分析](#82-代码结构分析)
    - [8.3 设计权衡](#83-设计权衡)
    - [8.4 可扩展性分析](#84-可扩展性分析)
  - [9. 扩展阅读](#9-扩展阅读)
  - [10. 权威参考](#10-权威参考)
    - [9.1 经典书籍](#91-经典书籍)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与历史背景

**持久化数据流**是Redis持久化机制的完整数据流，包括RDB快照生成、AOF日志写入、混合持久化等场景的数据流转路径。本文档深入分析Redis持久化机制的完整数据流。

**历史发展**：

- **2009年**：Redis引入RDB快照机制
- **2010年**：Redis引入AOF日志机制
- **2015年**：Redis引入混合持久化
- **2020年代**：持久化数据流优化和性能提升

### 1.2 应用价值

持久化数据流在Redis持久化中具有重要价值：

1. **性能分析**：理解数据流有助于性能优化
2. **延迟分析**：分析各阶段延迟，定位性能瓶颈
3. **系统优化**：优化数据流，提升整体性能
4. **问题诊断**：通过数据流分析诊断问题

## 2. RDB数据流

### 2.1 RDB生成流程

```text
内存数据 → 序列化 → 压缩 → 磁盘写入 → 同步刷盘
```

### 数据流路径

```c
// RDB生成数据流
int rdbSave(char *filename) {
    rio rdb;
    FILE *fp;
    char tmpfile[256];
    char magic[10];
    int j;
    long long now = mstime();
    uint64_t cksum;

    // 1. 创建临时文件
    snprintf(tmpfile, 256, "temp-%d.rdb", (int)getpid());
    fp = fopen(tmpfile, "w");
    if (!fp) {
        serverLog(LL_WARNING, "Failed opening .rdb for saving: %s", strerror(errno));
        return REDIS_ERR;
    }

    // 2. 初始化RIO结构
    rioInitWithFile(&rdb, fp);

    // 3. 写入RDB头部
    memcpy(magic, "REDIS", 5);
    snprintf(magic + 5, sizeof(magic) - 5, "%04d", REDIS_RDB_VERSION);
    if (rdbWriteRaw(&rdb, magic, 9) == -1) goto werr;

    // 4. 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db + j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;

        // 5. 写入数据库选择器
        if (rdbSaveType(&rdb, REDIS_RDB_OPCODE_SELECTDB) == -1) goto werr;
        if (rdbSaveLen(&rdb, j) == -1) goto werr;

        // 6. 写入数据库大小
        if (rdbSaveType(&rdb, REDIS_RDB_OPCODE_RESIZEDB) == -1) goto werr;
        if (rdbSaveLen(&rdb, dictSize(d)) == -1) goto werr;
        if (rdbSaveLen(&rdb, dictSize(db->expires)) == -1) goto werr;

        // 7. 遍历所有key-value
        dictIterator *di = dictGetIterator(d);
        dictEntry *de;
        while ((de = dictNext(di)) != NULL) {
            sds keystr = dictGetKey(de);
            robj *key = createStringObject(keystr, sdslen(keystr));
            robj *val = dictGetVal(de);
            long long expiretime = getExpire(db, key);

            // 8. 写入过期时间
            if (expiretime != -1) {
                if (rdbSaveType(&rdb, REDIS_RDB_OPCODE_EXPIRETIME_MS) == -1) goto werr;
                if (rdbSaveMillisecondTime(&rdb, expiretime) == -1) goto werr;
            }

            // 9. 写入key-value
            if (rdbSaveKeyValuePair(&rdb, key, val, db->id) == -1) goto werr;
        }
        dictReleaseIterator(di);
    }

    // 10. 写入结束标记
    if (rdbSaveType(&rdb, REDIS_RDB_OPCODE_EOF) == -1) goto werr;

    // 11. 写入校验和
    cksum = rdb.cksum;
    memrev64ifbe(&cksum);
    if (rioWrite(&rdb, &cksum, 8) == 0) goto werr;

    // 12. 同步到磁盘
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    // 13. 原子替换文件
    if (rename(tmpfile, filename) == -1) {
        serverLog(LL_WARNING, "Error moving temp DB file on the final destination: %s", strerror(errno));
        unlink(tmpfile);
        return REDIS_ERR;
    }

    serverLog(LL_NOTICE, "DB saved on disk");
    server.dirty = 0;
    server.lastsave = time(NULL);
    server.lastbgsave_status = REDIS_OK;
    return REDIS_OK;
}
```

**数据流路径**：遍历所有数据库，写入key-value，同步到磁盘。

**后台RDB生成**：使用fork子进程生成RDB，避免阻塞主线程。

```c
// 后台RDB生成（fork子进程）
int rdbSaveBackground(char *filename) {
    pid_t childpid;
    long long start;

    if (server.rdb_child_pid != -1) return REDIS_ERR;

    server.dirty_before_bgsave = server.dirty;
    server.lastbgsave_try = time(NULL);
    start = ustime();

    // fork子进程
    if ((childpid = fork()) == 0) {
        // 子进程
        int retval;

        // 关闭监听socket
        closeListeningSockets(0);

        // 设置进程标题
        redisSetProcTitle("redis-rdb-bgsave");

        // 生成RDB
        retval = rdbSave(filename);

        if (retval == REDIS_OK) {
            size_t private_dirty = zmalloc_get_private_dirty();

            if (private_dirty) {
                serverLog(LL_NOTICE,
                    "RDB: %zu MB of memory used by copy-on-write",
                    private_dirty / (1024 * 1024));
            }
        }

        exitFromChild((retval == REDIS_OK) ? 0 : 1);
    } else {
        // 父进程
        server.stat_fork_time = ustime() - start;
        server.stat_fork_rate = (double) zmalloc_used_memory() * 1000000 / server.stat_fork_time / (1024 * 1024 * 1024);
        latencyAddSampleIfNeeded("fork", server.stat_fork_time / 1000);

        if (childpid == -1) {
            server.lastbgsave_status = REDIS_ERR;
            serverLog(LL_WARNING, "Can't save in background: fork: %s", strerror(errno));
            return REDIS_ERR;
        }

        serverLog(LL_NOTICE, "Background saving started by pid %d", childpid);
        server.rdb_save_time_start = time(NULL);
        server.rdb_child_pid = childpid;
        server.rdb_child_type = RDB_CHILD_TYPE_DISK;
        return REDIS_OK;
    }
    return REDIS_OK;
}
```

**定理 2.1**：RDB生成的时间复杂度为O(N)，其中N为key数量。

**证明**：

- 遍历所有数据库：O(D)（D为数据库数量）
- 遍历所有key：O(N)（N为key数量）
- 序列化key-value：O(N)
- 总时间复杂度：O(N)

## 3. AOF数据流

### 3.1 AOF写入流程

```
命令执行 → 格式化命令 → AOF缓冲区 → 同步策略 → 磁盘写入
```

### 数据流路径

```c
// AOF写入数据流
void feedAppendOnlyFile(struct redisCommand *cmd, int dictid,
                       robj **argv, int argc) {
    sds buf = sdsempty();
    robj *tmpargv[3];

    // 1. 检查数据库ID
    if (dictid != server.aof_selected_db) {
        char seldb[64];
        snprintf(seldb, sizeof(seldb), "%d", dictid);
        buf = sdscatprintf(buf, "*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n",
                          (unsigned long)strlen(seldb), seldb);
        server.aof_selected_db = dictid;
    }

    // 2. 格式化命令
    if (cmd->proc == expireCommand || cmd->proc == pexpireCommand ||
        cmd->proc == expireatCommand) {
        // 转换为PEXPIREAT
        tmpargv[0] = createStringObject("PEXPIREAT", 9);
        tmpargv[1] = argv[1];
        tmpargv[2] = argv[3];
        buf = catAppendOnlyGenericCommand(buf, 3, tmpargv);
        decrRefCount(tmpargv[0]);
    } else if (cmd->proc == setCommand && argc >= 3) {
        // SET命令：转换为SETEX或SET
        // ...
    } else {
        // 其他命令：直接格式化
        buf = catAppendOnlyGenericCommand(buf, argc, argv);
    }

    // 3. 写入AOF缓冲区
    if (server.aof_state == AOF_ON)
        server.aof_buf = sdscatlen(server.aof_buf, buf, sdslen(buf));

    // 4. 根据同步策略处理
    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        // always：立即同步
        aof_fsync(server.aof_fd);
    } else if (server.aof_fsync == AOF_FSYNC_EVERYSEC) {
        // everysec：每秒同步
        aof_background_fsync(server.aof_fd);
    }
    // no：不主动同步，由操作系统决定

    sdsfree(buf);
}
```

**数据流路径**：格式化命令，写入AOF缓冲区，根据同步策略处理。

**AOF同步策略**：always（立即同步）、everysec（每秒同步）、no（不主动同步）。

```c
// AOF同步策略
void flushAppendOnlyFile(int force) {
    ssize_t nwritten;
    int sync_in_progress = 0;
    mstime_t latency;

    if (sdslen(server.aof_buf) == 0) {
        if (server.aof_fsync == AOF_FSYNC_EVERYSEC &&
            server.aof_fsync_pending == 0)
            return;
    } else {
        // 1. 写入AOF缓冲区到文件
        nwritten = aofWrite(server.aof_fd, server.aof_buf, sdslen(server.aof_buf));
        if (nwritten != (ssize_t)sdslen(server.aof_buf)) {
            // 写入失败处理
            // ...
            return;
        }
        sdsrange(server.aof_buf, nwritten, -1);
    }

    // 2. 根据同步策略同步
    if (server.aof_fsync == AOF_FSYNC_ALWAYS) {
        // always：立即同步
        latencyStartMonitor(latency);
        aof_fsync(server.aof_fd);
        latencyEndMonitor(latency);
        latencyAddSampleIfNeeded("aof-fsync-always", latency);
        server.aof_last_fsync = server.unixtime;
    } else if ((server.aof_fsync == AOF_FSYNC_EVERYSEC &&
                server.unixtime > server.aof_last_fsync)) {
        // everysec：每秒同步
        if (!sync_in_progress) {
            aof_background_fsync(server.aof_fd);
            server.aof_fsync_pending = 1;
        }
        server.aof_last_fsync = server.unixtime;
    }
}
```

**定理 3.1**：AOF写入的时间复杂度为O(1)（单条命令）。

**证明**：

- 命令格式化：O(1)（单条命令）
- 缓冲区写入：O(1)（追加操作）
- 磁盘写入：O(1)（追加操作）
- 总时间复杂度：O(1)

## 4. 混合持久化数据流

### 4.1 混合持久化流程

```
RDB快照 → AOF增量日志 → 合并文件 → 磁盘写入
```

### 数据流路径

```c
// 混合持久化数据流
int rewriteAppendOnlyFile(char *filename) {
    rio aof;
    FILE *fp;
    char tmpfile[256];
    long long start = ustime();
    int j;
    size_t processed = 0;

    // 1. 创建临时文件
    snprintf(tmpfile, 256, "temp-rewriteaof-%d.aof", (int)getpid());
    fp = fopen(tmpfile, "w");
    if (!fp) {
        serverLog(LL_WARNING, "Opening the temp file for AOF rewrite: %s", strerror(errno));
        return C_ERR;
    }

    // 2. 初始化RIO
    rioInitWithFile(&aof, fp);

    // 3. 如果开启混合持久化，先写入RDB
    if (server.aof_use_rdb_preamble) {
        int error;
        if (rdbSaveRio(&aof, &error, RDB_SAVE_AOF_PREAMBLE, NULL) == C_ERR) {
            errno = error;
            goto werr;
        }
    } else {
        // 4. 否则写入AOF格式头部
        if (rioWrite(&aof, "REDIS", 5) == 0) goto werr;
        if (rioWriteBulkCount(&aof, '$', server.dbnum) == 0) goto werr;
    }

    // 5. 遍历所有数据库
    for (j = 0; j < server.dbnum; j++) {
        redisDb *db = server.db + j;
        dict *d = db->dict;
        if (dictSize(d) == 0) continue;

        // 6. 写入SELECT命令
        if (rioWriteBulkCount(&aof, '*', 2) == 0) goto werr;
        if (rioWriteBulkString(&aof, "SELECT", 6) == 0) goto werr;
        if (rioWriteBulkLongLong(&aof, j) == 0) goto werr;

        // 7. 遍历所有key-value
        dictIterator *di = dictGetIterator(d);
        dictEntry *de;
        while ((de = dictNext(di)) != NULL) {
            sds keystr = dictGetKey(de);
            robj *key = createStringObject(keystr, sdslen(keystr));
            robj *val = dictGetVal(de);
            long long expiretime = getExpire(db, key);

            // 8. 写入过期时间
            if (expiretime != -1) {
                if (rioWriteBulkCount(&aof, '*', 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, "PEXPIREAT", 9) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                if (rioWriteBulkLongLong(&aof, expiretime) == 0) goto werr;
            }

            // 9. 写入key-value（根据类型）
            if (val->type == OBJ_STRING) {
                if (rioWriteBulkCount(&aof, '*', 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, "SET", 3) == 0) goto werr;
                if (rioWriteBulkString(&aof, keystr, sdslen(keystr)) == 0) goto werr;
                if (rioWriteBulkObject(&aof, val) == 0) goto werr;
            } else if (val->type == OBJ_LIST) {
                // List类型
                // ...
            }
            // ... 其他类型
        }
        dictReleaseIterator(di);
    }

    // 10. 同步到磁盘
    if (fflush(fp) == EOF) goto werr;
    if (fsync(fileno(fp)) == -1) goto werr;
    if (fclose(fp) == EOF) goto werr;

    // 11. 原子替换文件
    if (rename(tmpfile, filename) == -1) {
        serverLog(LL_WARNING, "Error moving temp append only file: %s", strerror(errno));
        unlink(tmpfile);
        return C_ERR;
    }

    serverLog(LL_NOTICE, "SYNC append only file rewrite performed");
    return C_OK;
}
```

## 5. 数据恢复流程

### 5.1 RDB恢复

```c
// RDB恢复数据流
int rdbLoad(char *filename) {
    FILE *fp;
    rio rdb;
    int retval;

    // 1. 打开RDB文件
    if ((fp = fopen(filename, "r")) == NULL) {
        return REDIS_ERR;
    }

    // 2. 初始化RIO
    rioInitWithFile(&rdb, fp);

    // 3. 读取RDB头部
    char buf[1024];
    if (rioRead(&rdb, buf, 9) == 0) goto eoferr;
    buf[9] = '\0';
    if (memcmp(buf, "REDIS", 5) != 0) {
        fclose(fp);
        serverLog(LL_WARNING, "Wrong signature trying to load DB from file");
        errno = EINVAL;
        return REDIS_ERR;
    }

    // 4. 读取版本号
    int rdbver = atoi(buf + 5);
    if (rdbver < 1 || rdbver > REDIS_RDB_VERSION) {
        fclose(fp);
        serverLog(LL_WARNING, "Can't handle RDB format version %d", rdbver);
        errno = EINVAL;
        return REDIS_ERR;
    }

    // 5. 读取数据
    while (1) {
        robj *key, *val;
        uint32_t dbid, type, encoding;
        unsigned long long expiretime, now = mstime();

        // 读取操作码
        if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;

        if (type == REDIS_RDB_OPCODE_EXPIRETIME_MS) {
            if (rdbLoadMillisecondTime(&rdb, &expiretime) == -1) goto eoferr;
            if ((type = rdbLoadType(&rdb)) == -1) goto eoferr;
            if (expiretime < now) {
                // 已过期，跳过
                if (rdbLoadObject(&rdb, type) == NULL) goto eoferr;
                continue;
            }
        } else {
            expiretime = 0;
        }

        if (type == REDIS_RDB_OPCODE_SELECTDB) {
            if (rdbLoadLen(&rdb, &dbid) == -1) goto eoferr;
            if (dbid >= (unsigned)server.dbnum) {
                serverLog(LL_WARNING, "FATAL: Data file was created with a Redis server configured to handle more than %d databases. Exiting\n", server.dbnum);
                exit(1);
            }
            server.db = server.db + dbid;
            continue;
        }

        if (type == REDIS_RDB_OPCODE_RESIZEDB) {
            // 跳过
            if (rdbLoadLen(&rdb, &dbid) == -1) goto eoferr;
            if (rdbLoadLen(&rdb, &dbid) == -1) goto eoferr;
            continue;
        }

        if (type == REDIS_RDB_OPCODE_EOF) {
            break;
        }

        // 读取key-value
        if ((key = rdbLoadStringObject(&rdb)) == NULL) goto eoferr;
        if ((val = rdbLoadObject(&rdb, type)) == NULL) goto eoferr;

        // 写入数据库
        dbAdd(server.db, key, val);
        if (expiretime) {
            setExpire(NULL, server.db, key, expiretime);
        }
    }

    // 6. 校验和验证
    uint64_t cksum, expected = rdb.cksum;
    if (rioRead(&rdb, &cksum, 8) == 0) goto eoferr;
    memrev64ifbe(&cksum);
    if (cksum == 0) {
        serverLog(LL_WARNING, "RDB file was saved with checksum disabled: no check performed.");
    } else if (cksum != expected) {
        serverLog(LL_WARNING, "Wrong checksum reading RDB file.");
        exit(1);
    }

    fclose(fp);
    return REDIS_OK;
}
```

**RDB恢复**：读取RDB文件，解析数据，写入数据库。

### 5.2 AOF恢复

```c
// AOF恢复数据流
int loadAppendOnlyFile(char *filename) {
    struct client *fakeClient;
    FILE *fp;
    struct redis_stat sb;
    int old_aof_state = server.aof_state;
    long loops = 0;
    off_t valid_up_to = 0;
    off_t valid_before_multi = 0;

    // 1. 打开AOF文件
    if ((fp = fopen(filename, "r")) == NULL) {
        serverLog(LL_WARNING, "Fatal error: can't open the append log file for reading: %s", strerror(errno));
        exit(1);
    }

    // 2. 检查文件格式
    char sig[5];
    if (fread(sig, 1, 5, fp) != 5 || memcmp(sig, "REDIS", 5) != 0) {
        // 可能是RDB格式（混合持久化）
        fclose(fp);
        return loadAppendOnlyFileRDB(filename);
    }

    // 3. 读取版本号
    uint8_t byte;
    if (fread(&byte, 1, 1, fp) != 1) {
        fclose(fp);
        return C_ERR;
    }

    // 4. 如果是混合持久化，先加载RDB部分
    if (byte == 0xFE) {  // RDB magic number
        fclose(fp);
        return loadAppendOnlyFileRDB(filename);
    }

    // 5. 创建伪客户端
    fakeClient = createFakeClient();
    startLoading(fp);

    // 6. 读取并执行命令
    while (1) {
        int argc, j;
        unsigned long len;
        robj **argv;
        char buf[128];
        sds argsds = NULL;
        struct redisCommand *cmd;

        // 读取命令
        if (fgets(buf, sizeof(buf), fp) == NULL) {
            if (feof(fp))
                break;
            else
                goto readerr;
        }

        if (buf[0] != '*') goto fmterr;
        if (buf[1] == '\0') goto readerr;
        argc = atoi(buf + 1);
        if (argc < 1) goto fmterr;

        argv = zmalloc(sizeof(robj *) * argc);
        fakeClient->argc = argc;
        fakeClient->argv = argv;

        // 读取参数
        for (j = 0; j < argc; j++) {
            if (fgets(buf, sizeof(buf), fp) == NULL) goto readerr;
            if (buf[0] != '$') goto fmterr;
            len = strtol(buf + 1, NULL, 10);
            argsds = sdsnewlen(SDS_NOINIT, len);
            if (len && fread(argsds, len, 1, fp) == 0) goto readerr;
            argv[j] = createObject(OBJ_STRING, argsds);
            if (fread(buf, 2, 1, fp) == 0) goto readerr;
        }

        // 执行命令
        cmd = lookupCommand(argv[0]->ptr);
        if (!cmd) {
            serverLog(LL_WARNING, "Unknown command '%s' reading the append only file", (char *)argv[0]->ptr);
            exit(1);
        }

        fakeClient->cmd = cmd;
        cmd->proc(fakeClient);

        // 清理
        for (j = 0; j < fakeClient->argc; j++)
            decrRefCount(fakeClient->argv[j]);
        zfree(fakeClient->argv);
    }

    // 7. 清理
    fclose(fp);
    freeFakeClient(fakeClient);
    server.aof_state = old_aof_state;
    stopLoading();

    serverLog(LL_NOTICE, "DB loaded from append only file: %.2f seconds", (float)(ustime() - start) / 1000000);
    return C_OK;
}
```

**AOF恢复**：读取AOF文件，解析命令，执行命令。

## 6. 性能优化

### 6.1 Copy-on-Write优化

```c
// RDB后台生成使用Copy-on-Write
// fork子进程后，父子进程共享内存页
// 只有修改时才复制内存页

// 优势：
// - 减少内存占用
// - 加快fork速度
```

**Copy-on-Write优化**：fork子进程后，父子进程共享内存页，只有修改时才复制内存页。

### 6.2 增量同步

```c
// AOF增量写入，而非全量重写
// 只写入变更的命令，减少IO
```

**增量同步**：AOF增量写入，而非全量重写，只写入变更的命令。

### 6.3 异步刷盘

```c
// AOF everysec策略：异步刷盘
// 避免阻塞主线程
void aof_background_fsync(int fd) {
    bioCreateBackgroundJob(BIO_AOF_FSYNC, (void *)(long)fd, NULL, NULL);
}
```

**异步刷盘**：AOF everysec策略使用异步刷盘，避免阻塞主线程。

## 7. 延迟分解

### 7.1 各阶段延迟

```
RDB生成延迟：
- 内存遍历：10-100ms（取决于数据量）
- 序列化：50-500ms
- 压缩：100-1000ms
- 磁盘写入：50-500ms
- 同步刷盘：10-100ms

AOF写入延迟：
- 命令格式化：<0.1ms
- 缓冲区写入：<0.1ms
- 磁盘写入：1-10ms
- 同步刷盘：1-10ms（everysec策略）
```

**各阶段延迟**：RDB生成延迟（内存遍历、序列化、压缩、磁盘写入、同步刷盘），AOF写入延迟（命令格式化、缓冲区写入、磁盘写入、同步刷盘）。

**定理 7.1**：RDB生成的总延迟约为$T_{traverse} + T_{serialize} + T_{compress} + T_{write} + T_{sync}$，其中各阶段延迟取决于数据量。

**证明**：

- 内存遍历：$T_{traverse} = O(N)$（N为key数量）
- 序列化：$T_{serialize} = O(N)$
- 压缩：$T_{compress} = O(N)$
- 磁盘写入：$T_{write} = O(N)$
- 同步刷盘：$T_{sync} = O(1)$
- 总延迟：$T_{total} = T_{traverse} + T_{serialize} + T_{compress} + T_{write} + T_{sync}$

## 8. 扩展阅读

- [RDB快照机制](../../03-Redis组件/03.02-持久化机制/03.02.01-RDB快照机制.md)
- [AOF日志机制](../../03-Redis组件/03.02-持久化机制/03.02.02-AOF日志机制.md)
- [混合持久化](../../03-Redis组件/03.02-持久化机制/03.02.03-混合持久化.md)
- [请求-响应数据流](./05.04.01-请求-响应数据流.md)

## 9. 权威参考

### 9.1 经典书籍

1. **《Redis设计与实现（第2版）》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7111544937
   - 第10章：RDB持久化（持久化数据流详解）
   - 第11章：AOF持久化（持久化数据流详解）

2. **《操作系统概念（第9版）》** - Abraham Silberschatz, Peter Baer Galvin, Greg Gagne
   - 出版社: 高等教育出版社
   - ISBN: 978-7040394063
   - 第9章：内存管理（Copy-on-Write机制详解）

### 9.2 官方文档

1. **Redis源码 - rdb.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/rdb.c>
   - Redis的RDB实现源码

2. **Redis源码 - aof.c**
   - URL: <https://github.com/redis/redis/blob/unstable/src/aof.c>
   - Redis的AOF实现源码

### 9.3 在线资源

1. **Wikipedia - Copy-on-Write**
   - URL: <https://en.wikipedia.org/wiki/Copy-on-write>
   - 提供Copy-on-Write的详细说明
