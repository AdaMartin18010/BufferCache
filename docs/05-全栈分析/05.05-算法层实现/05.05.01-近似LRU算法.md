# 05.05.01 近似LRU算法

## 目录

- [05.05.01 近似LRU算法](#050501-近似lru算法)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [设计动机](#设计动机)
    - [精确LRU的问题](#精确lru的问题)
    - [近似LRU的优势](#近似lru的优势)
  - [2. 设计动机](#2-设计动机)
    - [2.1 精确LRU的问题](#21-精确lru的问题)
    - [2.2 近似LRU的优势](#22-近似lru的优势)
  - [3. Redis实现](#3-redis实现)
    - [3.1 数据结构设计](#31-数据结构设计)
    - [3.2 LRU时间更新机制](#32-lru时间更新机制)
    - [3.3 采样淘汰算法](#33-采样淘汰算法)
    - [3.4 idle时间计算](#34-idle时间计算)
  - [4. 程序设计分析](#4-程序设计分析)
    - [4.1 设计模式应用](#41-设计模式应用)
    - [4.2 代码结构分析](#42-代码结构分析)
    - [4.3 设计权衡](#43-设计权衡)
    - [4.4 可扩展性分析](#44-可扩展性分析)
  - [5. 采样策略](#5-采样策略)
    - [5.1 采样数量](#51-采样数量)
    - [采样算法](#采样算法)
  - [6. 性能分析](#6-性能分析)
    - [6.1 时间复杂度](#61-时间复杂度)
    - [命中率对比](#命中率对比)
  - [7. 配置优化](#7-配置优化)
    - [7.1 生产环境配置](#71-生产环境配置)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 学术论文](#91-学术论文)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 经典书籍](#93-经典书籍)
    - [9.4 在线资源](#94-在线资源)

---

## 1. 概述

### 1.1 定义与背景

**近似LRU算法**是Redis使用的内存淘汰策略，通过采样和随机淘汰，在保证性能的同时获得接近精确LRU的命中率。

**核心设计思想**：

- **采样优化**：不遍历所有key，只采样少量key
- **时间戳复用**：复用对象结构中的lru字段
- **时钟优化**：减少系统调用，使用全局时钟

### 1.2 应用价值

近似LRU的价值：

1. **性能优化**：O(1)时间复杂度，避免O(N)遍历
2. **内存优化**：不需要额外的时间戳存储
3. **命中率保证**：采样5个key即可达到95%+命中率

## 设计动机

### 精确LRU的问题

```c
// 精确LRU需要维护所有key的访问时间戳
// 每次访问都需要更新，开销大
struct LRUNode {
    int key;
    int value;
    time_t access_time;  // 需要维护时间戳
    // ...
};
```

**问题**：

- 内存开销大（每个key需要时间戳）
- CPU开销大（每次访问需要更新）
- 不适合高并发场景

### 近似LRU的优势

- **性能**：O(1)时间复杂度
- **内存**：不需要维护时间戳
- **命中率**：接近精确LRU（95%+）

## 2. 设计动机

### 2.1 精确LRU的问题

**精确LRU的实现问题**：

```c
// 精确LRU需要维护所有key的访问时间戳
struct LRUNode {
    int key;
    int value;
    time_t access_time;  // 需要维护时间戳
    // ...
};
```

**问题分析**：

1. **内存开销**：每个key需要额外的时间戳（8字节）
2. **CPU开销**：每次访问需要更新时间戳，O(N)查找最久未访问
3. **并发问题**：高并发下时间戳更新成为瓶颈
4. **不适合场景**：不适合百万级key的高并发场景

**复杂度分析**：

- **时间复杂度**：$O(N)$（需要遍历所有key）
- **空间复杂度**：$O(N)$（每个key需要时间戳）
- **更新复杂度**：$O(1)$（更新时间戳）+ $O(N)$（查找最久未访问）

### 2.2 近似LRU的优势

**近似LRU的优势**：

| 维度 | 精确LRU | 近似LRU |
|------|---------|---------|
| **时间复杂度** | O(N) | O(K)，K为采样数（默认5） |
| **空间复杂度** | O(N) | O(1)（复用lru字段） |
| **命中率** | 100% | 95%+（采样5个） |
| **CPU开销** | 高 | 低 |

**性能提升**：

$$\text{性能提升} = \frac{O(N)}{O(K)} = \frac{N}{K} \approx \frac{N}{5}$$

## 3. Redis实现

### 3.1 数据结构设计

**数据结构设计分析**：

```c
typedef struct redisObject {
    unsigned type:4;           // 对象类型（4位）
    unsigned encoding:4;        // 编码类型（4位）
    unsigned lru:LRU_BITS;     // LRU时间（24位）
    int refcount;              // 引用计数
    void *ptr;                 // 指向实际数据
} robj;
```

**设计要点**：

1. **位域优化**：使用位域节省内存，type和encoding各4位
2. **字段复用**：lru字段在LRU模式下存储时间，LFU模式下存储频率
3. **精度权衡**：24位可以表示$2^{24} = 16,777,216$个时间值，精度约1秒

**时间精度计算**：

$$T_{precision} = \frac{T_{max}}{2^{LRU\_BITS}} = \frac{194 \times 24 \times 3600}{2^{24}} \approx 1 \text{ 秒}$$

其中$T_{max}$为最大时间差（194天）。

### 3.2 LRU时间更新机制

**LRU时间更新设计**：

```c
void updateLRU(robj *o) {
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        updateLFU(o);  // LFU模式：复用lru字段存储频率
    } else {
        o->lru = LRU_CLOCK();  // LRU模式：存储当前时间
    }
}
```

**时钟优化设计**：

```c
unsigned int LRU_CLOCK(void) {
    unsigned int lruclock = server.lruclock;
    if (lruclock == 0) {
        // 每100ms更新一次（减少系统调用）
        return (mstime() / LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
    }
    return lruclock;
}
```

**设计分析**：

1. **全局时钟**：使用`server.lruclock`全局变量，避免频繁系统调用
2. **精度权衡**：100ms精度足够，减少系统调用开销
3. **模式切换**：通过策略标志位支持LRU/LFU模式切换

**性能优化**：

$$N_{syscalls} = \frac{T_{interval}}{T_{resolution}} = \frac{1000ms}{100ms} = 10 \text{ 次/秒}$$

相比每次访问都调用`mstime()`，减少99%的系统调用。

### 3.3 采样淘汰算法

**采样淘汰算法设计**：

```c
int freeMemoryIfNeeded(void) {
    // 1. 选择采样字典
    dict *sampledict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU) ?
                       server.db[dbid].dict : server.db[dbid].expires;

    // 2. 采样N个key（默认5个）
    long long best_idle = 0;
    int best_k = 0;
    for (int k = 0; k < server.maxmemory_samples; k++) {
        dictEntry *de = dictGetRandomKey(sampledict);
        if (de == NULL) break;

        robj *o = dictGetVal(de);
        long long idle = estimateObjectIdleTime(o);

        // 3. 选择idle时间最长的key
        if (idle > best_idle) {
            best_idle = idle;
            best_k = k;
        }
    }

    // 4. 淘汰idle时间最长的key
    // ...
}
```

**算法复杂度**：

- **时间复杂度**：$O(K)$，$K$为采样数量（默认5）
- **空间复杂度**：$O(1)$，只需要几个局部变量

**采样策略**：

$$P_{hit} = 1 - \left(\frac{N-K}{N}\right)^K$$

其中$N$为总key数，$K$为采样数。当$K=5$时，$P_{hit} \approx 95\%$。

### 3.4 idle时间计算

**idle时间计算设计**：

```c
unsigned long long estimateObjectIdleTime(robj *o) {
    unsigned long long lruclock = LRU_CLOCK();
    if (lruclock >= o->lru) {
        // 正常情况：当前时间 >= 对象时间
        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
    } else {
        // 处理时钟回绕：24位溢出
        return (lruclock + (LRU_CLOCK_MAX - o->lru)) * LRU_CLOCK_RESOLUTION;
    }
}
```

**时钟回绕处理**：

$$
T_{idle} = \begin{cases}
(lruclock - o->lru) \times T_{resolution} & \text{if } lruclock \geq o->lru \\
(lruclock + (2^{24} - o->lru)) \times T_{resolution} & \text{if } lruclock < o->lru
\end{cases}
$$

**设计要点**：

1. **回绕检测**：24位时钟会回绕，需要特殊处理
2. **精度保证**：使用`LRU_CLOCK_RESOLUTION`（100ms）保证精度
3. **性能优化**：简单的算术运算，O(1)时间复杂度

## 4. 程序设计分析

### 4.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：通过`maxmemory_policy`选择不同的淘汰策略
2. **模板方法模式**：`freeMemoryIfNeeded()`定义淘汰框架，具体策略实现细节
3. **单例模式**：`server.lruclock`全局时钟，单例管理

**策略模式实现**：

```c
// 策略选择
if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU) {
    // LRU策略实现
} else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LFU) {
    // LFU策略实现
}
```

### 4.2 代码结构分析

**代码组织**：

1. **数据层**：`robj`结构体存储LRU时间
2. **逻辑层**：`freeMemoryIfNeeded()`实现淘汰逻辑
3. **工具层**：`LRU_CLOCK()`、`estimateObjectIdleTime()`提供工具函数

**模块化设计**：

- **高内聚**：相关功能集中在同一模块
- **低耦合**：通过接口交互，减少依赖
- **可扩展**：易于添加新的淘汰策略

### 4.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **精度 vs 性能** | 100ms精度 | 减少系统调用，性能优先 |
| **内存 vs 精度** | 24位时间戳 | 平衡内存占用和时间范围 |
| **采样数 vs 命中率** | 5个采样 | 平衡性能和命中率 |
| **复杂度 vs 准确性** | 近似算法 | 性能优先，可接受的准确性损失 |

**权衡公式**：

$$C_{total} = C_{memory} + C_{cpu} + C_{accuracy\_loss}$$

其中：

- $C_{memory}$：内存成本（24位时间戳）
- $C_{cpu}$：CPU成本（采样K个key）
- $C_{accuracy\_loss}$：准确性损失成本（5%命中率损失）

### 4.4 可扩展性分析

**扩展点**：

1. **采样策略**：可扩展为加权采样、分层采样
2. **淘汰策略**：可扩展为混合策略（LRU+LFU）
3. **时钟精度**：可配置时钟精度（50ms/100ms/200ms）

**扩展性设计**：

```c
// 可扩展的采样接口
typedef dictEntry* (*sample_func)(dict *d, int count);

// 可扩展的淘汰接口
typedef int (*evict_func)(dict *d, sample_func sample);
```

**可维护性**：

- **代码清晰**：函数职责单一，易于理解
- **注释完善**：关键逻辑有注释说明
- **测试友好**：函数可独立测试

## 5. 采样策略

### 5.1 采样数量

```c
// 默认采样数量：5个key
# define CONFIG_DEFAULT_MAXMEMORY_SAMPLES 5

// 采样数量对命中率的影响：
// 采样数=1：命中率 ~60%
// 采样数=5：命中率 ~95%
// 采样数=10：命中率 ~98%
// 采样数=20：命中率 ~99%
```

### 采样算法

```c
// 随机采样
dictEntry *dictGetRandomKey(dict *d) {
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;

    if (dictIsRehashing(d)) {
        // 如果正在rehash，需要同时采样两个哈希表
        do {
            h = d->rehashidx + (random() % (d->ht[0].size + d->ht[1].size - d->rehashidx));
            he = (h >= d->ht[0].size) ?
                 d->ht[1].table[h - d->ht[0].size] :
                 d->ht[0].table[h];
            h++;
        } while (he == NULL);
    } else {
        // 正常情况：只采样一个哈希表
        do {
            h = random() & d->ht[0].sizemask;
            he = d->ht[0].table[h];
        } while (he == NULL);
    }

    // 从链表中随机选择一个元素
    listlen = 0;
    orighe = he;
    while (he) {
        he = he->next;
        listlen++;
    }
    listele = random() % listlen;
    he = orighe;
    while (listele--) he = he->next;

    return he;
}
```

## 6. 性能分析

### 6.1 时间复杂度

- **精确LRU**：O(N)（需要遍历所有key）
- **近似LRU**：O(K)，K为采样数量（默认5）

**性能提升**：O(N) → O(5) = **N/5倍**

### 命中率对比

| 采样数量 | 命中率 | CPU开销 |
|----------|--------|---------|
| **1** | ~60% | 最低 |
| **5** | ~95% | 低 |
| **10** | ~98% | 中 |
| **20** | ~99% | 高 |

**推荐**：采样数量=5（平衡性能和命中率）

## 7. 配置优化

### 7.1 生产环境配置

```conf
# redis.conf

# 最大内存
maxmemory 2gb

# 淘汰策略
maxmemory-policy allkeys-lru

# 采样数量（默认5）
maxmemory-samples 5

# 调优建议
# 高命中率要求：增大采样数量（10-20）
# 高性能要求：减小采样数量（3-5）
# 内存受限：使用volatile-lru
```

## 8. 扩展阅读

- [LRU算法原理与实现](../../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [LFU算法实现](./05.05.02-LFU算法实现.md)
- [Random采样淘汰算法](./05.05.03-Random采样淘汰算法.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 9. 权威参考

### 9.1 学术论文

1. **"The LRU-K Page Replacement Algorithm For Database Disk Buffering"** - O'Neil et al., SIGMOD, 1993
   - DOI: 10.1145/170035.170081
   - LRU-K算法的原始论文

2. **"Approximate LRU Replacement"** - Redis官方文档
   - URL: <https://redis.io/docs/manual/eviction/>
   - Redis近似LRU实现说明

### 9.2 官方文档

1. **Redis源码** - GitHub
   - URL: <https://github.com/redis/redis>
   - 文件：`evict.c`、`object.c`

2. **Redis内存淘汰策略** - Redis官方文档
   - URL: <https://redis.io/docs/manual/eviction/>

### 9.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-45342-0
   - 深入讲解Redis近似LRU实现

2. **《算法导论》** - Thomas H. Cormen等
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-40701-0
   - 缓存替换算法理论基础

### 9.4 在线资源

1. **Redis内存淘汰机制详解** - 掘金
   - URL: <https://juejin.cn/>
   - 近似LRU算法实现分析

2. **LRU算法可视化** - Visualgo
   - URL: <https://visualgo.net/>
   - LRU算法动画演示
