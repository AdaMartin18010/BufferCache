# 05.05.01 近似LRU算法

## 概述

Redis使用近似LRU算法而非精确LRU，通过采样和随机淘汰，在保证性能的同时获得接近LRU的命中率。

## 设计动机

### 精确LRU的问题

```c
// 精确LRU需要维护所有key的访问时间戳
// 每次访问都需要更新，开销大
struct LRUNode {
    int key;
    int value;
    time_t access_time;  // 需要维护时间戳
    // ...
};
```

**问题**：

- 内存开销大（每个key需要时间戳）
- CPU开销大（每次访问需要更新）
- 不适合高并发场景

### 近似LRU的优势

- **性能**：O(1)时间复杂度
- **内存**：不需要维护时间戳
- **命中率**：接近精确LRU（95%+）

## Redis实现

### 数据结构

```c
// Redis对象结构
typedef struct redisObject {
    unsigned type:4;           // 对象类型
    unsigned encoding:4;        // 编码类型
    unsigned lru:LRU_BITS;     // LRU时间（24位）
    int refcount;              // 引用计数
    void *ptr;                 // 指向实际数据
} robj;

// LRU_BITS = 24位
// 可以表示2^24 = 16777216个不同的时间值
// 精度：约1秒（假设最大时间差为194天）
```

### LRU时间更新

```c
// 更新LRU时间
void updateLRU(robj *o) {
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        // LFU模式：使用lru字段存储频率
        updateLFU(o);
    } else {
        // LRU模式：存储当前时间
        o->lru = LRU_CLOCK();
    }
}

// 获取LRU时钟
unsigned int LRU_CLOCK(void) {
    unsigned int lruclock = LRU_CLOCK();
    if (lruclock == 0) {
        // 每100ms更新一次（减少系统调用）
        return (mstime() / LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;
    }
    return lruclock;
}
```

### 采样淘汰

```c
// 近似LRU淘汰
int freeMemoryIfNeeded(void) {
    // ...

    if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU ||
        server.maxmemory_policy == MAXMEMORY_VOLATILE_LRU) {

        struct evictionPoolEntry *pool = EvictionPoolLRU;

        while (mem_freed < mem_tofree) {
            unsigned long id;
            long long best_idle = 0;
            int best_k = 0;
            struct dictEntry *de;
            dict *sampledict;

            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU)
                sampledict = server.db[dbid].dict;
            else
                sampledict = server.db[dbid].expires;

            // 1. 采样N个key（默认5个）
            for (int k = 0; k < server.maxmemory_samples; k++) {
                sds key;
                robj *o;
                dictEntry *de;
                long long idle;

                // 随机采样
                de = dictGetRandomKey(sampledict);
                if (de == NULL) break;

                key = dictGetKey(de);
                o = dictGetVal(de);
                idle = estimateObjectIdleTime(o);

                // 2. 选择idle时间最长的key
                if (idle > best_idle) {
                    best_idle = idle;
                    best_k = k;
                }
            }

            // 3. 淘汰idle时间最长的key
            if (best_k >= 0) {
                de = dictGetRandomKey(sampledict);
                // ... 淘汰key
            }
        }
    }

    // ...
}
```

### 计算idle时间

```c
// 估算对象的idle时间
unsigned long long estimateObjectIdleTime(robj *o) {
    unsigned long long lruclock = LRU_CLOCK();
    if (lruclock >= o->lru) {
        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;
    } else {
        // 处理时钟回绕
        return (lruclock + (LRU_CLOCK_MAX - o->lru)) * LRU_CLOCK_RESOLUTION;
    }
}
```

## 采样策略

### 采样数量

```c
// 默认采样数量：5个key
#define CONFIG_DEFAULT_MAXMEMORY_SAMPLES 5

// 采样数量对命中率的影响：
// 采样数=1：命中率 ~60%
// 采样数=5：命中率 ~95%
// 采样数=10：命中率 ~98%
// 采样数=20：命中率 ~99%
```

### 采样算法

```c
// 随机采样
dictEntry *dictGetRandomKey(dict *d) {
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;

    if (dictIsRehashing(d)) {
        // 如果正在rehash，需要同时采样两个哈希表
        do {
            h = d->rehashidx + (random() % (d->ht[0].size + d->ht[1].size - d->rehashidx));
            he = (h >= d->ht[0].size) ?
                 d->ht[1].table[h - d->ht[0].size] :
                 d->ht[0].table[h];
            h++;
        } while (he == NULL);
    } else {
        // 正常情况：只采样一个哈希表
        do {
            h = random() & d->ht[0].sizemask;
            he = d->ht[0].table[h];
        } while (he == NULL);
    }

    // 从链表中随机选择一个元素
    listlen = 0;
    orighe = he;
    while (he) {
        he = he->next;
        listlen++;
    }
    listele = random() % listlen;
    he = orighe;
    while (listele--) he = he->next;

    return he;
}
```

## 性能分析

### 时间复杂度

- **精确LRU**：O(N)（需要遍历所有key）
- **近似LRU**：O(K)，K为采样数量（默认5）

**性能提升**：O(N) → O(5) = **N/5倍**

### 命中率对比

| 采样数量 | 命中率 | CPU开销 |
|----------|--------|---------|
| **1** | ~60% | 最低 |
| **5** | ~95% | 低 |
| **10** | ~98% | 中 |
| **20** | ~99% | 高 |

**推荐**：采样数量=5（平衡性能和命中率）

## 配置优化

### 生产环境配置

```conf
# redis.conf

# 最大内存
maxmemory 2gb

# 淘汰策略
maxmemory-policy allkeys-lru

# 采样数量（默认5）
maxmemory-samples 5

# 调优建议
# 高命中率要求：增大采样数量（10-20）
# 高性能要求：减小采样数量（3-5）
# 内存受限：使用volatile-lru
```

## 扩展阅读

- [LRU算法原理与实现](../../01-理论基础/01.01-基础替换算法/01.01.01-LRU算法原理与实现.md)
- [LFU算法实现](./05.05.02-LFU算法实现.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **LRU算法论文** - "The LRU-K Page Replacement Algorithm For Database Disk Buffering"
