# 05.05.02 LFU算法实现

## 概述

Redis 4.0引入了LFU（Least Frequently Used，最少使用）淘汰策略，通过统计访问频率而非访问时间，更好地适应热点数据场景。

## 设计动机

### LRU的局限性

```c
// LRU只考虑访问时间，不考虑访问频率
// 问题：新数据可能立即被淘汰（即使访问频率高）
```

### LFU的优势

- **频率统计**：考虑访问频率，而非时间
- **热点数据**：更好地保留热点数据
- **适应性强**：适应访问模式变化

## Redis实现

### LFU时间戳复用

```c
// Redis复用lru字段存储LFU数据
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS;  // 复用：存储LFU数据
    int refcount;
    void *ptr;
} robj;

// LFU数据格式（24位）
// +--------+------------+
// | 8位计数| 16位时间戳 |
// +--------+------------+
// 计数：0-255（对数计数）
// 时间戳：最后访问时间（分钟精度）
```

### LFU数据结构

```c
// LFU数据编码
#define LFU_INIT_VAL 5        // 初始计数
#define LFU_LOG_FACTOR 10     // 对数因子

// 获取LFU计数
uint8_t LFUDecrAndReturn(robj *o) {
    unsigned long ldt = o->lru >> 8;
    unsigned long counter = o->lru & 255;
    unsigned long num_periods = server.lfu_decay_time ?
        LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;

    if (num_periods)
        counter = (num_periods > counter) ? 0 : counter - num_periods;

    return counter;
}

// 更新LFU计数
void LFULogIncr(robj *o) {
    unsigned long counter;
    counter = LFUDecrAndReturn(o);

    if (counter == 255) return;

    // 对数增长
    double r = (double)rand() / RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval < 0) baseval = 0;
    double p = 1.0 / (baseval * server.lfu_log_factor + 1);

    if (r < p) counter++;

    o->lru = (LFUGetTimeInMinutes() << 8) | counter;
}
```

### 对数计数

```c
// LFU使用对数计数而非线性计数
// 原因：255位无法存储大频率值

// 对数增长公式
// P = 1 / (counter * lfu_log_factor + 1)
// counter++的概率 = P

// 示例：
// counter=0: P=1.0 (100%增长)
// counter=10: P≈0.01 (1%增长)
// counter=100: P≈0.001 (0.1%增长)
```

**优势**：
- 255位可以表示非常大的频率值
- 热点数据计数增长快
- 冷数据计数增长慢

### 时间衰减

```c
// LFU时间衰减
unsigned long LFUTimeElapsed(unsigned long ldt) {
    unsigned long now = LFUGetTimeInMinutes();
    if (now >= ldt) return now - ldt;
    return 65535 - ldt + now;  // 处理回绕
}

// 衰减公式
// counter = counter - (elapsed_time / lfu_decay_time)
// 如果elapsed_time > counter * lfu_decay_time，counter = 0
```

**作用**：
- 防止旧热点数据永久占用缓存
- 适应访问模式变化

## 淘汰策略

### LFU淘汰实现

```c
// LFU淘汰
int freeMemoryIfNeeded(void) {
    // ...

    if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LFU ||
        server.maxmemory_policy == MAXMEMORY_VOLATILE_LFU) {

        struct evictionPoolEntry *pool = EvictionPoolLRU;

        while (mem_freed < mem_tofree) {
            unsigned long id;
            double best_score = 0;
            int best_k = 0;
            struct dictEntry *de;
            dict *sampledict;

            if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LFU)
                sampledict = server.db[dbid].dict;
            else
                sampledict = server.db[dbid].expires;

            // 1. 采样N个key
            for (int k = 0; k < server.maxmemory_samples; k++) {
                sds key;
                robj *o;
                dictEntry *de;
                double score;

                de = dictGetRandomKey(sampledict);
                if (de == NULL) break;

                key = dictGetKey(de);
                o = dictGetVal(de);

                // 2. 计算LFU分数
                score = LFUGetScore(o);

                // 3. 选择分数最低的key
                if (score < best_score || best_score == 0) {
                    best_score = score;
                    best_k = k;
                }
            }

            // 4. 淘汰分数最低的key
            if (best_k >= 0) {
                de = dictGetRandomKey(sampledict);
                // ... 淘汰key
            }
        }
    }

    // ...
}
```

### LFU分数计算

```c
// 计算LFU分数
double LFUGetScore(robj *o) {
    unsigned long ldt = o->lru >> 8;
    unsigned long counter = o->lru & 255;

    // 衰减计数
    unsigned long num_periods = server.lfu_decay_time ?
        LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;

    if (num_periods)
        counter = (num_periods > counter) ? 0 : counter - num_periods;

    // 分数 = 计数（越低越容易被淘汰）
    return (double)counter;
}
```

## 配置参数

### 关键配置

```conf
# redis.conf

# LFU淘汰策略
maxmemory-policy allkeys-lfu  # 或 volatile-lfu

# LFU对数因子（默认10）
lfu-log-factor 10

# LFU衰减时间（默认1分钟）
lfu-decay-time 1

# 采样数量（默认5）
maxmemory-samples 5
```

### 参数调优

```conf
# lfu-log-factor调优
# 值越大，计数增长越慢
# 推荐值：10（默认）

# lfu-decay-time调优
# 值越大，衰减越慢
# 推荐值：1-60分钟
```

## 性能分析

### 时间复杂度

- **更新计数**：O(1)
- **计算分数**：O(1)
- **淘汰选择**：O(K)，K为采样数量

### 命中率对比

| 场景 | LRU命中率 | LFU命中率 | 提升 |
|------|-----------|-----------|------|
| **热点数据** | 85% | 95% | +10% |
| **频率局部性** | 70% | 90% | +20% |
| **时间局部性** | 90% | 85% | -5% |

## 适用场景

### 优势场景

1. **热点数据场景**
   - 有明显频率局部性
   - 访问频率差异大

2. **内容推荐**
   - 热门内容访问频率高
   - 需要保留热点内容

3. **广告系统**
   - 热门广告点击率高
   - 需要优先保留

### 不适用场景

1. **时间局部性场景**
   - 访问模式随时间变化
   - LRU更合适

2. **新数据场景**
   - 新数据可能立即被淘汰
   - 需要预热

## 扩展阅读

- [LFU算法原理与实现](../../01-理论基础/01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)
- [近似LRU算法](./05.05.01-近似LRU算法.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **LFU算法论文** - "An O(1) algorithm for implementing the LFU cache eviction scheme"
