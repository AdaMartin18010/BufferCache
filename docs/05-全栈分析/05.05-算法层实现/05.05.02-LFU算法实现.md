# 05.05.02 LFU算法实现

## 目录

- [05.05.02 LFU算法实现](#050502-lfu算法实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 设计动机](#2-设计动机)
    - [2.1 LRU的局限性](#21-lru的局限性)
    - [2.2 LFU的优势](#22-lfu的优势)
  - [3. Redis实现](#3-redis实现)
    - [3.1 数据结构设计](#31-数据结构设计)
    - [3.2 对数计数算法](#32-对数计数算法)
    - [3.3 时间衰减机制](#33-时间衰减机制)
    - [3.4 淘汰策略实现](#34-淘汰策略实现)
  - [4. 程序设计分析](#4-程序设计分析)
    - [4.1 设计模式应用](#41-设计模式应用)
    - [4.2 代码结构分析](#42-代码结构分析)
    - [4.3 设计权衡](#43-设计权衡)
    - [4.4 可扩展性分析](#44-可扩展性分析)
  - [5. 配置参数](#5-配置参数)
    - [5.1 关键配置](#51-关键配置)
    - [5.2 参数调优](#52-参数调优)
  - [6. 性能分析](#6-性能分析)
    - [6.1 时间复杂度](#61-时间复杂度)
    - [6.2 命中率对比](#62-命中率对比)
  - [7. 适用场景](#7-适用场景)
    - [7.1 优势场景](#71-优势场景)
    - [7.2 不适用场景](#72-不适用场景)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 学术论文](#91-学术论文)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 经典书籍](#93-经典书籍)
    - [9.4 在线资源](#94-在线资源)

---

## 1. 概述

### 1.1 定义与背景

**LFU（Least Frequently Used，最少使用）**是Redis 4.0引入的淘汰策略，通过统计访问频率而非访问时间，更好地适应热点数据场景。

**核心设计思想**：

- **频率统计**：统计访问频率，而非最后访问时间
- **对数计数**：使用对数计数压缩频率值到8位
- **时间衰减**：防止旧热点数据永久占用缓存

### 1.2 应用价值

LFU算法的价值：

1. **热点数据保留**：更好地保留高频访问的数据
2. **适应性强**：通过时间衰减适应访问模式变化
3. **性能优化**：O(1)更新复杂度，O(K)淘汰复杂度

## 2. 设计动机

### 2.1 LRU的局限性

**LRU的问题**：

```c
// LRU只考虑访问时间，不考虑访问频率
// 问题：新数据可能立即被淘汰（即使访问频率高）
```

**问题分析**：

1. **时间局部性假设**：假设最近访问的数据会再次访问
2. **频率忽略**：不考虑访问频率，可能淘汰高频数据
3. **新数据问题**：新数据可能立即被淘汰

**场景示例**：

- **热点数据**：频繁访问但最近未访问的数据可能被淘汰
- **新数据**：新插入的高频数据可能立即被淘汰

### 2.2 LFU的优势

**LFU的优势**：

| 维度 | LRU | LFU |
|------|-----|-----|
| **统计维度** | 访问时间 | 访问频率 |
| **热点数据** | 可能被淘汰 | 优先保留 |
| **新数据** | 可能立即淘汰 | 需要预热 |
| **适应性强** | 弱 | 强（时间衰减） |

**命中率提升**：

$$\Delta H = H_{LFU} - H_{LRU} \approx +10-20\%$$

在热点数据场景下，LFU命中率通常比LRU高10-20%。

## 3. Redis实现

### 3.1 数据结构设计

**字段复用设计**：

```c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS;  // 复用：存储LFU数据
    int refcount;
    void *ptr;
} robj;
```

**LFU数据格式（24位）**：

```text
+--------+------------+
| 8位计数| 16位时间戳 |
+--------+------------+
```

**设计分析**：

1. **字段复用**：复用`lru`字段，避免额外内存开销
2. **位域划分**：8位计数 + 16位时间戳 = 24位
3. **精度权衡**：计数0-255，时间戳分钟精度

**内存节省**：

$$S_{saved} = N \times 8 \text{ 字节}$$

其中$N$为key数量，每个key节省8字节时间戳。

### 3.2 对数计数算法

**对数增长公式**：

$$P(counter) = \frac{1}{baseval \times lfu\_log\_factor + 1}$$

其中：

- $baseval = \max(0, counter - LFU\_INIT\_VAL)$
- $lfu\_log\_factor$：对数因子（默认10）

**实现代码**：

```c
void LFULogIncr(robj *o) {
    unsigned long counter = LFUDecrAndReturn(o);
    if (counter == 255) return;  // 已满，不再增长

    // 对数增长
    double r = (double)rand() / RAND_MAX;
    double baseval = counter - LFU_INIT_VAL;
    if (baseval < 0) baseval = 0;
    double p = 1.0 / (baseval * server.lfu_log_factor + 1);

    if (r < p) counter++;  // 概率增长
    o->lru = (LFUGetTimeInMinutes() << 8) | counter;
}
```

**对数计数优势**：

| counter值 | 增长概率P | 实际频率范围 |
|----------|-----------|--------------|
| 0-5 | 100% | 1-5次 |
| 10 | ~1% | ~100次 |
| 50 | ~0.2% | ~5000次 |
| 100 | ~0.1% | ~10000次 |
| 255 | 0% | ~百万次 |

**频率映射公式**：

$$F_{actual} \approx counter \times 10^{counter/10}$$

### 3.3 时间衰减机制

**时间衰减公式**：

$$counter_{new} = \max(0, counter_{old} - \lfloor\frac{T_{elapsed}}{T_{decay}}\rfloor)$$

其中：

- $T_{elapsed}$：距离最后访问的时间（分钟）
- $T_{decay}$：衰减时间（默认1分钟）

**实现代码**：

```c
uint8_t LFUDecrAndReturn(robj *o) {
    unsigned long ldt = o->lru >> 8;  // 最后访问时间
    unsigned long counter = o->lru & 255;  // 计数
    unsigned long num_periods = server.lfu_decay_time ?
        LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;

    if (num_periods)
        counter = (num_periods > counter) ? 0 : counter - num_periods;

    return counter;
}
```

**衰减效果**：

- **快速衰减**：$T_{decay} = 1$分钟，快速适应变化
- **慢速衰减**：$T_{decay} = 60$分钟，保留长期热点

### 3.4 淘汰策略实现

**LFU淘汰算法**：

```c
int freeMemoryIfNeeded(void) {
    // 1. 采样N个key
    for (int k = 0; k < server.maxmemory_samples; k++) {
        dictEntry *de = dictGetRandomKey(sampledict);
        robj *o = dictGetVal(de);

        // 2. 计算LFU分数（计数越低越容易被淘汰）
        double score = LFUGetScore(o);

        // 3. 选择分数最低的key
        if (score < best_score || best_score == 0) {
            best_score = score;
            best_k = k;
        }
    }

    // 4. 淘汰分数最低的key
    // ...
}
```

**分数计算**：

$$score = counter_{decayed}$$

其中$counter_{decayed}$为衰减后的计数。

## 4. 程序设计分析

### 4.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：通过`maxmemory_policy`选择LFU策略
2. **模板方法模式**：`freeMemoryIfNeeded()`定义淘汰框架
3. **单例模式**：全局配置`server.lfu_log_factor`、`server.lfu_decay_time`

**策略模式实现**：

```c
// 策略选择
if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LFU) {
    // LFU策略实现
    score = LFUGetScore(o);
} else if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_LRU) {
    // LRU策略实现
    idle = estimateObjectIdleTime(o);
}
```

### 4.2 代码结构分析

**代码组织**：

1. **数据层**：`robj`结构体存储LFU数据（计数+时间戳）
2. **逻辑层**：`LFULogIncr()`、`LFUDecrAndReturn()`实现核心逻辑
3. **策略层**：`freeMemoryIfNeeded()`实现淘汰策略

**模块化设计**：

- **高内聚**：LFU相关功能集中在同一模块
- **低耦合**：通过接口交互，易于替换策略
- **可测试**：函数可独立测试

### 4.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **精度 vs 内存** | 8位计数 | 平衡内存占用和频率范围 |
| **精度 vs 复杂度** | 对数计数 | 8位可表示百万级频率 |
| **准确性 vs 适应性** | 时间衰减 | 防止旧热点永久占用 |
| **性能 vs 准确性** | 采样淘汰 | 平衡性能和命中率 |

**权衡公式**：

$$C_{total} = C_{memory} + C_{cpu} + C_{accuracy\_loss} + C_{adaptability}$$

其中：

- $C_{memory}$：内存成本（8位计数）
- $C_{cpu}$：CPU成本（对数计算、采样）
- $C_{accuracy\_loss}$：准确性损失（对数计数误差）
- $C_{adaptability}$：适应性成本（时间衰减）

### 4.4 可扩展性分析

**扩展点**：

1. **计数算法**：可扩展为其他计数算法（线性、指数等）
2. **衰减策略**：可扩展为其他衰减策略（指数衰减、分段衰减等）
3. **采样策略**：可扩展为加权采样、分层采样

**扩展性设计**：

```c
// 可扩展的计数接口
typedef uint8_t (*count_func)(robj *o, int access_count);

// 可扩展的衰减接口
typedef uint8_t (*decay_func)(robj *o, unsigned long elapsed_time);

// 可扩展的分数计算接口
typedef double (*score_func)(robj *o);
```

**可维护性**：

- **代码清晰**：函数职责单一，易于理解
- **配置灵活**：通过配置参数调整行为
- **测试友好**：函数可独立测试

## 5. 配置参数

### 5.1 关键配置

**配置参数**：

```conf
# redis.conf

# LFU淘汰策略
maxmemory-policy allkeys-lfu  # 或 volatile-lfu

# LFU对数因子（默认10）
lfu-log-factor 10

# LFU衰减时间（默认1分钟）
lfu-decay-time 1

# 采样数量（默认5）
maxmemory-samples 5
```

### 5.2 参数调优

**lfu-log-factor调优**：

$$P(counter) = \frac{1}{baseval \times factor + 1}$$

- **factor=5**：计数增长快，适合快速识别热点
- **factor=10**：默认值，平衡性能和准确性
- **factor=20**：计数增长慢，适合长期热点

**lfu-decay-time调优**：

$$counter_{new} = counter_{old} - \lfloor\frac{T_{elapsed}}{T_{decay}}\rfloor$$

- **decay-time=1**：快速衰减，快速适应变化
- **decay-time=60**：慢速衰减，保留长期热点

## 6. 性能分析

### 6.1 时间复杂度

**复杂度分析**：

- **更新计数**：$O(1)$（对数计算、随机数生成）
- **计算分数**：$O(1)$（时间衰减计算）
- **淘汰选择**：$O(K)$，$K$为采样数量（默认5）

**总复杂度**：

$$T_{total} = T_{update} + T_{evict} = O(1) + O(K) = O(K)$$

### 6.2 命中率对比

**命中率对比**：

| 场景 | LRU命中率 | LFU命中率 | 提升 |
|------|-----------|-----------|------|
| **热点数据** | 85% | 95% | +10% |
| **频率局部性** | 70% | 90% | +20% |
| **时间局部性** | 90% | 85% | -5% |

**命中率公式**：

$$H_{LFU} = H_{LRU} + \Delta H_{frequency}$$

其中$\Delta H_{frequency}$为频率局部性带来的提升。

## 7. 适用场景

### 7.1 优势场景

**适用场景**：

1. **热点数据场景**：有明显频率局部性
2. **内容推荐**：热门内容访问频率高
3. **广告系统**：热门广告点击率高

### 7.2 不适用场景

**不适用场景**：

1. **时间局部性场景**：访问模式随时间变化，LRU更合适
2. **新数据场景**：新数据可能立即被淘汰，需要预热

## 8. 扩展阅读

- [LFU算法原理与实现](../../01-理论基础/01.01-基础替换算法/01.01.02-LFU算法原理与实现.md)
- [近似LRU算法](./05.05.01-近似LRU算法.md)
- [Random采样淘汰算法](./05.05.03-Random采样淘汰算法.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 9. 权威参考

### 9.1 学术论文

1. **"An O(1) algorithm for implementing the LFU cache eviction scheme"** - Shah et al., 2010
   - O(1) LFU算法实现

2. **"TinyLFU: A Highly Efficient Cache Admission Policy"** - Eran et al., 2017
   - TinyLFU算法，LFU的改进版本

### 9.2 官方文档

1. **Redis源码** - GitHub
   - URL: <https://github.com/redis/redis>
   - 文件：`evict.c`、`object.c`

2. **Redis内存淘汰策略** - Redis官方文档
   - URL: <https://redis.io/docs/manual/eviction/>

### 9.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-45342-0
   - 深入讲解Redis LFU实现

2. **《算法导论》** - Thomas H. Cormen等
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-40701-0
   - 缓存替换算法理论基础

### 9.4 在线资源

1. **LFU算法详解** - 掘金
   - URL: <https://juejin.cn/>
   - LFU算法实现分析

2. **Redis LFU实现分析** - 博客园
   - URL: <https://www.cnblogs.com/>
   - Redis LFU源码分析
