# 05.05.03 Random采样淘汰算法

## 概述

Random采样淘汰是Redis内存回收的重要策略，通过随机采样多个key，选择其中一个进行淘汰。理解Random采样淘汰算法对于优化Redis内存管理至关重要。

## Random采样原理

### 基本思想

```c
// Random采样淘汰基本思想
// 1. 随机采样N个key
// 2. 根据策略选择其中一个淘汰
// 3. 时间复杂度：O(N)，N通常为5-20

// 采样策略
typedef enum {
    MAXMEMORY_ALLKEYS_RANDOM,    // 所有key中随机
    MAXMEMORY_VOLATILE_RANDOM,   // 有过期时间的key中随机
} maxmemory_policy_t;
```

### 工作流程

```
内存不足时：
1. 随机采样N个key（默认5个）
2. 根据策略选择淘汰目标
3. 淘汰选中的key
4. 释放内存
```

## Redis实现

### 1. 采样实现

```c
// Redis随机采样实现
dictEntry *dictGetRandomKey(dict *d) {
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;

    // 随机选择哈希桶
    do {
        h = random() & d->ht[0].sizemask;
        he = d->ht[0].table[h];
    } while(he == NULL);

    // 随机选择链表中的元素
    listlen = 0;
    orighe = he;
    while(he) {
        he = he->next;
        listlen++;
    }
    listele = random() % listlen;
    he = orighe;
    while(listele--) he = he->next;

    return he;
}
```

### 2. 淘汰实现

```c
// Random淘汰实现
int freeMemoryIfNeeded(void) {
    // ...

    if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||
        server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM) {

        // 采样多个key
        for (int k = 0; k < server.maxmemory_samples; k++) {
            dictEntry *de = dictGetRandomKey(sampledict);
            evictionPoolEntry *pool = EvictionPoolLRU;

            // 添加到淘汰池
            if (poolAdd(pool, de)) {
                // 池满，选择最差的淘汰
                break;
            }
        }

        // 从淘汰池中选择最差的淘汰
        evictionPoolEntry *victim = poolSelect(pool);
        if (victim) {
            return freeMemoryByEvictingKey(victim->key);
        }
    }

    // ...
}
```

## 采样数量优化

### 1. 采样数量影响

```python
# 采样数量对性能的影响
class SamplingSizeImpact:
    def analyze(self):
        return {
            'small_samples': {
                'count': 5,
                'performance': '快',
                'accuracy': '低',
            },
            'medium_samples': {
                'count': 10,
                'performance': '中',
                'accuracy': '中',
            },
            'large_samples': {
                'count': 20,
                'performance': '慢',
                'accuracy': '高',
            },
        }
```

### 2. 推荐采样数

```conf
# redis.conf
# 采样数量配置
maxmemory-samples 5

# 推荐值：
# - 小数据集（<1GB）：5
# - 中等数据集（1-10GB）：10
# - 大数据集（>10GB）：20
```

## 性能分析

### 1. 时间复杂度

```python
# Random采样淘汰时间复杂度
class RandomEvictionComplexity:
    def analyze(self):
        return {
            'sampling': 'O(N)',  # N为采样数
            'selection': 'O(1)',
            'eviction': 'O(1)',
            'total': 'O(N)',
        }
```

### 2. 命中率

```python
# Random采样淘汰命中率
class RandomEvictionHitRate:
    def compare(self, samples):
        """对比不同采样数的命中率"""
        return {
            5: '90%',   # 采样5个
            10: '95%',  # 采样10个
            20: '98%',  # 采样20个
        }
```

## 与其他策略对比

### Random vs LRU

| 维度 | Random | LRU |
|------|--------|-----|
| **时间复杂度** | O(N) | O(1) |
| **内存开销** | 低 | 中 |
| **命中率** | 低 | 高 |
| **适用场景** | 随机访问 | 时间局部性 |

### Random vs LFU

| 维度 | Random | LFU |
|------|--------|-----|
| **时间复杂度** | O(N) | O(logN) |
| **内存开销** | 低 | 高 |
| **命中率** | 低 | 高 |
| **适用场景** | 随机访问 | 频率局部性 |

## 扩展阅读

- [Random随机替换算法](../../01-理论基础/01.01-基础替换算法/01.01.05-Random随机替换算法.md)
- [近似LRU算法](./05.05.01-近似LRU算法.md)
- [LFU算法实现](./05.05.02-LFU算法实现.md)

## 权威参考

- **Redis源码** - <https://github.com/redis/redis>
- **《Redis设计与实现》** - 黄健宏著
- **Redis官方文档** - <https://redis.io/docs/manual/eviction/>
