# 05.05.03 Random采样淘汰算法

## 目录

- [05.05.03 Random采样淘汰算法](#050503-random采样淘汰算法)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. Random采样原理](#2-random采样原理)
    - [2.1 基本思想](#21-基本思想)
    - [2.2 工作流程](#22-工作流程)
    - [2.3 采样模型](#23-采样模型)
  - [3. Redis实现](#3-redis实现)
    - [3.1 采样算法实现](#31-采样算法实现)
    - [3.2 淘汰策略实现](#32-淘汰策略实现)
    - [3.3 随机数生成](#33-随机数生成)
  - [4. 程序设计分析](#4-程序设计分析)
    - [4.1 设计模式应用](#41-设计模式应用)
    - [4.2 代码结构分析](#42-代码结构分析)
    - [4.3 设计权衡](#43-设计权衡)
    - [4.4 可扩展性分析](#44-可扩展性分析)
  - [5. 采样数量优化](#5-采样数量优化)
    - [5.1 采样数量影响](#51-采样数量影响)
    - [5.2 推荐采样数](#52-推荐采样数)
  - [6. 性能分析](#6-性能分析)
    - [6.1 时间复杂度](#61-时间复杂度)
    - [6.2 命中率](#62-命中率)
  - [7. 与其他策略对比](#7-与其他策略对比)
    - [7.1 Random vs LRU](#71-random-vs-lru)
    - [7.2 Random vs LFU](#72-random-vs-lfu)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 学术论文](#91-学术论文)
    - [9.2 官方文档](#92-官方文档)
    - [9.3 经典书籍](#93-经典书籍)
    - [9.4 在线资源](#94-在线资源)

---

## 1. 概述

### 1.1 定义与背景

**Random采样淘汰算法**是Redis内存回收的重要策略，通过随机采样多个key，选择其中一个进行淘汰。理解Random采样淘汰算法对于优化Redis内存管理至关重要。

**核心设计思想**：

- **随机采样**：随机选择key进行淘汰
- **简单高效**：实现简单，性能好
- **无状态**：不需要维护额外状态

### 1.2 应用价值

Random采样淘汰的价值：

1. **简单高效**：实现简单，O(K)复杂度
2. **无状态**：不需要维护时间戳或频率
3. **适用场景**：适合随机访问模式

## 2. Random采样原理

### 2.1 基本思想

**Random采样淘汰基本思想**：

```c
// 采样策略
typedef enum {
    MAXMEMORY_ALLKEYS_RANDOM,    // 所有key中随机
    MAXMEMORY_VOLATILE_RANDOM,   // 有过期时间的key中随机
} maxmemory_policy_t;
```

**算法流程**：

1. 随机采样N个key（默认5个）
2. 根据策略选择淘汰目标
3. 淘汰选中的key
4. 释放内存

### 2.2 工作流程

**工作流程**：

```text
内存不足时：
1. 随机采样N个key（默认5个）
2. 根据策略选择淘汰目标
3. 淘汰选中的key
4. 释放内存
```

### 2.3 采样模型

**采样概率模型**：

$$P(key_i \text{被选中}) = \frac{1}{N}$$

其中$N$为总key数。

**采样K个key的期望**：

$$E[\text{选中特定key}] = \frac{K}{N}$$

## 3. Redis实现

### 3.1 采样算法实现

**随机采样实现**：

```c
dictEntry *dictGetRandomKey(dict *d) {
    dictEntry *he, *orighe;
    unsigned long h;
    int listlen, listele;

    if (dictSize(d) == 0) return NULL;

    // 随机选择哈希桶
    do {
        h = random() & d->ht[0].sizemask;
        he = d->ht[0].table[h];
    } while(he == NULL);

    // 随机选择链表中的元素
    listlen = 0;
    orighe = he;
    while(he) {
        he = he->next;
        listlen++;
    }
    listele = random() % listlen;
    he = orighe;
    while(listele--) he = he->next;

    return he;
}
```

**采样复杂度**：

- **时间复杂度**：$O(L)$，$L$为链表平均长度
- **空间复杂度**：$O(1)$

### 3.2 淘汰策略实现

**Random淘汰实现**：

```c
int freeMemoryIfNeeded(void) {
    if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||
        server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM) {

        // 采样多个key
        for (int k = 0; k < server.maxmemory_samples; k++) {
            dictEntry *de = dictGetRandomKey(sampledict);
            evictionPoolEntry *pool = EvictionPoolLRU;

            // 添加到淘汰池
            if (poolAdd(pool, de)) {
                break;  // 池满
            }
        }

        // 从淘汰池中选择最差的淘汰
        evictionPoolEntry *victim = poolSelect(pool);
        if (victim) {
            return freeMemoryByEvictingKey(victim->key);
        }
    }
}
```

**淘汰复杂度**：

- **时间复杂度**：$O(K)$，$K$为采样数量
- **空间复杂度**：$O(K)$，淘汰池大小

### 3.3 随机数生成

**随机数生成**：

$$h = random() \& sizemask$$

其中$sizemask = size - 1$（$size$为2的幂次方）。

**均匀分布保证**：

$$P(h = i) = \frac{1}{size}$$

## 4. 程序设计分析

### 4.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：通过`maxmemory_policy`选择Random策略
2. **模板方法模式**：`freeMemoryIfNeeded()`定义淘汰框架
3. **工厂模式**：`dictGetRandomKey()`工厂方法生成随机key

**策略模式实现**：

```c
// 策略选择
if (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) {
    // Random策略实现
    de = dictGetRandomKey(sampledict);
} else if (server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM) {
    // Volatile Random策略实现
    sampledict = server.db[dbid].expires;
    de = dictGetRandomKey(sampledict);
}
```

### 4.2 代码结构分析

**代码组织**：

1. **采样层**：`dictGetRandomKey()`实现随机采样
2. **策略层**：`freeMemoryIfNeeded()`实现淘汰策略
3. **工具层**：随机数生成、链表遍历

**模块化设计**：

- **高内聚**：Random相关功能集中管理
- **低耦合**：通过接口交互，易于替换
- **可测试**：函数可独立测试

### 4.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **简单 vs 准确** | 简单随机 | 实现简单，性能好 |
| **采样数 vs 性能** | 5个采样 | 平衡性能和准确性 |
| **无状态 vs 有状态** | 无状态 | 不需要维护额外状态 |

**权衡公式**：

$$C_{total} = C_{simplicity} + C_{performance} + C_{accuracy\_loss}$$

其中：

- $C_{simplicity}$：简单性成本（低）
- $C_{performance}$：性能成本（O(K)）
- $C_{accuracy\_loss}$：准确性损失（随机性）

### 4.4 可扩展性分析

**扩展点**：

1. **采样策略**：可扩展为加权采样、分层采样
2. **淘汰策略**：可扩展为混合策略
3. **随机数生成**：可扩展为更好的随机数生成器

**扩展性设计**：

```c
// 可扩展的采样接口
typedef dictEntry* (*sample_func)(dict *d, int count);

// 可扩展的淘汰接口
typedef int (*evict_func)(dict *d, sample_func sample);
```

**可维护性**：

- **代码清晰**：算法逻辑清晰
- **易于调试**：随机采样易于测试
- **测试友好**：函数可独立测试

## 5. 采样数量优化

### 5.1 采样数量影响

**采样数量对性能的影响**：

| 采样数量 | 性能 | 准确性 |
|---------|------|--------|
| **5** | 快 | 低 |
| **10** | 中 | 中 |
| **20** | 慢 | 高 |

**性能公式**：

$$T_{evict} = K \times T_{sample}$$

其中$T_{sample}$为单次采样时间。

### 5.2 推荐采样数

**推荐配置**：

```conf
# redis.conf
maxmemory-samples 5

# 推荐值：
# - 小数据集（<1GB）：5
# - 中等数据集（1-10GB）：10
# - 大数据集（>10GB）：20
```

**采样数选择公式**：

$$K_{optimal} = \max(5, \min(20, \log_2(N)))$$

其中$N$为总key数。

## 6. 性能分析

### 6.1 时间复杂度

**复杂度分析**：

- **采样**：$O(K \times L)$，$K$为采样数，$L$为链表平均长度
- **选择**：$O(1)$
- **淘汰**：$O(1)$
- **总计**：$O(K \times L)$

**平均复杂度**：

$$T_{avg} = K \times \bar{L} = K \times \frac{N}{size}$$

其中$\bar{L}$为链表平均长度。

### 6.2 命中率

**命中率分析**：

| 采样数量 | 命中率 |
|---------|--------|
| **5** | ~90% |
| **10** | ~95% |
| **20** | ~98% |

**命中率公式**：

$$H_{random} = 1 - \left(\frac{N-K}{N}\right)^K$$

## 7. 与其他策略对比

### 7.1 Random vs LRU

**对比分析**：

| 维度 | Random | LRU |
|------|--------|-----|
| **时间复杂度** | O(K) | O(1) |
| **内存开销** | 低 | 中 |
| **命中率** | 低 | 高 |
| **适用场景** | 随机访问 | 时间局部性 |

### 7.2 Random vs LFU

**对比分析**：

| 维度 | Random | LFU |
|------|--------|-----|
| **时间复杂度** | O(K) | O(K) |
| **内存开销** | 低 | 高 |
| **命中率** | 低 | 高 |
| **适用场景** | 随机访问 | 频率局部性 |

## 8. 扩展阅读

- [Random随机替换算法](../../01-理论基础/01.01-基础替换算法/01.01.05-Random随机替换算法.md)
- [近似LRU算法](./05.05.01-近似LRU算法.md)
- [LFU算法实现](./05.05.02-LFU算法实现.md)
- [Redis内存管理](../../03-Redis组件/03.04-内存管理/README.md)

## 9. 权威参考

### 9.1 学术论文

1. **"Random Sampling Algorithms"** - ACM Computing Surveys, 1995
   - 随机采样算法综述

2. **"Cache Replacement Policies"** - IEEE Computer, 2000
   - 缓存替换策略对比

### 9.2 官方文档

1. **Redis源码** - GitHub
   - URL: <https://github.com/redis/redis>
   - 文件：`evict.c`、`dict.c`

2. **Redis内存淘汰策略** - Redis官方文档
   - URL: <https://redis.io/docs/manual/eviction/>

### 9.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-45342-0
   - Redis Random淘汰实现

2. **《算法导论》** - Thomas H. Cormen等
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-40701-0
   - 随机采样算法

### 9.4 在线资源

1. **随机采样算法** - Wikipedia
   - URL: <https://en.wikipedia.org/wiki/Random_sampling>

2. **Redis内存淘汰机制** - 掘金
   - URL: <https://juejin.cn/>
