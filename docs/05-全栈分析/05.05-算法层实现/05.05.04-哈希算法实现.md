# 05.05.04 哈希算法实现

## 目录

- [05.05.04 哈希算法实现](#050504-哈希算法实现)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. Redis哈希算法](#2-redis哈希算法)
    - [2.1 MurmurHash2算法](#21-murmurhash2算法)
    - [2.2 SipHash算法](#22-siphash算法)
    - [2.3 CRC64算法](#23-crc64算法)
  - [3. 哈希表应用](#3-哈希表应用)
    - [3.1 dict哈希表](#31-dict哈希表)
    - [3.2 一致性哈希](#32-一致性哈希)
  - [4. 程序设计分析](#4-程序设计分析)
    - [4.1 设计模式应用](#41-设计模式应用)
    - [4.2 代码结构分析](#42-代码结构分析)
    - [4.3 设计权衡](#43-设计权衡)
    - [4.4 可扩展性分析](#44-可扩展性分析)
  - [5. 性能优化](#5-性能优化)
  - [6. 性能测试](#6-性能测试)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)

---

## 1. 概述

### 1.1 定义与背景

**哈希算法**是Redis数据结构和分布式系统的核心，用于快速定位数据、实现一致性哈希、计算数据指纹等。理解Redis中的哈希算法实现对于优化性能和保证数据分布至关重要。

**哈希算法应用**：

- **数据定位**：快速定位key-value对
- **一致性哈希**：分布式系统中的数据分片
- **数据指纹**：计算数据校验和

### 1.2 应用价值

哈希算法的价值：

1. **性能优化**：O(1)平均查找时间
2. **数据分布**：保证数据均匀分布
3. **安全性**：防止Hash DoS攻击

## 2. Redis哈希算法

### 2.1 MurmurHash2算法

**MurmurHash2实现**：

```c
uint32_t MurmurHash2(const void *key, int len, uint32_t seed) {
    const uint32_t m = 0x5bd1e995;
    const int r = 24;
    uint32_t h = seed ^ len;

    const unsigned char *data = (const unsigned char *)key;

    while (len >= 4) {
        uint32_t k = *(uint32_t *)data;

        k *= m;
        k ^= k >> r;
        k *= m;

        h *= m;
        h ^= k;

        data += 4;
        len -= 4;
    }

    switch(len) {
        case 3: h ^= data[2] << 16;
        case 2: h ^= data[1] << 8;
        case 1: h ^= data[0];
                h *= m;
    }

    h ^= h >> 13;
    h *= m;
    h ^= h >> 15;

    return h;
}
```

**算法复杂度**：

- **时间复杂度**：$O(n)$，$n$为key长度
- **空间复杂度**：$O(1)$

**哈希函数性质**：

1. **确定性**：相同输入产生相同输出
2. **均匀分布**：输出均匀分布在哈希空间
3. **雪崩效应**：输入微小变化导致输出巨大变化

### 2.2 SipHash算法

**SipHash实现**：

```c
uint64_t siphash(const uint8_t *in, const size_t inlen,
                 const uint8_t *k) {
    // SipHash实现
    // 用于计算字符串哈希值
    // 防止Hash DoS攻击
}
```

**SipHash优势**：

- **安全性**：防止Hash DoS攻击
- **性能**：性能接近MurmurHash2
- **密钥化**：使用密钥，防止攻击

**Hash DoS防护**：

$$P_{collision} = \frac{1}{2^{64}}$$

使用64位哈希值，碰撞概率极低。

### 2.3 CRC64算法

**CRC64实现**：

```c
uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {
    // CRC64实现
    // 用于计算校验和
    // 用于AOF校验等场景
}
```

**CRC64应用**：

- **数据校验**：AOF文件校验
- **错误检测**：数据传输错误检测
- **数据指纹**：计算数据指纹

## 3. 哈希表应用

### 3.1 dict哈希表

**dict使用MurmurHash2**：

```c
unsigned int dictGenHashFunction(const void *key, int len) {
    return MurmurHash2(key, len, dict_hash_function_seed);
}
```

**哈希表查找**：

```c
dictEntry *dictFind(dict *d, const void *key) {
    // 计算哈希值
    h = dictHashKey(d, key);

    // 在两个表中查找
    for (table = 0; table <= 1; table++) {
        idx = h & d->ht[table].sizemask;
        he = d->ht[table].table[idx];

        while(he) {
            if (key==he->key || dictCompareKeys(d, key, he->key))
                return he;
            he = he->next;
        }

        if (!dictIsRehashing(d)) break;
    }

    return NULL;
}
```

**查找复杂度**：

- **平均情况**：$O(1)$
- **最坏情况**：$O(n)$（所有key哈希冲突）

### 3.2 一致性哈希

**CRC16计算slot**：

```c
unsigned int keyHashSlot(char *key, int keylen) {
    // 查找{...}中的内容
    for (s = 0; s < keylen; s++)
        if (key[s] == '{') break;

    if (s == keylen) return crc16(key, keylen) & 0x3FFF;

    for (e = s+1; e < keylen; e++)
        if (key[e] == '}') break;

    if (e == keylen || e == s+1) return crc16(key, keylen) & 0x3FFF;

    return crc16(key+s+1, e-s-1) & 0x3FFF;
}
```

**Slot计算**：

$$slot = crc16(key) \bmod 16384$$

其中16384为Redis Cluster的slot数量。

## 4. 程序设计分析

### 4.1 设计模式应用

**使用的设计模式**：

1. **策略模式**：不同场景使用不同哈希算法
2. **工厂模式**：`dictGenHashFunction()`工厂方法生成哈希值
3. **模板方法模式**：定义哈希计算框架

**策略模式实现**：

```c
// 策略选择
if (use_siphash) {
    hash = siphash(key, len, secret_key);
} else {
    hash = MurmurHash2(key, len, seed);
}
```

### 4.2 代码结构分析

**代码组织**：

1. **算法层**：MurmurHash2、SipHash、CRC64实现
2. **应用层**：dict、一致性哈希应用
3. **工具层**：哈希函数选择、冲突处理

**模块化设计**：

- **高内聚**：哈希相关功能集中管理
- **低耦合**：通过接口交互，易于替换
- **可测试**：函数可独立测试

### 4.3 设计权衡

**设计权衡分析**：

| 权衡维度 | 选择 | 原因 |
|---------|------|------|
| **性能 vs 安全** | MurmurHash2/SipHash | 平衡性能和安全性 |
| **速度 vs 准确性** | MurmurHash2 | 速度快，分布均匀 |
| **通用 vs 专用** | 多种算法 | 不同场景使用不同算法 |

**权衡公式**：

$$C_{total} = C_{performance} + C_{security} + C_{maintainability}$$

其中：

- $C_{performance}$：性能成本（MurmurHash2快）
- $C_{security}$：安全成本（SipHash安全）
- $C_{maintainability}$：可维护性成本（多种算法）

### 4.4 可扩展性分析

**扩展点**：

1. **新哈希算法**：易于添加新哈希算法
2. **哈希策略**：可配置哈希算法选择
3. **冲突处理**：可扩展为其他冲突处理策略

**扩展性设计**：

```c
// 可扩展的哈希接口
typedef uint32_t (*hash_func)(const void *key, int len, uint32_t seed);

// 可扩展的哈希策略
typedef struct hash_strategy {
    hash_func hash_function;
    const char *name;
} hash_strategy_t;
```

**可维护性**：

- **代码清晰**：算法实现清晰
- **易于调试**：哈希值易于验证
- **测试友好**：函数可独立测试

## 5. 性能优化

### 5.1 哈希函数选择

**哈希函数选择**：

| 算法 | 速度 | 分布 | 安全性 | 适用场景 |
|------|------|------|--------|----------|
| **MurmurHash2** | 快 | 均匀 | 中 | 通用哈希表 |
| **SipHash** | 中 | 均匀 | 高 | 防止DoS攻击 |
| **CRC64** | 快 | 一般 | 低 | 校验和 |

**选择公式**：

$$H_{choice} = \begin{cases}
\text{MurmurHash2} & \text{if } S_{security} < \theta \\
\text{SipHash} & \text{if } S_{security} \geq \theta
\end{cases}$$

其中$\theta$为安全阈值。

### 5.2 哈希表大小优化

**哈希表大小优化**：

$$size = 2^k$$

其中$k$满足$2^k \geq N \times \alpha$，$N$为key数量，$\alpha$为负载因子（0.75）。

**负载因子控制**：

$$\rho = \frac{N}{size} \leq 0.75$$

当$\rho > 0.75$时，触发Rehash。

### 5.3 哈希冲突处理

**链地址法**：

$$T_{lookup} = O(1 + \alpha)$$

其中$\alpha$为负载因子。

**冲突概率**：

$$P_{collision} = 1 - \frac{N!}{(N-k)! \times N^k}$$

其中$k$为key数量，$N$为哈希表大小。

## 6. 性能测试

### 6.1 哈希函数性能

**性能测试**：

| 算法 | 速度（M ops/s） |
|------|----------------|
| **MurmurHash2** | ~500 |
| **SipHash** | ~300 |
| **CRC64** | ~800 |
| **djb hash** | ~600 |

**性能公式**：

$$T_{hash} = \frac{L}{BW_{cpu}}$$

其中$L$为key长度，$BW_{cpu}$为CPU带宽。

### 6.2 分布均匀性测试

**分布均匀性**：

$$\sigma^2 = \frac{1}{N}\sum_{i=1}^{N}(x_i - \bar{x})^2$$

其中$x_i$为第$i$个桶的元素数，$\bar{x}$为平均值。

**均匀性指标**：

$$U = 1 - \frac{\sigma}{\bar{x}}$$

理想情况下，$U = 1$（完全均匀）。

## 7. 扩展阅读

- [哈希表dict实现](../../03-Redis组件/03.01-核心数据结构/03.01.02-哈希表dict实现.md)
- [一致性哈希原理](../../01-理论基础/01.03-分布式缓存算法/01.03.01-一致性哈希原理.md)
- [Cluster集群模式](../../03-Redis组件/03.03-高可用架构/03.03.03-Cluster集群模式.md)

## 8. 权威参考

### 8.1 学术论文

1. **"MurmurHash: An Extremely Fast Non-Cryptographic Hash Function"** - Austin Appleby, 2008
   - MurmurHash算法原始论文

2. **"SipHash: A Fast Short-Input PRF"** - Jean-Philippe Aumasson & Daniel J. Bernstein, 2012
   - SipHash算法原始论文

### 8.2 官方文档

1. **Redis源码** - GitHub
   - URL: <https://github.com/redis/redis>
   - 文件：`dict.c`、`crc64.c`

2. **MurmurHash官方** - GitHub
   - URL: <https://github.com/aappleby/smhasher>

### 8.3 经典书籍

1. **《Redis设计与实现》** - 黄健宏
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-45342-0
   - Redis哈希算法实现

2. **《算法导论》** - Thomas H. Cormen等
   - 出版社: 机械工业出版社
   - ISBN: 978-7-111-40701-0
   - 哈希表算法

### 8.4 在线资源

1. **MurmurHash算法** - Wikipedia
   - URL: <https://en.wikipedia.org/wiki/MurmurHash>

2. **SipHash算法** - GitHub
   - URL: <https://github.com/veorq/SipHash>
