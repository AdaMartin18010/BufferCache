# 05.06.01 延迟分布建模

## 概述

延迟分布是Redis性能分析的核心指标。理解延迟分布的特征、来源和优化方法，对于诊断性能问题和优化系统至关重要。

## 延迟分布特征

### 典型分布

```
延迟分布（P50/P95/P99）：
P50（中位数）：1ms
P95：5ms
P99：10ms
P99.9：50ms
P99.99：100ms
```

### 分布形状

```
延迟分布通常呈现：
- 长尾分布（Long Tail）
- 右偏分布（Right Skewed）
- 多峰分布（Multi-modal）
```

## 延迟来源分析

### 1. 网络延迟

```python
# 网络延迟分解
network_latency = propagation_delay + transmission_delay + queuing_delay

# propagation_delay：传播延迟
# = distance / speed_of_light
# 本地：~0.1ms
# 跨机房：~10ms

# transmission_delay：传输延迟
# = packet_size / bandwidth
# 1KB @ 1Gbps：~0.01ms

# queuing_delay：排队延迟
# = queue_length / service_rate
# 取决于网络拥塞程度
```

### 2. 内核延迟

```python
# 内核延迟分解
kernel_latency = syscall_overhead + context_switch + interrupt_handling

# syscall_overhead：系统调用开销
# ~0.1-1μs

# context_switch：上下文切换
# ~1-10μs

# interrupt_handling：中断处理
# ~1-10μs
```

### 3. Redis延迟

```python
# Redis延迟分解
redis_latency = command_parsing + command_execution + response_building

# command_parsing：命令解析
# ~0.01-0.1ms

# command_execution：命令执行
# 简单命令：~0.01-0.1ms
# 复杂命令：~1-10ms

# response_building：响应构建
# ~0.01-0.1ms
```

### 4. 抖动延迟

```python
# 抖动来源
jitter = gc_pause + page_fault + cache_miss + lock_contention

# gc_pause：GC暂停（如果使用）
# ~1-10ms

# page_fault：页错误
# ~0.1-1ms

# cache_miss：缓存未命中
# ~0.1-1ms

# lock_contention：锁竞争
# ~0.1-10ms
```

## 延迟分布模型

### 1. 正态分布模型

```python
# 假设延迟服从正态分布
# P(x) = (1 / (σ * √(2π))) * e^(-(x-μ)²/(2σ²))

# μ：平均延迟
# σ：标准差

# 问题：实际延迟分布通常不是正态分布
```

### 2. 指数分布模型

```python
# 假设延迟服从指数分布
# P(x) = λ * e^(-λx)

# λ：速率参数

# 适用：简单场景
```

### 3. 威布尔分布模型

```python
# 威布尔分布（更符合实际）
# P(x) = (k/λ) * (x/λ)^(k-1) * e^(-(x/λ)^k)

# k：形状参数
# λ：尺度参数

# 优势：可以建模长尾分布
```

### 4. 混合分布模型

```python
# 混合分布（多峰分布）
# P(x) = w1 * P1(x) + w2 * P2(x) + ...

# w1, w2, ...：权重
# P1, P2, ...：子分布

# 适用：复杂场景
```

## Redis延迟分析

### 延迟分解

```c
// Redis延迟分解
total_latency = network_latency +
                kernel_latency +
                redis_latency +
                jitter

// 典型值：
// network_latency: 0.1-1ms（本地）或10-100ms（远程）
// kernel_latency: 0.01-0.1ms
// redis_latency: 0.01-10ms（取决于命令）
// jitter: 0.1-10ms（取决于系统负载）
```

### 延迟监控

```python
# Redis延迟监控
import redis
import time

class LatencyMonitor:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.latencies = []

    def measure_latency(self, command, *args):
        start = time.time()
        result = getattr(self.redis, command)(*args)
        latency = (time.time() - start) * 1000  # 转换为毫秒
        self.latencies.append(latency)
        return result

    def get_statistics(self):
        if not self.latencies:
            return None

        sorted_latencies = sorted(self.latencies)
        n = len(sorted_latencies)

        return {
            'p50': sorted_latencies[int(n * 0.50)],
            'p95': sorted_latencies[int(n * 0.95)],
            'p99': sorted_latencies[int(n * 0.99)],
            'p99.9': sorted_latencies[int(n * 0.999)],
            'mean': sum(self.latencies) / n,
            'max': max(self.latencies),
            'min': min(self.latencies)
        }
```

## 延迟优化

### 1. 网络优化

```python
# 1. 使用本地连接
# 2. 减少网络跳数
# 3. 使用高速网络（10Gbps+）
# 4. 优化TCP参数
```

### 2. 内核优化

```python
# 1. 减少系统调用
# 2. 使用epoll而非select
# 3. 优化中断处理
# 4. 使用CPU亲和性
```

### 3. Redis优化

```python
# 1. 使用Pipeline减少网络往返
# 2. 使用批量操作
# 3. 避免大Key操作
# 4. 优化命令选择
```

### 4. 系统优化

```python
# 1. 禁用透明大页
# 2. 优化内存分配
# 3. 减少GC暂停
# 4. 优化锁竞争
```

## 延迟SLA

### SLA定义

```python
# 延迟SLA示例
latency_sla = {
    'p50': 1,      # 50%请求 < 1ms
    'p95': 5,      # 95%请求 < 5ms
    'p99': 10,     # 99%请求 < 10ms
    'p99.9': 50,   # 99.9%请求 < 50ms
    'p99.99': 100  # 99.99%请求 < 100ms
}
```

### SLA监控

```python
# SLA监控与告警
class SLAMonitor:
    def __init__(self, latency_monitor, sla):
        self.latency_monitor = latency_monitor
        self.sla = sla

    def check_sla(self):
        stats = self.latency_monitor.get_statistics()

        violations = []
        for percentile, threshold in self.sla.items():
            if stats[percentile] > threshold:
                violations.append({
                    'percentile': percentile,
                    'actual': stats[percentile],
                    'threshold': threshold
                })

        if violations:
            send_alert(f"SLA violation: {violations}")

        return len(violations) == 0
```

## 扩展阅读

- [Little定律应用](./05.06.02-Little定律应用.md)
- [抖动来源分析](./05.06.04-抖动来源分析.md)
- [请求-响应数据流](../05.04-数据流分析/05.04.01-请求-响应数据流.md)

## 权威参考

- **《性能之巅》** - Brendan Gregg
- **《系统性能调优》** - Linux内核文档
- **Redis官方文档** - <https://redis.io/docs/manual/optimization/>
