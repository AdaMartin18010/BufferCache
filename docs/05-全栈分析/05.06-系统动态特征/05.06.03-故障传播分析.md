# 05.06.03 故障传播分析

## 概述

故障传播分析是系统可靠性工程的重要组成部分，通过分析故障在系统中的传播路径和影响范围，制定有效的故障隔离和恢复策略。

## 故障传播模型

### 传播路径

```
故障源 → 直接影响 → 间接影响 → 级联故障

示例：
主节点故障 → 从节点无法同步 → 客户端请求失败 → 业务中断
```

### 传播时间

```python
# 故障传播时间模型
class FaultPropagation:
    def __init__(self):
        self.propagation_delay = {
            'network': 0.1,      # 网络传播延迟（秒）
            'application': 0.01, # 应用层传播延迟
            'database': 0.1,    # 数据库传播延迟
        }

    def calculate_propagation_time(self, path):
        """计算故障传播时间"""
        total_time = 0
        for component in path:
            total_time += self.propagation_delay.get(component, 0)
        return total_time
```

## Redis故障场景

### 1. 主节点故障

```python
# 主节点故障传播分析
class MasterFailurePropagation:
    def analyze(self):
        # 故障源：主节点故障
        fault_source = "Master Node Failure"

        # 直接影响
        direct_impact = [
            "Write requests fail",
            "Master replication stops",
            "Memory usage stops updating",
        ]

        # 间接影响
        indirect_impact = [
            "Slaves cannot sync",
            "Clients cannot write",
            "Cache becomes stale",
        ]

        # 级联故障
        cascade_failure = [
            "Application errors",
            "Database overload",
            "Service unavailability",
        ]

        return {
            'source': fault_source,
            'direct': direct_impact,
            'indirect': indirect_impact,
            'cascade': cascade_failure,
        }
```

### 2. 网络分区

```python
# 网络分区故障传播分析
class NetworkPartitionPropagation:
    def analyze(self):
        # 故障源：网络分区
        fault_source = "Network Partition"

        # 分区场景
        scenarios = {
            'master_minority': {
                'impact': 'Master becomes unavailable',
                'propagation': ['Write fails', 'Slaves elect new master'],
            },
            'master_majority': {
                'impact': 'Minority slaves unavailable',
                'propagation': ['Read fails on minority', 'Data inconsistency'],
            },
        }

        return scenarios
```

### 3. 内存溢出

```python
# 内存溢出故障传播分析
class MemoryOverflowPropagation:
    def analyze(self):
        # 故障源：内存溢出
        fault_source = "Memory Overflow"

        # 传播路径
        propagation_path = [
            "Memory limit reached",
            "Eviction starts",
            "Cache hit rate drops",
            "Database load increases",
            "Application performance degrades",
        ]

        return {
            'source': fault_source,
            'path': propagation_path,
            'recovery_time': '5-10 minutes',
        }
```

## 故障隔离

### 1. 熔断器模式

```python
# 熔断器实现
class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout=60):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.failure_count = 0
        self.state = 'CLOSED'  # CLOSED, OPEN, HALF_OPEN
        self.last_failure_time = None

    def call(self, func, *args, **kwargs):
        if self.state == 'OPEN':
            if time.time() - self.last_failure_time > self.timeout:
                self.state = 'HALF_OPEN'
            else:
                raise CircuitBreakerOpen("Circuit breaker is OPEN")

        try:
            result = func(*args, **kwargs)
            if self.state == 'HALF_OPEN':
                self.state = 'CLOSED'
                self.failure_count = 0
            return result
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()

            if self.failure_count >= self.failure_threshold:
                self.state = 'OPEN'

            raise e
```

### 2. 超时控制

```python
# 超时控制
class TimeoutControl:
    def __init__(self, timeout=1.0):
        self.timeout = timeout

    def execute_with_timeout(self, func, *args, **kwargs):
        import signal

        def timeout_handler(signum, frame):
            raise TimeoutError("Operation timed out")

        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(int(self.timeout))

        try:
            result = func(*args, **kwargs)
            return result
        finally:
            signal.alarm(0)
```

### 3. 限流控制

```python
# 限流控制
class RateLimiter:
    def __init__(self, max_requests=100, window=60):
        self.max_requests = max_requests
        self.window = window
        self.requests = []

    def allow(self):
        now = time.time()
        # 清理过期请求
        self.requests = [r for r in self.requests if now - r < self.window]

        if len(self.requests) >= self.max_requests:
            return False

        self.requests.append(now)
        return True
```

## 故障恢复

### 1. 自动故障转移

```python
# 自动故障转移
class AutoFailover:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.sentinel = redis.sentinel.Sentinel([('localhost', 26379)])

    def get_master(self):
        """获取主节点"""
        try:
            master = self.sentinel.master_for('mymaster')
            return master
        except Exception as e:
            # 故障转移
            self.failover()
            return self.sentinel.master_for('mymaster')

    def failover(self):
        """执行故障转移"""
        # 1. 检测故障
        # 2. 选举新主节点
        # 3. 切换客户端连接
        pass
```

### 2. 数据恢复

```python
# 数据恢复策略
class DataRecovery:
    def __init__(self, redis_client):
        self.redis = redis_client

    def recover_from_rdb(self, rdb_file):
        """从RDB恢复"""
        # 1. 停止Redis
        # 2. 替换RDB文件
        # 3. 启动Redis
        pass

    def recover_from_aof(self, aof_file):
        """从AOF恢复"""
        # 1. 停止Redis
        # 2. 替换AOF文件
        # 3. 启动Redis
        pass
```

## 监控与告警

### 故障检测

```python
# 故障检测
class FaultDetection:
    def __init__(self, redis_client):
        self.redis = redis_client

    def check_health(self):
        """健康检查"""
        try:
            self.redis.ping()
            return True
        except Exception as e:
            return False

    def detect_faults(self):
        """检测故障"""
        faults = []

        # 检查连接
        if not self.check_health():
            faults.append("Connection failure")

        # 检查内存
        info = self.redis.info('memory')
        if info['used_memory'] > info['maxmemory'] * 0.9:
            faults.append("Memory high")

        return faults
```

## 扩展阅读

- [延迟分布建模](./05.06.01-延迟分布建模.md)
- [Little定律应用](./05.06.02-Little定律应用.md)
- [Sentinel哨兵机制](../../03-Redis组件/03.03-高可用架构/03.03.02-Sentinel哨兵机制.md)

## 权威参考

- **《系统可靠性工程》** - 可靠性工程经典教材
- **《分布式系统：概念与设计》** - 分布式系统经典教材
- **Redis Sentinel文档** - <https://redis.io/docs/manual/sentinel/>
