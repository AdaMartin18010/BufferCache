# 05.06.05 性能优化公式

## 概述

性能优化公式是量化分析系统性能的数学工具，用于指导优化决策、预测性能提升、评估优化效果。理解这些公式对于系统性能优化至关重要。

## 基础性能公式

### 1. 延迟公式

```
延迟 = 处理时间 + 等待时间 + 传输时间
```

```python
# 延迟分解
class LatencyFormula:
    def decompose(self):
        return {
            'processing_time': '处理时间',
            'waiting_time': '等待时间',
            'transmission_time': '传输时间',
        }
```

### 2. 吞吐量公式

```
吞吐量 = 请求数 / 时间
```

```python
# 吞吐量计算
class ThroughputFormula:
    def calculate(self, requests, time):
        return requests / time

    def max_throughput(self, latency):
        """最大吞吐量（单线程）"""
        return 1.0 / latency
```

### 3. 利用率公式

```
利用率 = 实际使用时间 / 总时间
```

```python
# 利用率计算
class UtilizationFormula:
    def calculate(self, busy_time, total_time):
        return busy_time / total_time

    def optimal_utilization(self):
        """最优利用率（通常70-80%）"""
        return 0.75
```

## Little定律

### 基本公式

```
L = λ × W
```

其中：

- L：系统中平均请求数
- λ：到达率（请求/秒）
- W：平均响应时间

```python
# Little定律应用
class LittlesLaw:
    def calculate(self, arrival_rate, response_time):
        """计算系统中平均请求数"""
        return arrival_rate * response_time

    def response_time(self, queue_length, arrival_rate):
        """计算平均响应时间"""
        return queue_length / arrival_rate

    def arrival_rate(self, queue_length, response_time):
        """计算到达率"""
        return queue_length / response_time
```

### 应用示例

```python
# Redis应用Little定律
class RedisLittlesLaw:
    def analyze(self):
        # 假设：
        # - 到达率：10000 req/s
        # - 平均响应时间：1 ms
        # 则系统中平均请求数：
        queue_length = 10000 * 0.001  # 10个请求
        return queue_length
```

## Amdahl定律

### 基本公式

```
加速比 = 1 / ((1 - P) + P / S)
```

其中：

- P：可并行部分比例
- S：并行加速倍数

```python
# Amdahl定律应用
class AmdahlsLaw:
    def speedup(self, parallel_fraction, speedup_factor):
        """计算加速比"""
        return 1.0 / ((1 - parallel_fraction) + parallel_fraction / speedup_factor)

    def max_speedup(self, parallel_fraction):
        """最大加速比"""
        return 1.0 / (1 - parallel_fraction)
```

### 应用示例

```python
# Redis多线程优化
class RedisAmdahl:
    def analyze(self):
        # 假设：
        # - 可并行部分：30%
        # - 并行加速：4倍（4线程）
        # 则加速比：
        speedup = 1.0 / ((1 - 0.3) + 0.3 / 4)  # 1.29倍
        return speedup
```

## 缓存命中率公式

### 基本公式

```
命中率 = 命中次数 / 总请求数
```

```python
# 缓存命中率
class CacheHitRate:
    def calculate(self, hits, total):
        return hits / total

    def miss_rate(self, hits, total):
        """未命中率"""
        return 1 - (hits / total)

    def effective_latency(self, hit_rate, cache_latency, miss_latency):
        """有效延迟"""
        return hit_rate * cache_latency + (1 - hit_rate) * miss_latency
```

### 应用示例

```python
# Redis缓存命中率
class RedisCacheHitRate:
    def analyze(self):
        # 假设：
        # - 命中率：95%
        # - 缓存延迟：0.1 ms
        # - 数据库延迟：10 ms
        # 则有效延迟：
        effective = 0.95 * 0.1 + 0.05 * 10  # 0.595 ms
        return effective
```

## 排队论公式

### M/M/1队列

```
平均等待时间 = ρ / (μ × (1 - ρ))
```

其中：

- ρ：利用率（λ / μ）
- μ：服务率
- λ：到达率

```python
# M/M/1队列
class MM1Queue:
    def waiting_time(self, arrival_rate, service_rate):
        """平均等待时间"""
        rho = arrival_rate / service_rate
        if rho >= 1:
            return float('inf')  # 系统不稳定
        return rho / (service_rate * (1 - rho))

    def queue_length(self, arrival_rate, service_rate):
        """平均队列长度"""
        rho = arrival_rate / service_rate
        if rho >= 1:
            return float('inf')
        return rho / (1 - rho)
```

### 应用示例

```python
# Redis请求队列
class RedisQueue:
    def analyze(self):
        # 假设：
        # - 到达率：10000 req/s
        # - 服务率：20000 req/s
        # 则平均等待时间：
        waiting = (10000/20000) / (20000 * (1 - 10000/20000))  # 0.05 ms
        return waiting
```

## 性能优化公式

### 1. 延迟优化

```
优化后延迟 = 原延迟 × (1 - 优化比例)
```

```python
# 延迟优化
class LatencyOptimization:
    def optimize(self, original_latency, optimization_ratio):
        """计算优化后延迟"""
        return original_latency * (1 - optimization_ratio)

    def improvement(self, original, optimized):
        """计算改进比例"""
        return (original - optimized) / original
```

### 2. 吞吐量优化

```
优化后吞吐量 = 原吞吐量 × 加速比
```

```python
# 吞吐量优化
class ThroughputOptimization:
    def optimize(self, original_throughput, speedup):
        """计算优化后吞吐量"""
        return original_throughput * speedup
```

### 3. 成本效益分析

```
ROI = (收益 - 成本) / 成本
```

```python
# 成本效益分析
class CostBenefitAnalysis:
    def roi(self, benefit, cost):
        """计算投资回报率"""
        return (benefit - cost) / cost

    def break_even(self, cost, benefit_per_unit):
        """计算盈亏平衡点"""
        return cost / benefit_per_unit
```

## 综合优化模型

### 性能模型

```python
# 综合性能模型
class PerformanceModel:
    def total_latency(self, components):
        """总延迟（各组件延迟之和）"""
        return sum(components)

    def bottleneck_analysis(self, components):
        """瓶颈分析"""
        max_component = max(components, key=lambda x: x['latency'])
        return max_component

    def optimization_priority(self, components):
        """优化优先级"""
        # 按延迟贡献排序
        sorted_components = sorted(
            components,
            key=lambda x: x['latency'],
            reverse=True
        )
        return sorted_components
```

## 扩展阅读

- [延迟分布建模](./05.06.01-延迟分布建模.md)
- [Little定律应用](./05.06.02-Little定律应用.md)
- [关键路径优化](../05.04-数据流分析/05.04.05-关键路径优化.md)

## 权威参考

- **《性能之巅》** - Brendan Gregg著
- **《排队论》** - Queueing Theory
- **《系统性能优化》** - System Performance Optimization
