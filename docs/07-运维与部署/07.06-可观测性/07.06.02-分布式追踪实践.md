# 07.06.02 分布式追踪实践

## 目录

- [07.06.02 分布式追踪实践](#070602-分布式追踪实践)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 分布式追踪基础](#2-分布式追踪基础)
    - [2.1 Trace和Span概念](#21-trace和span概念)
    - [2.2 OpenTracing标准](#22-opentracing标准)
    - [2.3 OpenTelemetry标准](#23-opentelemetry标准)
  - [3. Jaeger追踪系统](#3-jaeger追踪系统)
    - [3.1 Jaeger架构](#31-jaeger架构)
    - [3.2 Jaeger部署](#32-jaeger部署)
    - [3.3 Redis集成](#33-redis集成)
  - [4. Zipkin追踪系统](#4-zipkin追踪系统)
    - [4.1 Zipkin架构](#41-zipkin架构)
    - [4.2 Zipkin部署](#42-zipkin部署)
    - [4.3 Redis集成](#43-redis集成)
  - [5. OpenTelemetry实践](#5-opentelemetry实践)
    - [5.1 OpenTelemetry架构](#51-opentelemetry架构)
    - [5.2 Redis Instrumentation](#52-redis-instrumentation)
    - [5.3 应用集成](#53-应用集成)
  - [6. 追踪数据分析](#6-追踪数据分析)
    - [6.1 延迟分析](#61-延迟分析)
    - [6.2 依赖分析](#62-依赖分析)
    - [6.3 错误分析](#63-错误分析)
  - [7. 生产环境部署实践](#7-生产环境部署实践)
    - [7.1 完整Jaeger集群部署](#71-完整jaeger集群部署)
      - [7.1.1 Jaeger集群部署脚本](#711-jaeger集群部署脚本)
    - [7.2 Redis追踪集成工具](#72-redis追踪集成工具)
      - [7.2.1 Redis追踪装饰器](#721-redis追踪装饰器)
    - [7.3 追踪数据分析工具](#73-追踪数据分析工具)
      - [7.3.1 追踪数据分析器](#731-追踪数据分析器)
    - [7.4 最佳实践](#74-最佳实践)
    - [7.4.1 采样策略](#741-采样策略)
    - [7.4.2 标签设计](#742-标签设计)
    - [7.4.3 性能优化](#743-性能优化)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与背景

分布式追踪是分布式系统可观测性的重要组成部分，通过追踪请求在分布式系统中的完整路径，帮助理解系统行为和定位问题。

**分布式追踪背景**：

- **请求路径追踪**：追踪请求在多个服务间的完整路径
- **性能分析**：分析每个服务的延迟和瓶颈
- **依赖关系**：理解服务间的依赖关系

### 1.2 应用价值

**分布式追踪价值**：

- ✅ **问题定位**：快速定位性能瓶颈和错误
- ✅ **性能优化**：识别慢请求和优化点
- ✅ **依赖分析**：理解服务依赖关系
- ✅ **容量规划**：基于追踪数据规划容量

---

## 2. 分布式追踪基础

### 2.1 Trace和Span概念

**Trace和Span**：

- **Trace**：一次完整的请求路径，包含多个Span
- **Span**：Trace中的一个操作单元，包含开始时间、结束时间、标签等

**Trace结构示例**：

```text
Trace: user-request-12345
├── Span: HTTP Request (100ms)
│   ├── Span: Redis GET (5ms)
│   ├── Span: Database Query (50ms)
│   └── Span: Redis SET (3ms)
└── Span: HTTP Response (2ms)
```

### 2.2 OpenTracing标准

**OpenTracing核心概念**：

- **Tracer**：追踪器，创建Span
- **Span**：操作单元
- **SpanContext**：Span上下文，用于传播

**OpenTracing示例**：

```python
from opentracing import Tracer
from opentracing.ext import tags

tracer = Tracer()

# 创建Span
with tracer.start_span('redis_get') as span:
    span.set_tag('redis.command', 'GET')
    span.set_tag('redis.key', 'user:123')

    # 执行Redis操作
    value = redis_client.get('user:123')

    span.set_tag('redis.value_length', len(value) if value else 0)
```

### 2.3 OpenTelemetry标准

**OpenTelemetry核心概念**：

- **TracerProvider**：追踪器提供者
- **Tracer**：追踪器
- **Span**：操作单元
- **Context**：上下文传播

**OpenTelemetry示例**：

```python
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger import JaegerExporter

# 配置TracerProvider
trace.set_tracer_provider(TracerProvider())
tracer = trace.get_tracer(__name__)

# 配置Jaeger导出器
jaeger_exporter = JaegerExporter(
    agent_host_name='localhost',
    agent_port=6831
)
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(jaeger_exporter)
)

# 创建Span
with tracer.start_as_current_span('redis_get') as span:
    span.set_attribute('redis.command', 'GET')
    span.set_attribute('redis.key', 'user:123')

    value = redis_client.get('user:123')

    span.set_attribute('redis.value_length', len(value) if value else 0)
```

---

## 3. Jaeger追踪系统

### 3.1 Jaeger架构

**Jaeger组件**：

- **Agent**：接收Span数据
- **Collector**：收集和处理Span
- **Storage**：存储Span数据（Elasticsearch、Cassandra等）
- **Query**：查询和展示界面

### 3.2 Jaeger部署

**Jaeger部署（Docker）**：

```yaml
# docker-compose.yml
version: '3.8'
services:
  jaeger:
    image: jaegertracing/all-in-one:1.50
    container_name: jaeger
    ports:
      - "16686:16686"  # UI
      - "14268:14268"  # HTTP
      - "6831:6831/udp"  # UDP
      - "6832:6832/udp"  # UDP
    environment:
      - COLLECTOR_ZIPKIN_HOST_PORT=:9411
    networks:
      - tracing

networks:
  tracing:
    driver: bridge
```

**Jaeger部署（Kubernetes）**：

```yaml
# jaeger-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jaeger
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jaeger
  template:
    metadata:
      labels:
        app: jaeger
    spec:
      containers:
      - name: jaeger
        image: jaegertracing/all-in-one:1.50
        ports:
        - containerPort: 16686
        - containerPort: 14268
        - containerPort: 6831
          protocol: UDP
        env:
        - name: COLLECTOR_ZIPKIN_HOST_PORT
          value: ":9411"
```

### 3.3 Redis集成

**Redis OpenTelemetry集成**：

```python
from opentelemetry import trace
from opentelemetry.instrumentation.redis import RedisInstrumentor
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger import JaegerExporter
import redis

# 配置TracerProvider
trace.set_tracer_provider(TracerProvider())
tracer = trace.get_tracer(__name__)

# 配置Jaeger导出器
jaeger_exporter = JaegerExporter(
    agent_host_name='localhost',
    agent_port=6831
)
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(jaeger_exporter)
)

# 自动Instrumentation Redis
RedisInstrumentor().instrument()

# 使用Redis（自动追踪）
redis_client = redis.Redis(host='localhost', port=6379)
redis_client.get('user:123')  # 自动创建Span
```

**手动Redis追踪**：

```python
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

def traced_redis_get(redis_client, key):
    """带追踪的Redis GET操作"""
    with tracer.start_as_current_span('redis.get') as span:
        span.set_attribute('redis.command', 'GET')
        span.set_attribute('redis.key', key)

        try:
            value = redis_client.get(key)
            span.set_attribute('redis.value_length', len(value) if value else 0)
            span.set_status(trace.Status(trace.StatusCode.OK))
            return value
        except Exception as e:
            span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
            span.record_exception(e)
            raise
```

---

## 4. Zipkin追踪系统

### 4.1 Zipkin架构

**Zipkin组件**：

- **Collector**：收集Span数据
- **Storage**：存储Span数据（MySQL、Elasticsearch等）
- **Query**：查询和展示界面

### 4.2 Zipkin部署

**Zipkin部署（Docker）**：

```yaml
# docker-compose.yml
version: '3.8'
services:
  zipkin:
    image: openzipkin/zipkin:2.24
    container_name: zipkin
    ports:
      - "9411:9411"
    environment:
      - STORAGE_TYPE=elasticsearch
      - ES_HOSTS=http://elasticsearch:9200
    depends_on:
      - elasticsearch
    networks:
      - tracing

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    ports:
      - "9200:9200"
    networks:
      - tracing

networks:
  tracing:
    driver: bridge
```

### 4.3 Redis集成

**Redis Zipkin集成**：

```python
from py_zipkin.zipkin import zipkin_span
from py_zipkin.request_helpers import create_zipkin_attr
import redis

def traced_redis_get(redis_client, key):
    """带Zipkin追踪的Redis GET操作"""
    zipkin_attrs = create_zipkin_attr()

    with zipkin_span(
        service_name='redis-service',
        span_name='redis.get',
        zipkin_attrs=zipkin_attrs,
        transport_handler=http_transport,
        sample_rate=1.0
    ):
        # 添加标签
        zipkin_attrs['redis.command'] = 'GET'
        zipkin_attrs['redis.key'] = key

        value = redis_client.get(key)
        zipkin_attrs['redis.value_length'] = len(value) if value else 0

        return value
```

---

## 5. OpenTelemetry实践

### 5.1 OpenTelemetry架构

**OpenTelemetry组件**：

- **API**：追踪API
- **SDK**：SDK实现
- **Instrumentation**：自动Instrumentation库
- **Exporters**：导出器（Jaeger、Zipkin、Prometheus等）

### 5.2 Redis Instrumentation

**Redis自动Instrumentation**：

```python
from opentelemetry import trace
from opentelemetry.instrumentation.redis import RedisInstrumentor
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import ConsoleSpanExporter, BatchSpanProcessor
import redis

# 配置TracerProvider
trace.set_tracer_provider(TracerProvider())
tracer = trace.get_tracer(__name__)

# 配置控制台导出器（开发环境）
console_exporter = ConsoleSpanExporter()
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(console_exporter)
)

# 自动Instrumentation Redis
RedisInstrumentor().instrument(
    tracer_provider=trace.get_tracer_provider()
)

# 使用Redis（自动追踪）
redis_client = redis.Redis(host='localhost', port=6379)
redis_client.get('user:123')  # 自动创建Span
redis_client.set('user:123', 'value')  # 自动创建Span
```

**Redis Instrumentation配置**：

```python
from opentelemetry.instrumentation.redis import RedisInstrumentor

# 配置Instrumentation选项
RedisInstrumentor().instrument(
    tracer_provider=trace.get_tracer_provider(),
    request_hook=lambda span, instance, args, kwargs: span.set_attribute(
        'redis.db', instance.connection_pool.connection_kwargs.get('db', 0)
    ),
    response_hook=lambda span, instance, response: span.set_attribute(
        'redis.response_size', len(str(response)) if response else 0
    )
)
```

### 5.3 应用集成

**Flask应用集成**：

```python
from flask import Flask
from opentelemetry import trace
from opentelemetry.instrumentation.flask import FlaskInstrumentor
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger import JaegerExporter
import redis

app = Flask(__name__)

# 配置TracerProvider
trace.set_tracer_provider(TracerProvider())
tracer = trace.get_tracer(__name__)

# 配置Jaeger导出器
jaeger_exporter = JaegerExporter(
    agent_host_name='localhost',
    agent_port=6831
)
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(jaeger_exporter)
)

# 自动Instrumentation Flask和Redis
FlaskInstrumentor().instrument_app(app)
RedisInstrumentor().instrument()

redis_client = redis.Redis(host='localhost', port=6379)

@app.route('/user/<user_id>')
def get_user(user_id):
    # Flask自动创建Span
    # Redis操作自动创建子Span
    user_data = redis_client.get(f'user:{user_id}')
    return user_data or 'Not found'
```

---

## 6. 追踪数据分析

### 6.1 延迟分析

**延迟分析查询（Jaeger）**：

```python
from jaeger_client import Config
import time

config = Config(
    config={
        'sampler': {
            'type': 'const',
            'param': 1,
        },
        'logging': True,
    },
    service_name='redis-service',
)
tracer = config.initialize_tracer()

# 分析延迟分布
def analyze_latency(trace_id):
    """分析Trace延迟"""
    trace = tracer.get_trace(trace_id)

    total_duration = trace.duration
    spans = trace.spans

    # 计算各Span延迟占比
    for span in spans:
        span_duration = span.duration
        percentage = (span_duration / total_duration) * 100
        print(f"{span.operation_name}: {span_duration}ms ({percentage:.2f}%)")
```

### 6.2 依赖分析

**依赖关系分析**：

```python
def analyze_dependencies(traces):
    """分析服务依赖关系"""
    dependencies = {}

    for trace in traces:
        for span in trace.spans:
            service = span.tags.get('service.name')
            if service not in dependencies:
                dependencies[service] = set()

            # 查找子Span
            for child_span in trace.spans:
                if child_span.parent_id == span.span_id:
                    child_service = child_span.tags.get('service.name')
                    if child_service:
                        dependencies[service].add(child_service)

    return dependencies
```

### 6.3 错误分析

**错误分析查询**：

```python
def analyze_errors(traces):
    """分析错误Trace"""
    error_traces = []

    for trace in traces:
        for span in trace.spans:
            if span.tags.get('error') == True:
                error_traces.append({
                    'trace_id': trace.trace_id,
                    'span': span.operation_name,
                    'error': span.tags.get('error.message'),
                    'timestamp': span.start_time
                })

    return error_traces
```

---

## 7. 生产环境部署实践

### 7.1 完整Jaeger集群部署

#### 7.1.1 Jaeger集群部署脚本

```bash
#!/bin/bash
# deploy-jaeger-cluster.sh

set -e

JAEGER_VERSION="1.50"
ES_HOST="${ES_HOST:-elasticsearch}"
ES_PORT="${ES_PORT:-9200}"
ES_USER="${ES_USER:-elastic}"
ES_PASSWORD="${ES_PASSWORD:-changeme}"
DATA_DIR="/data/jaeger"

echo "开始部署Jaeger集群..."

mkdir -p "$DATA_DIR"

# 创建Jaeger配置
cat > "$DATA_DIR/jaeger-config.yaml" <<EOF
collector:
  zipkin:
    http-port: 9411
  otlp:
    grpc:
      endpoint: 0.0.0.0:4317
    http:
      endpoint: 0.0.0.0:4318

storage:
  type: elasticsearch
  elasticsearch:
    server-urls: http://${ES_HOST}:${ES_PORT}
    username: ${ES_USER}
    password: ${ES_PASSWORD}
    index-prefix: jaeger
    max-num-spans: 50000

query:
  base-path: /jaeger
EOF

# 创建docker-compose文件
cat > "$DATA_DIR/docker-compose.yml" <<EOF
version: '3.8'
services:
  jaeger-collector:
    image: jaegertracing/jaeger-collector:${JAEGER_VERSION}
    container_name: jaeger-collector
    ports:
      - "14268:14268"  # HTTP
      - "14250:14250"  # gRPC
      - "4317:4317"   # OTLP gRPC
      - "4318:4318"   # OTLP HTTP
      - "9411:9411"   # Zipkin
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://${ES_HOST}:${ES_PORT}
      - ES_USERNAME=${ES_USER}
      - ES_PASSWORD=${ES_PASSWORD}
    depends_on:
      - elasticsearch
    networks:
      - tracing

  jaeger-query:
    image: jaegertracing/jaeger-query:${JAEGER_VERSION}
    container_name: jaeger-query
    ports:
      - "16686:16686"  # UI
    environment:
      - SPAN_STORAGE_TYPE=elasticsearch
      - ES_SERVER_URLS=http://${ES_HOST}:${ES_PORT}
      - ES_USERNAME=${ES_USER}
      - ES_PASSWORD=${ES_PASSWORD}
      - QUERY_BASE_PATH=/jaeger
    depends_on:
      - elasticsearch
    networks:
      - tracing

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
    container_name: elasticsearch
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
      - ELASTIC_PASSWORD=${ES_PASSWORD}
    ports:
      - "${ES_PORT}:9200"
    networks:
      - tracing

networks:
  tracing:
    driver: bridge
EOF

# 启动服务
cd "$DATA_DIR"
docker-compose up -d

echo "等待服务启动..."
sleep 30

# 验证服务
echo "验证Jaeger Query..."
curl http://localhost:16686/api/services

echo "Jaeger集群部署完成！"
echo "Jaeger UI: http://localhost:16686"
```

### 7.2 Redis追踪集成工具

#### 7.2.1 Redis追踪装饰器

```python
#!/usr/bin/env python3
# redis-tracing-wrapper.py

from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.jaeger import JaegerExporter
from opentelemetry.instrumentation.redis import RedisInstrumentor
import redis
from functools import wraps
import time

# 配置TracerProvider
trace.set_tracer_provider(TracerProvider())
tracer = trace.get_tracer(__name__)

# 配置Jaeger导出器
jaeger_exporter = JaegerExporter(
    agent_host_name='localhost',
    agent_port=6831
)
trace.get_tracer_provider().add_span_processor(
    BatchSpanProcessor(jaeger_exporter)
)

# 自动Instrumentation Redis
RedisInstrumentor().instrument()

class TracedRedis:
    """带追踪的Redis客户端包装器"""

    def __init__(self, redis_client):
        self.redis = redis_client

    def get(self, key):
        """带追踪的GET操作"""
        with tracer.start_as_current_span('redis.get') as span:
            span.set_attribute('redis.command', 'GET')
            span.set_attribute('redis.key', key)

            start_time = time.time()
            try:
                value = self.redis.get(key)
                duration = (time.time() - start_time) * 1000

                span.set_attribute('redis.duration_ms', duration)
                span.set_attribute('redis.value_length', len(value) if value else 0)
                span.set_status(trace.Status(trace.StatusCode.OK))

                return value
            except Exception as e:
                duration = (time.time() - start_time) * 1000
                span.set_attribute('redis.duration_ms', duration)
                span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
                span.record_exception(e)
                raise

    def set(self, key, value, ex=None):
        """带追踪的SET操作"""
        with tracer.start_as_current_span('redis.set') as span:
            span.set_attribute('redis.command', 'SET')
            span.set_attribute('redis.key', key)
            span.set_attribute('redis.value_length', len(str(value)))
            if ex:
                span.set_attribute('redis.expire_seconds', ex)

            start_time = time.time()
            try:
                result = self.redis.set(key, value, ex=ex)
                duration = (time.time() - start_time) * 1000

                span.set_attribute('redis.duration_ms', duration)
                span.set_status(trace.Status(trace.StatusCode.OK))

                return result
            except Exception as e:
                duration = (time.time() - start_time) * 1000
                span.set_attribute('redis.duration_ms', duration)
                span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
                span.record_exception(e)
                raise

    def pipeline(self):
        """带追踪的Pipeline操作"""
        return TracedPipeline(self.redis.pipeline())

class TracedPipeline:
    """带追踪的Pipeline包装器"""

    def __init__(self, pipeline):
        self.pipeline = pipeline

    def execute(self):
        """执行Pipeline"""
        with tracer.start_as_current_span('redis.pipeline') as span:
            span.set_attribute('redis.command', 'PIPELINE')
            span.set_attribute('redis.commands_count', len(self.pipeline.command_stack))

            start_time = time.time()
            try:
                results = self.pipeline.execute()
                duration = (time.time() - start_time) * 1000

                span.set_attribute('redis.duration_ms', duration)
                span.set_attribute('redis.results_count', len(results))
                span.set_status(trace.Status(trace.StatusCode.OK))

                return results
            except Exception as e:
                duration = (time.time() - start_time) * 1000
                span.set_attribute('redis.duration_ms', duration)
                span.set_status(trace.Status(trace.StatusCode.ERROR, str(e)))
                span.record_exception(e)
                raise

    def __getattr__(self, name):
        return getattr(self.pipeline, name)

# 使用示例
if __name__ == '__main__':
    redis_client = redis.Redis(host='localhost', port=6379)
    traced_redis = TracedRedis(redis_client)

    # 自动追踪的操作
    traced_redis.get('user:123')
    traced_redis.set('user:123', 'value', ex=3600)
```

### 7.3 追踪数据分析工具

#### 7.3.1 追踪数据分析器

```python
#!/usr/bin/env python3
# trace-analyzer.py

from jaeger_client import Config
import json
from datetime import datetime, timedelta
from collections import defaultdict

class TraceAnalyzer:
    """追踪数据分析器"""

    def __init__(self, jaeger_query_url='http://localhost:16686'):
        self.jaeger_query_url = jaeger_query_url
        self.config = Config(
            config={
                'sampler': {
                    'type': 'const',
                    'param': 1,
                },
                'logging': True,
            },
            service_name='trace-analyzer',
        )
        self.tracer = self.config.initialize_tracer()

    def analyze_service_latency(self, service_name, hours=1):
        """分析服务延迟"""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=hours)

        # 查询服务追踪
        traces = self._query_traces(
            service=service_name,
            start_time=start_time,
            end_time=end_time
        )

        latencies = []
        for trace in traces:
            for span in trace.spans:
                if span.service_name == service_name:
                    latencies.append(span.duration)

        if not latencies:
            return None

        latencies.sort()
        n = len(latencies)

        return {
            'p50': latencies[int(n * 0.5)],
            'p95': latencies[int(n * 0.95)],
            'p99': latencies[int(n * 0.99)],
            'avg': sum(latencies) / n,
            'max': max(latencies),
            'min': min(latencies),
            'count': n
        }

    def analyze_error_rate(self, service_name, hours=1):
        """分析错误率"""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=hours)

        traces = self._query_traces(
            service=service_name,
            start_time=start_time,
            end_time=end_time
        )

        total_spans = 0
        error_spans = 0

        for trace in traces:
            for span in trace.spans:
                if span.service_name == service_name:
                    total_spans += 1
                    if span.tags.get('error') == True:
                        error_spans += 1

        return {
            'total_spans': total_spans,
            'error_spans': error_spans,
            'error_rate': error_spans / total_spans if total_spans > 0 else 0
        }

    def analyze_dependencies(self, service_name, hours=1):
        """分析服务依赖关系"""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=hours)

        traces = self._query_traces(
            service=service_name,
            start_time=start_time,
            end_time=end_time
        )

        dependencies = defaultdict(int)

        for trace in traces:
            service_spans = {}
            for span in trace.spans:
                if span.service_name == service_name:
                    service_spans[span.span_id] = span

            for span in trace.spans:
                if span.parent_id in service_spans:
                    dependencies[span.service_name] += 1

        return dict(dependencies)

    def _query_traces(self, service, start_time, end_time):
        """查询追踪数据"""
        # 这里简化实现，实际需要调用Jaeger Query API
        import requests

        params = {
            'service': service,
            'start': int(start_time.timestamp() * 1000000),
            'end': int(end_time.timestamp() * 1000000),
            'limit': 1000
        }

        response = requests.get(
            f'{self.jaeger_query_url}/api/traces',
            params=params
        )

        if response.status_code == 200:
            return response.json().get('data', [])
        return []

    def generate_report(self, service_name, hours=24):
        """生成分析报告"""
        print(f"=== {service_name} 追踪分析报告（过去{hours}小时）===\n")

        # 延迟分析
        latency = self.analyze_service_latency(service_name, hours=hours)
        if latency:
            print("延迟统计:")
            print(f"  P50: {latency['p50']:.2f}ms")
            print(f"  P95: {latency['p95']:.2f}ms")
            print(f"  P99: {latency['p99']:.2f}ms")
            print(f"  平均: {latency['avg']:.2f}ms")
            print(f"  最大: {latency['max']:.2f}ms")
            print(f"  最小: {latency['min']:.2f}ms")
            print(f"  总数: {latency['count']}")

        # 错误率分析
        error_rate = self.analyze_error_rate(service_name, hours=hours)
        print(f"\n错误统计:")
        print(f"  总Span数: {error_rate['total_spans']}")
        print(f"  错误Span数: {error_rate['error_spans']}")
        print(f"  错误率: {error_rate['error_rate']*100:.2f}%")

        # 依赖分析
        dependencies = self.analyze_dependencies(service_name, hours=hours)
        print(f"\n服务依赖:")
        for dep_service, count in sorted(dependencies.items(), key=lambda x: x[1], reverse=True)[:10]:
            print(f"  {dep_service}: {count}次调用")

# 使用示例
if __name__ == '__main__':
    analyzer = TraceAnalyzer()
    analyzer.generate_report('redis-service', hours=24)
```

### 7.4 最佳实践

### 7.4.1 采样策略

**采样策略配置**：

```python
from opentelemetry.sdk.trace.sampling import TraceIdRatioBased

# 采样率10%
sampler = TraceIdRatioBased(0.1)

trace.set_tracer_provider(
    TracerProvider(sampler=sampler)
)
```

**自适应采样**：

```python
class AdaptiveSampler:
    """自适应采样器"""
    def __init__(self, base_rate=0.1):
        self.base_rate = base_rate
        self.error_rate = 0.0

    def should_sample(self, trace_id, parent_context=None):
        """决定是否采样"""
        # 错误率高的服务提高采样率
        if self.error_rate > 0.1:
            return True

        # 正常采样率
        import random
        return random.random() < self.base_rate
```

### 7.4.2 标签设计

**标签设计规范**：

```python
# 好的标签设计
span.set_attribute('redis.command', 'GET')
span.set_attribute('redis.key', 'user:123')
span.set_attribute('redis.db', 0)
span.set_attribute('redis.connection_pool_size', 10)

# 避免的标签设计
span.set_attribute('data', large_data_object)  # 不要记录大量数据
span.set_attribute('password', 'secret')  # 不要记录敏感信息
```

### 7.4.3 性能优化

**批量导出优化**：

```python
from opentelemetry.sdk.trace.export import BatchSpanProcessor

# 批量导出配置
batch_processor = BatchSpanProcessor(
    jaeger_exporter,
    max_queue_size=2048,
    max_export_batch_size=512,
    export_timeout_millis=30000,
    schedule_delay_millis=5000
)

trace.get_tracer_provider().add_span_processor(batch_processor)
```

---

## 8. 扩展阅读

- [Jaeger官方文档](https://www.jaegertracing.io/docs/)
- [Zipkin官方文档](https://zipkin.io/)
- [OpenTelemetry官方文档](https://opentelemetry.io/docs/)
- [OpenTracing官方文档](https://opentracing.io/)

---

## 9. 权威参考

### 9.1 官方文档

- Jaeger官方文档
- Zipkin官方文档
- OpenTelemetry官方文档

### 9.2 经典书籍

- 《Distributed Tracing in Practice》
- 《Mastering Distributed Tracing》

### 9.3 在线资源

- OpenTelemetry官方博客
- Jaeger官方博客
