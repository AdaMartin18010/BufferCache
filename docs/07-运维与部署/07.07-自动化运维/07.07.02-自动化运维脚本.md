# 07.07.02 自动化运维脚本

## 目录

- [07.07.02 自动化运维脚本](#070702-自动化运维脚本)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 部署脚本](#2-部署脚本)
    - [2.1 Redis单实例部署](#21-redis单实例部署)
    - [2.2 Redis Sentinel部署](#22-redis-sentinel部署)
    - [2.3 Redis Cluster部署](#23-redis-cluster部署)
  - [3. 运维脚本](#3-运维脚本)
    - [3.1 备份恢复脚本](#31-备份恢复脚本)
    - [3.2 监控检查脚本](#32-监控检查脚本)
    - [3.3 配置管理脚本](#33-配置管理脚本)
  - [4. 故障处理脚本](#4-故障处理脚本)
    - [4.1 故障检测脚本](#41-故障检测脚本)
    - [4.2 故障恢复脚本](#42-故障恢复脚本)
    - [4.3 故障切换脚本](#43-故障切换脚本)
  - [5. 性能优化脚本](#5-性能优化脚本)
    - [5.1 内存优化脚本](#51-内存优化脚本)
    - [5.2 连接优化脚本](#52-连接优化脚本)
    - [5.3 性能分析脚本](#53-性能分析脚本)
  - [6. 多语言实现](#6-多语言实现)
    - [6.1 Python实现](#61-python实现)
      - [6.1.1 Redis部署脚本（Python）](#611-redis部署脚本python)
      - [6.1.2 Redis备份脚本（Python）](#612-redis备份脚本python)
      - [6.1.3 Redis健康检查脚本（Python）](#613-redis健康检查脚本python)
    - [6.2 Golang实现](#62-golang实现)
      - [6.2.1 Redis部署脚本（Go）](#621-redis部署脚本go)
      - [6.2.2 Redis备份脚本（Go）](#622-redis备份脚本go)
    - [6.3 Rust实现](#63-rust实现)
      - [6.3.1 Redis部署脚本（Rust）](#631-redis部署脚本rust)
    - [6.4 C++实现](#64-c实现)
      - [6.4.1 Redis部署脚本（C++）](#641-redis部署脚本c)
  - [7. 脚本最佳实践](#7-脚本最佳实践)
    - [7.1 脚本设计原则](#71-脚本设计原则)
    - [7.2 错误处理](#72-错误处理)
    - [7.3 日志记录](#73-日志记录)
  - [8. 扩展阅读](#8-扩展阅读)
  - [9. 权威参考](#9-权威参考)
    - [9.1 官方文档](#91-官方文档)
    - [9.2 经典书籍](#92-经典书籍)
    - [9.3 在线资源](#93-在线资源)

---

## 1. 概述

### 1.1 定义与背景

自动化运维脚本是用于自动化执行运维任务的脚本集合，包括部署、运维、故障处理等场景。

**自动化脚本背景**：

- **效率提升**：自动化执行，减少人工操作
- **一致性**：保证操作的一致性
- **可重复性**：支持重复执行

### 1.2 应用价值

**自动化脚本价值**：

- ✅ **效率提升**：快速执行运维任务
- ✅ **错误减少**：减少人为错误
- ✅ **一致性**：保证操作一致性
- ✅ **可追溯**：记录操作日志

---

## 2. 部署脚本

### 2.1 Redis单实例部署

**Redis单实例部署脚本**：

```bash
#!/bin/bash
# deploy_redis_single.sh

set -e

REDIS_VERSION="7.2.0"
REDIS_PORT=6379
REDIS_DATA_DIR="/var/lib/redis"
REDIS_LOG_DIR="/var/log/redis"
REDIS_USER="redis"

# 检查是否为root用户
if [ "$EUID" -ne 0 ]; then
    echo "请使用root用户运行此脚本"
    exit 1
fi

# 创建Redis用户
if ! id "$REDIS_USER" &>/dev/null; then
    useradd -r -s /bin/false $REDIS_USER
fi

# 创建目录
mkdir -p $REDIS_DATA_DIR
mkdir -p $REDIS_LOG_DIR
chown -R $REDIS_USER:$REDIS_USER $REDIS_DATA_DIR
chown -R $REDIS_USER:$REDIS_USER $REDIS_LOG_DIR

# 下载Redis
cd /tmp
wget https://download.redis.io/releases/redis-${REDIS_VERSION}.tar.gz
tar xzf redis-${REDIS_VERSION}.tar.gz
cd redis-${REDIS_VERSION}

# 编译安装
make
make install

# 创建配置文件
cat > /etc/redis/redis.conf <<EOF
port $REDIS_PORT
bind 0.0.0.0
dir $REDIS_DATA_DIR
logfile $REDIS_LOG_DIR/redis-server.log
daemonize yes
pidfile /var/run/redis.pid
maxmemory 2gb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
EOF

# 创建systemd服务
cat > /etc/systemd/system/redis.service <<EOF
[Unit]
Description=Redis In-Memory Data Store
After=network.target

[Service]
User=$REDIS_USER
Group=$REDIS_USER
ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf
ExecStop=/usr/local/bin/redis-cli shutdown
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 启动Redis
systemctl daemon-reload
systemctl enable redis
systemctl start redis

# 验证部署
sleep 2
if redis-cli ping | grep -q PONG; then
    echo "Redis部署成功"
else
    echo "Redis部署失败"
    exit 1
fi
```

### 2.2 Redis Sentinel部署

**Redis Sentinel部署脚本**：

```bash
#!/bin/bash
# deploy_redis_sentinel.sh

set -e

MASTER_IP="192.168.1.100"
MASTER_PORT=6379
SENTINEL_PORT=26379
QUORUM=2

# 创建Sentinel配置
cat > /etc/redis/sentinel.conf <<EOF
port $SENTINEL_PORT
sentinel monitor mymaster $MASTER_IP $MASTER_PORT $QUORUM
sentinel down-after-milliseconds mymaster 5000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 10000
EOF

# 创建systemd服务
cat > /etc/systemd/system/redis-sentinel.service <<EOF
[Unit]
Description=Redis Sentinel
After=network.target

[Service]
ExecStart=/usr/local/bin/redis-sentinel /etc/redis/sentinel.conf
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# 启动Sentinel
systemctl daemon-reload
systemctl enable redis-sentinel
systemctl start redis-sentinel

# 验证部署
sleep 2
if redis-cli -p $SENTINEL_PORT ping | grep -q PONG; then
    echo "Redis Sentinel部署成功"
else
    echo "Redis Sentinel部署失败"
    exit 1
fi
```

### 2.3 Redis Cluster部署

**Redis Cluster部署脚本**：

```bash
#!/bin/bash
# deploy_redis_cluster.sh

set -e

CLUSTER_NODES=6
CLUSTER_PORT_START=7000
CLUSTER_DATA_DIR="/var/lib/redis-cluster"

# 创建集群目录
mkdir -p $CLUSTER_DATA_DIR

# 部署集群节点
for i in $(seq 0 $((CLUSTER_NODES-1))); do
    PORT=$((CLUSTER_PORT_START + i))
    DATA_DIR="$CLUSTER_DATA_DIR/$PORT"
    mkdir -p $DATA_DIR

    # 创建配置文件
    cat > $DATA_DIR/redis.conf <<EOF
port $PORT
cluster-enabled yes
cluster-config-file nodes-$PORT.conf
cluster-node-timeout 5000
appendonly yes
dir $DATA_DIR
EOF

    # 启动Redis节点
    redis-server $DATA_DIR/redis.conf &
done

# 等待节点启动
sleep 5

# 初始化集群
redis-cli --cluster create \
    $(for i in $(seq 0 $((CLUSTER_NODES-1))); do
        echo -n "127.0.0.1:$((CLUSTER_PORT_START + i)) "
    done) \
    --cluster-replicas 1 \
    --cluster-yes

echo "Redis Cluster部署成功"
```

---

## 3. 运维脚本

### 3.1 备份恢复脚本

**Redis备份脚本**：

```bash
#!/bin/bash
# backup_redis.sh

set -e

BACKUP_DIR="/backup/redis"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="$BACKUP_DIR/redis_backup_$DATE.rdb"

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行RDB备份
redis-cli BGSAVE

# 等待备份完成
while [ "$(redis-cli LASTSAVE)" -lt "$(date +%s)" ]; do
    sleep 1
done

# 复制RDB文件
RDB_FILE=$(redis-cli CONFIG GET dir | tail -1)/dump.rdb
cp $RDB_FILE $BACKUP_FILE

# 压缩备份文件
gzip $BACKUP_FILE

# 上传到对象存储（可选）
# aws s3 cp ${BACKUP_FILE}.gz s3://redis-backups/

# 清理旧备份（保留7天）
find $BACKUP_DIR -name "*.rdb.gz" -mtime +7 -delete

echo "备份完成: ${BACKUP_FILE}.gz"
```

**Redis恢复脚本**：

```bash
#!/bin/bash
# restore_redis.sh

set -e

BACKUP_FILE=$1

if [ -z "$BACKUP_FILE" ]; then
    echo "用法: $0 <备份文件>"
    exit 1
fi

# 解压备份文件
if [[ $BACKUP_FILE == *.gz ]]; then
    gunzip -c $BACKUP_FILE > /tmp/dump.rdb
else
    cp $BACKUP_FILE /tmp/dump.rdb
fi

# 停止Redis
systemctl stop redis

# 复制RDB文件
RDB_DIR=$(redis-cli CONFIG GET dir | tail -1)
cp /tmp/dump.rdb $RDB_DIR/dump.rdb
chown redis:redis $RDB_DIR/dump.rdb

# 启动Redis
systemctl start redis

# 验证恢复
sleep 2
if redis-cli ping | grep -q PONG; then
    echo "恢复成功"
else
    echo "恢复失败"
    exit 1
fi
```

### 3.2 监控检查脚本

**Redis健康检查脚本**：

```bash
#!/bin/bash
# health_check_redis.sh

set -e

REDIS_HOST=${1:-localhost}
REDIS_PORT=${2:-6379}

# 检查Redis连接
if ! redis-cli -h $REDIS_HOST -p $REDIS_PORT ping | grep -q PONG; then
    echo "ERROR: Redis连接失败"
    exit 1
fi

# 检查内存使用
MEMORY_USED=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory | grep used_memory_human | cut -d: -f2 | tr -d '\r')
MEMORY_MAX=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT CONFIG GET maxmemory | tail -1)

if [ "$MEMORY_MAX" != "0" ]; then
    MEMORY_USED_BYTES=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory | grep used_memory: | cut -d: -f2 | tr -d '\r')
    MEMORY_USAGE_PERCENT=$((MEMORY_USED_BYTES * 100 / MEMORY_MAX))

    if [ $MEMORY_USAGE_PERCENT -gt 90 ]; then
        echo "WARNING: 内存使用率过高: ${MEMORY_USAGE_PERCENT}%"
    fi
fi

# 检查连接数
CONNECTIONS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO clients | grep connected_clients | cut -d: -f2 | tr -d '\r')
MAX_CONNECTIONS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT CONFIG GET maxclients | tail -1)
CONNECTION_USAGE_PERCENT=$((CONNECTIONS * 100 / MAX_CONNECTIONS))

if [ $CONNECTION_USAGE_PERCENT -gt 80 ]; then
    echo "WARNING: 连接数使用率过高: ${CONNECTION_USAGE_PERCENT}%"
fi

# 检查慢查询
SLOWLOG_COUNT=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT SLOWLOG LEN)

if [ $SLOWLOG_COUNT -gt 10 ]; then
    echo "WARNING: 慢查询数量: $SLOWLOG_COUNT"
fi

echo "Redis健康检查通过"
```

### 3.3 配置管理脚本

**Redis配置更新脚本**：

```bash
#!/bin/bash
# update_redis_config.sh

set -e

CONFIG_FILE="/etc/redis/redis.conf"
BACKUP_FILE="${CONFIG_FILE}.backup.$(date +%Y%m%d_%H%M%S)"

# 备份当前配置
cp $CONFIG_FILE $BACKUP_FILE

# 更新配置
sed -i 's/^maxmemory .*/maxmemory 4gb/' $CONFIG_FILE
sed -i 's/^maxmemory-policy .*/maxmemory-policy allkeys-lru/' $CONFIG_FILE

# 重载配置
redis-cli CONFIG REWRITE

# 验证配置
if redis-cli CONFIG GET maxmemory | grep -q "4gb"; then
    echo "配置更新成功"
else
    echo "配置更新失败，恢复备份"
    cp $BACKUP_FILE $CONFIG_FILE
    exit 1
fi
```

---

## 4. 故障处理脚本

### 4.1 故障检测脚本

**Redis故障检测脚本**：

```bash
#!/bin/bash
# detect_redis_failure.sh

REDIS_HOST=${1:-localhost}
REDIS_PORT=${2:-6379}

# 检测Redis是否响应
if ! redis-cli -h $REDIS_HOST -p $REDIS_PORT ping &>/dev/null; then
    echo "FAILURE: Redis无响应"
    exit 1
fi

# 检测Redis是否为主节点（Sentinel模式）
if redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO replication | grep -q "role:master"; then
    # 检查从节点数量
    SLAVE_COUNT=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO replication | grep connected_slaves | cut -d: -f2 | tr -d '\r')

    if [ "$SLAVE_COUNT" -eq 0 ]; then
        echo "WARNING: 主节点没有从节点"
    fi
fi

# 检测内存使用
MEMORY_USED=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory | grep used_memory: | cut -d: -f2 | tr -d '\r')
MEMORY_MAX=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT CONFIG GET maxmemory | tail -1)

if [ "$MEMORY_MAX" != "0" ] && [ "$MEMORY_USED" -ge "$MEMORY_MAX" ]; then
    echo "FAILURE: 内存已满"
    exit 1
fi

echo "Redis运行正常"
```

### 4.2 故障恢复脚本

**Redis故障恢复脚本**：

```bash
#!/bin/bash
# recover_redis.sh

set -e

REDIS_HOST=${1:-localhost}
REDIS_PORT=${2:-6379}

# 尝试重启Redis
systemctl restart redis

# 等待启动
sleep 5

# 验证恢复
if redis-cli -h $REDIS_HOST -p $REDIS_PORT ping | grep -q PONG; then
    echo "Redis恢复成功"
    exit 0
fi

# 如果重启失败，尝试从备份恢复
echo "重启失败，尝试从备份恢复"

BACKUP_FILE=$(ls -t /backup/redis/*.rdb.gz | head -1)

if [ -z "$BACKUP_FILE" ]; then
    echo "ERROR: 未找到备份文件"
    exit 1
fi

# 恢复备份
./restore_redis.sh $BACKUP_FILE

echo "从备份恢复完成"
```

### 4.3 故障切换脚本

**Redis故障切换脚本（Sentinel模式）**：

```bash
#!/bin/bash
# failover_redis.sh

set -e

SENTINEL_HOST=${1:-localhost}
SENTINEL_PORT=${2:-26379}
MASTER_NAME=${3:-mymaster}

# 触发故障切换
redis-cli -h $SENTINEL_HOST -p $SENTINEL_PORT SENTINEL failover $MASTER_NAME

# 等待故障切换完成
sleep 10

# 获取新的主节点
NEW_MASTER=$(redis-cli -h $SENTINEL_HOST -p $SENTINEL_PORT SENTINEL get-master-addr-by-name $MASTER_NAME | head -1)

if [ -z "$NEW_MASTER" ]; then
    echo "ERROR: 故障切换失败"
    exit 1
fi

echo "故障切换成功，新主节点: $NEW_MASTER"
```

---

## 5. 性能优化脚本

### 5.1 内存优化脚本

**Redis内存优化脚本**：

```bash
#!/bin/bash
# optimize_redis_memory.sh

set -e

REDIS_HOST=${1:-localhost}
REDIS_PORT=${2:-6379}

# 获取内存使用情况
MEMORY_USED=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO memory | grep used_memory: | cut -d: -f2 | tr -d '\r')
MEMORY_MAX=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT CONFIG GET maxmemory | tail -1)

if [ "$MEMORY_MAX" = "0" ]; then
    echo "未设置最大内存限制"
    exit 1
fi

MEMORY_USAGE_PERCENT=$((MEMORY_USED * 100 / MEMORY_MAX))

if [ $MEMORY_USAGE_PERCENT -lt 80 ]; then
    echo "内存使用率正常: ${MEMORY_USAGE_PERCENT}%"
    exit 0
fi

echo "内存使用率过高: ${MEMORY_USAGE_PERCENT}%"

# 查找大Key
echo "查找大Key..."
redis-cli -h $REDIS_HOST -p $REDIS_PORT --bigkeys

# 清理过期Key
echo "清理过期Key..."
redis-cli -h $REDIS_HOST -p $REDIS_PORT --scan --pattern "*" | while read key; do
    TTL=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT TTL "$key")
    if [ "$TTL" -eq -1 ]; then
        echo "发现无过期时间的Key: $key"
    fi
done

# 内存碎片整理
echo "执行内存碎片整理..."
redis-cli -h $REDIS_HOST -p $REDIS_PORT MEMORY PURGE

echo "内存优化完成"
```

### 5.2 连接优化脚本

**Redis连接优化脚本**：

```bash
#!/bin/bash
# optimize_redis_connections.sh

set -e

REDIS_HOST=${1:-localhost}
REDIS_PORT=${2:-6379}

# 获取连接信息
CONNECTIONS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO clients | grep connected_clients | cut -d: -f2 | tr -d '\r')
MAX_CONNECTIONS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT CONFIG GET maxclients | tail -1)

echo "当前连接数: $CONNECTIONS"
echo "最大连接数: $MAX_CONNECTIONS"

# 检查空闲连接
CLIENT_LIST=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT CLIENT LIST)
IDLE_CONNECTIONS=$(echo "$CLIENT_LIST" | awk -F' ' '{if ($9 > 3600) print $2}' | wc -l)

if [ "$IDLE_CONNECTIONS" -gt 0 ]; then
    echo "发现 $IDLE_CONNECTIONS 个空闲连接（超过1小时）"

    # 关闭空闲连接
    echo "$CLIENT_LIST" | awk -F' ' '{if ($9 > 3600) print $2}' | while read client_id; do
        redis-cli -h $REDIS_HOST -p $REDIS_PORT CLIENT KILL ID $client_id
        echo "关闭空闲连接: $client_id"
    done
fi

# 设置连接超时
redis-cli -h $REDIS_HOST -p $REDIS_PORT CONFIG SET timeout 300

echo "连接优化完成"
```

### 5.3 性能分析脚本

**Redis性能分析脚本**：

```bash
#!/bin/bash
# analyze_redis_performance.sh

set -e

REDIS_HOST=${1:-localhost}
REDIS_PORT=${2:-6379}
DURATION=${3:-60}

echo "开始性能分析，持续时间: ${DURATION}秒"

# 记录开始时间
START_TIME=$(date +%s)

# 获取初始统计信息
INITIAL_OPS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO stats | grep total_commands_processed | cut -d: -f2 | tr -d '\r')
INITIAL_HITS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO stats | grep keyspace_hits | cut -d: -f2 | tr -d '\r')
INITIAL_MISSES=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO stats | grep keyspace_misses | cut -d: -f2 | tr -d '\r')

# 等待指定时间
sleep $DURATION

# 获取结束统计信息
FINAL_OPS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO stats | grep total_commands_processed | cut -d: -f2 | tr -d '\r')
FINAL_HITS=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO stats | grep keyspace_hits | cut -d: -f2 | tr -d '\r')
FINAL_MISSES=$(redis-cli -h $REDIS_HOST -p $REDIS_PORT INFO stats | grep keyspace_misses | cut -d: -f2 | tr -d '\r')

# 计算性能指标
OPS=$((FINAL_OPS - INITIAL_OPS))
QPS=$((OPS / DURATION))
HITS=$((FINAL_HITS - INITIAL_HITS))
MISSES=$((FINAL_MISSES - INITIAL_MISSES))
HIT_RATE=$((HITS * 100 / (HITS + MISSES))) if [ $((HITS + MISSES)) -gt 0 ]; then HIT_RATE=$((HITS * 100 / (HITS + MISSES))); else HIT_RATE=0; fi

echo "性能分析结果:"
echo "  总操作数: $OPS"
echo "  QPS: $QPS"
echo "  命中率: ${HIT_RATE}%"
echo "  命中数: $HITS"
echo "  未命中数: $MISSES"
```

---

## 6. 多语言实现

### 6.1 Python实现

#### 6.1.1 Redis部署脚本（Python）

```python
#!/usr/bin/env python3
"""
Redis单实例部署脚本（Python）
"""
import os
import subprocess
import sys
import shutil
from pathlib import Path

class RedisDeployer:
    """Redis部署器"""

    def __init__(self, redis_version="7.2.0", redis_port=6379):
        self.redis_version = redis_version
        self.redis_port = redis_port
        self.redis_data_dir = Path("/var/lib/redis")
        self.redis_log_dir = Path("/var/log/redis")
        self.redis_user = "redis"

    def check_root(self):
        """检查是否为root用户"""
        if os.geteuid() != 0:
            print("请使用root用户运行此脚本")
            sys.exit(1)

    def create_user(self):
        """创建Redis用户"""
        try:
            subprocess.run(
                ["useradd", "-r", "-s", "/bin/false", self.redis_user],
                check=True,
                capture_output=True
            )
        except subprocess.CalledProcessError:
            # 用户可能已存在，忽略错误
            pass

    def create_directories(self):
        """创建目录"""
        self.redis_data_dir.mkdir(parents=True, exist_ok=True)
        self.redis_log_dir.mkdir(parents=True, exist_ok=True)

        # 设置权限
        shutil.chown(self.redis_data_dir, self.redis_user, self.redis_user)
        shutil.chown(self.redis_log_dir, self.redis_user, self.redis_user)

    def download_and_install(self):
        """下载并安装Redis"""
        import urllib.request
        import tarfile

        redis_url = f"https://download.redis.io/releases/redis-{self.redis_version}.tar.gz"
        tar_file = f"/tmp/redis-{self.redis_version}.tar.gz"

        # 下载
        print(f"下载Redis {self.redis_version}...")
        urllib.request.urlretrieve(redis_url, tar_file)

        # 解压
        with tarfile.open(tar_file, "r:gz") as tar:
            tar.extractall("/tmp")

        # 编译安装
        redis_dir = f"/tmp/redis-{self.redis_version}"
        subprocess.run(["make"], cwd=redis_dir, check=True)
        subprocess.run(["make", "install"], cwd=redis_dir, check=True)

    def create_config(self):
        """创建配置文件"""
        config_content = f"""port {self.redis_port}
bind 0.0.0.0
dir {self.redis_data_dir}
logfile {self.redis_log_dir}/redis-server.log
daemonize yes
pidfile /var/run/redis.pid
maxmemory 2gb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
"""

        config_file = Path("/etc/redis/redis.conf")
        config_file.parent.mkdir(parents=True, exist_ok=True)
        config_file.write_text(config_content)

    def create_systemd_service(self):
        """创建systemd服务"""
        service_content = f"""[Unit]
Description=Redis In-Memory Data Store
After=network.target

[Service]
User={self.redis_user}
Group={self.redis_user}
ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf
ExecStop=/usr/local/bin/redis-cli shutdown
Restart=always

[Install]
WantedBy=multi-user.target
"""

        service_file = Path("/etc/systemd/system/redis.service")
        service_file.write_text(service_content)

    def start_service(self):
        """启动服务"""
        subprocess.run(["systemctl", "daemon-reload"], check=True)
        subprocess.run(["systemctl", "enable", "redis"], check=True)
        subprocess.run(["systemctl", "start", "redis"], check=True)

    def verify_deployment(self):
        """验证部署"""
        import time
        import redis

        time.sleep(2)
        try:
            r = redis.Redis(host='localhost', port=self.redis_port)
            if r.ping():
                print("Redis部署成功")
                return True
        except Exception as e:
            print(f"Redis部署失败: {e}")
            return False

    def deploy(self):
        """执行部署"""
        self.check_root()
        self.create_user()
        self.create_directories()
        self.download_and_install()
        self.create_config()
        self.create_systemd_service()
        self.start_service()
        self.verify_deployment()

if __name__ == '__main__':
    deployer = RedisDeployer()
    deployer.deploy()
```

#### 6.1.2 Redis备份脚本（Python）

```python
#!/usr/bin/env python3
"""
Redis备份脚本（Python）
"""
import redis
import gzip
import shutil
from pathlib import Path
from datetime import datetime
import time

class RedisBackup:
    """Redis备份工具"""

    def __init__(self, redis_host='localhost', redis_port=6379, backup_dir='/backup/redis'):
        self.redis_client = redis.Redis(host=redis_host, port=redis_port)
        self.backup_dir = Path(backup_dir)
        self.backup_dir.mkdir(parents=True, exist_ok=True)

    def backup(self):
        """执行备份"""
        # 触发RDB备份
        self.redis_client.bgsave()

        # 等待备份完成
        last_save = self.redis_client.lastsave()
        while True:
            current_save = self.redis_client.lastsave()
            if current_save > last_save:
                break
            time.sleep(1)

        # 获取RDB文件路径
        rdb_dir = self.redis_client.config_get('dir')['dir']
        rdb_file = Path(rdb_dir) / 'dump.rdb'

        # 创建备份文件名
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        backup_file = self.backup_dir / f'redis_backup_{timestamp}.rdb.gz'

        # 压缩并复制
        with open(rdb_file, 'rb') as f_in:
            with gzip.open(backup_file, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)

        print(f"备份完成: {backup_file}")
        return backup_file

    def cleanup_old_backups(self, days=7):
        """清理旧备份"""
        import time
        cutoff_time = time.time() - (days * 24 * 3600)

        for backup_file in self.backup_dir.glob('*.rdb.gz'):
            if backup_file.stat().st_mtime < cutoff_time:
                backup_file.unlink()
                print(f"删除旧备份: {backup_file}")

if __name__ == '__main__':
    backup = RedisBackup()
    backup.backup()
    backup.cleanup_old_backups()
```

#### 6.1.3 Redis健康检查脚本（Python）

```python
#!/usr/bin/env python3
"""
Redis健康检查脚本（Python）
"""
import redis
import sys

class RedisHealthChecker:
    """Redis健康检查器"""

    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis_client = redis.Redis(
            host=redis_host,
            port=redis_port,
            socket_connect_timeout=5
        )

    def check_connection(self):
        """检查连接"""
        try:
            if self.redis_client.ping():
                return True
        except Exception as e:
            print(f"ERROR: Redis连接失败: {e}")
            return False

    def check_memory(self):
        """检查内存使用"""
        info = self.redis_client.info('memory')
        maxmemory = int(self.redis_client.config_get('maxmemory')['maxmemory'])

        if maxmemory == 0:
            return True

        used_memory = info['used_memory']
        usage_percent = (used_memory / maxmemory) * 100

        if usage_percent > 90:
            print(f"WARNING: 内存使用率过高: {usage_percent:.2f}%")
            return False

        return True

    def check_connections(self):
        """检查连接数"""
        info = self.redis_client.info('clients')
        max_clients = int(self.redis_client.config_get('maxclients')['maxclients'])
        connected_clients = info['connected_clients']

        usage_percent = (connected_clients / max_clients) * 100

        if usage_percent > 80:
            print(f"WARNING: 连接数使用率过高: {usage_percent:.2f}%")
            return False

        return True

    def check_slowlog(self):
        """检查慢查询"""
        slowlog_count = self.redis_client.slowlog_len()

        if slowlog_count > 10:
            print(f"WARNING: 慢查询数量: {slowlog_count}")
            return False

        return True

    def check_all(self):
        """执行所有检查"""
        if not self.check_connection():
            sys.exit(1)

        checks = [
            self.check_memory(),
            self.check_connections(),
            self.check_slowlog()
        ]

        if all(checks):
            print("Redis健康检查通过")
            return True
        else:
            return False

if __name__ == '__main__':
    checker = RedisHealthChecker()
    if not checker.check_all():
        sys.exit(1)
```

### 6.2 Golang实现

#### 6.2.1 Redis部署脚本（Go）

```go
package main

import (
    "fmt"
    "os"
    "os/exec"
    "path/filepath"
    "strings"
)

type RedisDeployer struct {
    RedisVersion string
    RedisPort    int
    DataDir      string
    LogDir       string
    RedisUser    string
}

func NewRedisDeployer() *RedisDeployer {
    return &RedisDeployer{
        RedisVersion: "7.2.0",
        RedisPort:    6379,
        DataDir:      "/var/lib/redis",
        LogDir:       "/var/log/redis",
        RedisUser:    "redis",
    }
}

func (d *RedisDeployer) CheckRoot() error {
    if os.Geteuid() != 0 {
        return fmt.Errorf("请使用root用户运行此脚本")
    }
    return nil
}

func (d *RedisDeployer) CreateUser() error {
    cmd := exec.Command("useradd", "-r", "-s", "/bin/false", d.RedisUser)
    if err := cmd.Run(); err != nil {
        // 用户可能已存在，忽略错误
    }
    return nil
}

func (d *RedisDeployer) CreateDirectories() error {
    if err := os.MkdirAll(d.DataDir, 0755); err != nil {
        return err
    }
    if err := os.MkdirAll(d.LogDir, 0755); err != nil {
        return err
    }

    // 设置权限
    exec.Command("chown", "-R", d.RedisUser+":"+d.RedisUser, d.DataDir).Run()
    exec.Command("chown", "-R", d.RedisUser+":"+d.RedisUser, d.LogDir).Run()

    return nil
}

func (d *RedisDeployer) CreateConfig() error {
    configContent := fmt.Sprintf(`port %d
bind 0.0.0.0
dir %s
logfile %s/redis-server.log
daemonize yes
pidfile /var/run/redis.pid
maxmemory 2gb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
`, d.RedisPort, d.DataDir, d.LogDir)

    configFile := "/etc/redis/redis.conf"
    os.MkdirAll(filepath.Dir(configFile), 0755)

    return os.WriteFile(configFile, []byte(configContent), 0644)
}

func (d *RedisDeployer) CreateSystemdService() error {
    serviceContent := fmt.Sprintf(`[Unit]
Description=Redis In-Memory Data Store
After=network.target

[Service]
User=%s
Group=%s
ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf
ExecStop=/usr/local/bin/redis-cli shutdown
Restart=always

[Install]
WantedBy=multi-user.target
`, d.RedisUser, d.RedisUser)

    serviceFile := "/etc/systemd/system/redis.service"
    return os.WriteFile(serviceFile, []byte(serviceContent), 0644)
}

func (d *RedisDeployer) StartService() error {
    exec.Command("systemctl", "daemon-reload").Run()
    exec.Command("systemctl", "enable", "redis").Run()
    return exec.Command("systemctl", "start", "redis").Run()
}

func (d *RedisDeployer) Deploy() error {
    if err := d.CheckRoot(); err != nil {
        return err
    }

    if err := d.CreateUser(); err != nil {
        return err
    }

    if err := d.CreateDirectories(); err != nil {
        return err
    }

    if err := d.CreateConfig(); err != nil {
        return err
    }

    if err := d.CreateSystemdService(); err != nil {
        return err
    }

    return d.StartService()
}

func main() {
    deployer := NewRedisDeployer()
    if err := deployer.Deploy(); err != nil {
        fmt.Fprintf(os.Stderr, "部署失败: %v\n", err)
        os.Exit(1)
    }
    fmt.Println("Redis部署成功")
}
```

#### 6.2.2 Redis备份脚本（Go）

```go
package main

import (
    "compress/gzip"
    "fmt"
    "io"
    "os"
    "path/filepath"
    "time"

    "github.com/go-redis/redis/v8"
    "golang.org/x/net/context"
)

type RedisBackup struct {
    client    *redis.Client
    backupDir string
}

func NewRedisBackup(addr, backupDir string) *RedisBackup {
    return &RedisBackup{
        client: redis.NewClient(&redis.Options{
            Addr: addr,
        }),
        backupDir: backupDir,
    }
}

func (b *RedisBackup) Backup(ctx context.Context) error {
    // 触发RDB备份
    if err := b.client.BgSave(ctx).Err(); err != nil {
        return err
    }

    // 等待备份完成
    lastSave := b.client.LastSave(ctx).Val()
    for {
        currentSave := b.client.LastSave(ctx).Val()
        if currentSave > lastSave {
            break
        }
        time.Sleep(1 * time.Second)
    }

    // 获取RDB文件路径
    rdbDir := b.client.ConfigGet(ctx, "dir").Val()["dir"]
    rdbFile := filepath.Join(rdbDir, "dump.rdb")

    // 创建备份文件名
    timestamp := time.Now().Format("20060102_150405")
    backupFile := filepath.Join(b.backupDir, fmt.Sprintf("redis_backup_%s.rdb.gz", timestamp))

    // 压缩并复制
    src, err := os.Open(rdbFile)
    if err != nil {
        return err
    }
    defer src.Close()

    dst, err := os.Create(backupFile)
    if err != nil {
        return err
    }
    defer dst.Close()

    gz := gzip.NewWriter(dst)
    defer gz.Close()

    _, err = io.Copy(gz, src)
    if err != nil {
        return err
    }

    fmt.Printf("备份完成: %s\n", backupFile)
    return nil
}

func main() {
    ctx := context.Background()
    backup := NewRedisBackup("localhost:6379", "/backup/redis")
    if err := backup.Backup(ctx); err != nil {
        fmt.Fprintf(os.Stderr, "备份失败: %v\n", err)
        os.Exit(1)
    }
}
```

### 6.3 Rust实现

#### 6.3.1 Redis部署脚本（Rust）

```rust
use std::fs;
use std::io::Write;
use std::path::Path;
use std::process::Command;

struct RedisDeployer {
    redis_version: String,
    redis_port: u16,
    data_dir: String,
    log_dir: String,
    redis_user: String,
}

impl RedisDeployer {
    fn new() -> Self {
        Self {
            redis_version: "7.2.0".to_string(),
            redis_port: 6379,
            data_dir: "/var/lib/redis".to_string(),
            log_dir: "/var/log/redis".to_string(),
            redis_user: "redis".to_string(),
        }
    }

    fn check_root(&self) -> Result<(), Box<dyn std::error::Error>> {
        if unsafe { libc::geteuid() } != 0 {
            return Err("请使用root用户运行此脚本".into());
        }
        Ok(())
    }

    fn create_directories(&self) -> Result<(), Box<dyn std::error::Error>> {
        fs::create_dir_all(&self.data_dir)?;
        fs::create_dir_all(&self.log_dir)?;

        // 设置权限
        Command::new("chown")
            .args(&["-R", &format!("{}:{}", self.redis_user, self.redis_user), &self.data_dir])
            .status()?;

        Command::new("chown")
            .args(&["-R", &format!("{}:{}", self.redis_user, self.redis_user), &self.log_dir])
            .status()?;

        Ok(())
    }

    fn create_config(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config_content = format!(
            "port {}\nbind 0.0.0.0\ndir {}\nlogfile {}/redis-server.log\ndaemonize yes\npidfile /var/run/redis.pid\nmaxmemory 2gb\nmaxmemory-policy allkeys-lru\nsave 900 1\nsave 300 10\nsave 60 10000\n",
            self.redis_port, self.data_dir, self.log_dir
        );

        fs::create_dir_all("/etc/redis")?;
        let mut file = fs::File::create("/etc/redis/redis.conf")?;
        file.write_all(config_content.as_bytes())?;

        Ok(())
    }

    fn create_systemd_service(&self) -> Result<(), Box<dyn std::error::Error>> {
        let service_content = format!(
            "[Unit]\nDescription=Redis In-Memory Data Store\nAfter=network.target\n\n[Service]\nUser={}\nGroup={}\nExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf\nExecStop=/usr/local/bin/redis-cli shutdown\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n",
            self.redis_user, self.redis_user
        );

        let mut file = fs::File::create("/etc/systemd/system/redis.service")?;
        file.write_all(service_content.as_bytes())?;

        Ok(())
    }

    fn start_service(&self) -> Result<(), Box<dyn std::error::Error>> {
        Command::new("systemctl").args(&["daemon-reload"]).status()?;
        Command::new("systemctl").args(&["enable", "redis"]).status()?;
        Command::new("systemctl").args(&["start", "redis"]).status()?;

        Ok(())
    }

    fn deploy(&self) -> Result<(), Box<dyn std::error::Error>> {
        self.check_root()?;
        self.create_directories()?;
        self.create_config()?;
        self.create_systemd_service()?;
        self.start_service()?;

        println!("Redis部署成功");
        Ok(())
    }
}

fn main() {
    let deployer = RedisDeployer::new();
    if let Err(e) = deployer.deploy() {
        eprintln!("部署失败: {}", e);
        std::process::exit(1);
    }
}
```

### 6.4 C++实现

#### 6.4.1 Redis部署脚本（C++）

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <sys/stat.h>
#include <unistd.h>

class RedisDeployer {
private:
    std::string redis_version;
    int redis_port;
    std::string data_dir;
    std::string log_dir;
    std::string redis_user;

public:
    RedisDeployer()
        : redis_version("7.2.0")
        , redis_port(6379)
        , data_dir("/var/lib/redis")
        , log_dir("/var/log/redis")
        , redis_user("redis")
    {}

    bool checkRoot() {
        if (geteuid() != 0) {
            std::cerr << "请使用root用户运行此脚本" << std::endl;
            return false;
        }
        return true;
    }

    bool createDirectories() {
        std::string cmd1 = "mkdir -p " + data_dir;
        std::string cmd2 = "mkdir -p " + log_dir;
        std::string cmd3 = "chown -R " + redis_user + ":" + redis_user + " " + data_dir;
        std::string cmd4 = "chown -R " + redis_user + ":" + redis_user + " " + log_dir;

        system(cmd1.c_str());
        system(cmd2.c_str());
        system(cmd3.c_str());
        system(cmd4.c_str());

        return true;
    }

    bool createConfig() {
        std::string config_content =
            "port " + std::to_string(redis_port) + "\n" +
            "bind 0.0.0.0\n" +
            "dir " + data_dir + "\n" +
            "logfile " + log_dir + "/redis-server.log\n" +
            "daemonize yes\n" +
            "pidfile /var/run/redis.pid\n" +
            "maxmemory 2gb\n" +
            "maxmemory-policy allkeys-lru\n" +
            "save 900 1\n" +
            "save 300 10\n" +
            "save 60 10000\n";

        system("mkdir -p /etc/redis");

        std::ofstream config_file("/etc/redis/redis.conf");
        if (!config_file.is_open()) {
            return false;
        }

        config_file << config_content;
        config_file.close();

        return true;
    }

    bool createSystemdService() {
        std::string service_content =
            "[Unit]\n"
            "Description=Redis In-Memory Data Store\n"
            "After=network.target\n"
            "\n"
            "[Service]\n"
            "User=" + redis_user + "\n"
            "Group=" + redis_user + "\n"
            "ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf\n"
            "ExecStop=/usr/local/bin/redis-cli shutdown\n"
            "Restart=always\n"
            "\n"
            "[Install]\n"
            "WantedBy=multi-user.target\n";

        std::ofstream service_file("/etc/systemd/system/redis.service");
        if (!service_file.is_open()) {
            return false;
        }

        service_file << service_content;
        service_file.close();

        return true;
    }

    bool startService() {
        system("systemctl daemon-reload");
        system("systemctl enable redis");
        system("systemctl start redis");

        return true;
    }

    bool deploy() {
        if (!checkRoot()) {
            return false;
        }

        if (!createDirectories()) {
            return false;
        }

        if (!createConfig()) {
            return false;
        }

        if (!createSystemdService()) {
            return false;
        }

        if (!startService()) {
            return false;
        }

        std::cout << "Redis部署成功" << std::endl;
        return true;
    }
};

int main() {
    RedisDeployer deployer;
    if (!deployer.deploy()) {
        std::cerr << "部署失败" << std::endl;
        return 1;
    }
    return 0;
}
```

---

## 7. 脚本最佳实践

### 7.1 脚本设计原则

**脚本设计原则**：

- **错误处理**：使用`set -e`和错误检查
- **日志记录**：记录操作日志
- **幂等性**：支持重复执行
- **可测试性**：可以单独测试

### 7.2 错误处理

**错误处理示例**：

```bash
#!/bin/bash
set -e  # 遇到错误立即退出

# 函数错误处理
function handle_error() {
    echo "错误发生在第 $1 行"
    exit 1
}

trap 'handle_error $LINENO' ERR

# 命令错误处理
if ! command -v redis-cli &> /dev/null; then
    echo "ERROR: redis-cli未安装"
    exit 1
fi
```

### 7.3 日志记录

**日志记录示例**：

```bash
#!/bin/bash

LOG_FILE="/var/log/redis_ops.log"

function log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

log "开始执行Redis操作"
# 执行操作
log "操作完成"
```

---

## 8. 扩展阅读

- [Bash脚本最佳实践](https://github.com/koalaman/shellcheck)
- [Redis运维手册](https://redis.io/docs/manual/)
- [Python Redis客户端](https://github.com/redis/redis-py)
- [Go Redis客户端](https://github.com/go-redis/redis)
- [Rust Redis客户端](https://github.com/redis-rs/redis-rs)

---

## 9. 权威参考

### 9.1 官方文档

- Redis官方文档
- Bash官方文档
- Python官方文档
- Go官方文档
- Rust官方文档

### 9.2 经典书籍

- 《Linux Shell脚本攻略》
- 《Python自动化运维》
- 《Go语言实战》

### 9.3 在线资源

- Shell脚本最佳实践
- Redis运维最佳实践
- 多语言Redis客户端库
