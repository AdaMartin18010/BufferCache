# 07.08.02 多租户资源隔离

## 目录

- [07.08.02 多租户资源隔离](#070802-多租户资源隔离)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 内存隔离](#2-内存隔离)
    - [2.1 内存配额管理](#21-内存配额管理)
    - [2.2 内存使用监控](#22-内存使用监控)
    - [2.3 内存超限处理](#23-内存超限处理)
  - [3. CPU隔离](#3-cpu隔离)
    - [3.1 CPU配额管理](#31-cpu配额管理)
    - [3.2 CPU使用监控](#32-cpu使用监控)
    - [3.3 CPU限制实现](#33-cpu限制实现)
  - [4. 网络隔离](#4-网络隔离)
    - [4.1 带宽限制](#41-带宽限制)
    - [4.2 连接数限制](#42-连接数限制)
    - [4.3 网络QoS](#43-网络qos)
  - [5. 存储隔离](#5-存储隔离)
    - [5.1 存储配额管理](#51-存储配额管理)
    - [5.2 存储使用监控](#52-存储使用监控)
    - [5.3 存储清理策略](#53-存储清理策略)
  - [6. 性能隔离](#6-性能隔离)
    - [6.1 QPS隔离](#61-qps隔离)
    - [6.2 延迟隔离](#62-延迟隔离)
    - [6.3 吞吐量隔离](#63-吞吐量隔离)
  - [7. 资源配额系统](#7-资源配额系统)
    - [7.1 配额配置](#71-配额配置)
    - [7.2 配额检查](#72-配额检查)
    - [7.3 配额动态调整](#73-配额动态调整)
  - [8. 资源监控与告警](#8-资源监控与告警)
    - [8.1 资源使用监控](#81-资源使用监控)
    - [8.2 配额使用告警](#82-配额使用告警)
    - [8.3 资源超限告警](#83-资源超限告警)
      - [8.3.1 告警系统实现](#831-告警系统实现)
  - [9. 资源隔离最佳实践](#9-资源隔离最佳实践)
    - [9.1 隔离策略选择](#91-隔离策略选择)
    - [9.2 配额设置原则](#92-配额设置原则)
    - [9.3 监控告警配置](#93-监控告警配置)
  - [10. 扩展阅读](#10-扩展阅读)
  - [11. 权威参考](#11-权威参考)

---

## 1. 概述

多租户资源隔离是多租户架构的核心保障，确保不同租户之间的资源使用互不影响。

**隔离目标**：

- ✅ 资源完全隔离
- ✅ 性能互不影响
- ✅ 配额精确控制
- ✅ 超限及时告警

**隔离范围**：

- 内存隔离（内存配额、使用监控、超限处理）
- CPU隔离（CPU配额、使用监控、限制实现）
- 网络隔离（带宽限制、连接数限制、QoS）
- 存储隔离（存储配额、使用监控、清理策略）
- 性能隔离（QPS隔离、延迟隔离、吞吐量隔离）

---

## 2. 内存隔离

### 2.1 内存配额管理

**内存配额管理器**：

```python
#!/usr/bin/env python3
# memory-quota-manager.py

import redis
import json
from typing import Dict, Optional

class MemoryQuotaManager:
    """内存配额管理器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.quota_key = "tenant:memory:quota"
        self.usage_key = "tenant:memory:usage"

    def set_quota(self, tenant_id, memory_mb: int):
        """设置内存配额"""
        memory_bytes = memory_mb * 1024 * 1024
        self.redis.hset(self.quota_key, tenant_id, memory_bytes)

        # 如果使用独立实例，设置maxmemory
        tenant_client = self.get_tenant_client(tenant_id)
        if tenant_client:
            tenant_client.config_set('maxmemory', f'{memory_bytes}')
            tenant_client.config_set('maxmemory-policy', 'allkeys-lru')

    def get_quota(self, tenant_id) -> Optional[int]:
        """获取内存配额（字节）"""
        quota_bytes = self.redis.hget(self.quota_key, tenant_id)
        return int(quota_bytes) if quota_bytes else None

    def get_usage(self, tenant_id) -> int:
        """获取内存使用量（字节）"""
        usage_bytes = self.redis.hget(self.usage_key, tenant_id)
        return int(usage_bytes) if usage_bytes else 0

    def update_usage(self, tenant_id, memory_bytes: int):
        """更新内存使用量"""
        self.redis.hset(self.usage_key, tenant_id, memory_bytes)

    def check_quota(self, tenant_id, additional_memory: int = 0) -> tuple[bool, Dict]:
        """检查内存配额"""
        quota = self.get_quota(tenant_id)
        if quota is None:
            return True, {'unlimited': True}

        current_usage = self.get_usage(tenant_id)
        total_usage = current_usage + additional_memory

        usage_percent = (total_usage / quota) * 100

        return total_usage <= quota, {
            'quota': quota,
            'current_usage': current_usage,
            'total_usage': total_usage,
            'usage_percent': usage_percent,
            'available': quota - total_usage
        }

    def get_tenant_client(self, tenant_id):
        """获取租户的Redis客户端"""
        # 实现获取租户客户端逻辑
        return None

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
quota_manager = MemoryQuotaManager(redis_client)

# 设置配额
quota_manager.set_quota('tenant1', 1024)  # 1GB
quota_manager.set_quota('tenant2', 2048)  # 2GB

# 检查配额
allowed, info = quota_manager.check_quota('tenant1', 100 * 1024 * 1024)
if not allowed:
    print(f"Memory quota exceeded: {info['usage_percent']:.2f}%")
```

**内存使用计算**：

```python
#!/usr/bin/env python3
# memory-usage-calculator.py

import redis
from typing import List

class MemoryUsageCalculator:
    """内存使用计算器"""

    def __init__(self, redis_client):
        self.redis = redis_client

    def calculate_tenant_memory(self, tenant_id, key_prefix: str = None) -> int:
        """计算租户内存使用量"""
        if key_prefix is None:
            key_prefix = f"{tenant_id}:"

        total_memory = 0
        cursor = 0

        while True:
            cursor, keys = self.redis.scan(
                cursor,
                match=f"{key_prefix}*",
                count=100
            )

            for key in keys:
                try:
                    memory = self.redis.memory_usage(key)
                    total_memory += memory
                except:
                    pass

            if cursor == 0:
                break

        return total_memory

    def calculate_tenant_memory_by_db(self, tenant_id, db_number: int) -> int:
        """通过数据库计算内存使用量"""
        tenant_client = redis.Redis(
            host=self.redis.connection_pool.connection_kwargs['host'],
            port=self.redis.connection_pool.connection_kwargs['port'],
            db=db_number,
            decode_responses=True
        )

        info_memory = tenant_client.info('memory')
        return info_memory.get('used_memory', 0)

    def calculate_tenant_memory_by_instance(self, tenant_id, instance_config) -> int:
        """通过独立实例计算内存使用量"""
        tenant_client = redis.Redis(
            host=instance_config['host'],
            port=instance_config['port'],
            decode_responses=True
        )

        info_memory = tenant_client.info('memory')
        return info_memory.get('used_memory', 0)

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
calculator = MemoryUsageCalculator(redis_client)

# 计算内存使用（Key前缀隔离）
memory_usage = calculator.calculate_tenant_memory('tenant1')

# 计算内存使用（数据库隔离）
memory_usage = calculator.calculate_tenant_memory_by_db('tenant1', db_number=0)
```

### 2.2 内存使用监控

**内存监控器**：

```python
#!/usr/bin/env python3
# memory-monitor.py

import redis
import time
import threading
from prometheus_client import Gauge
from typing import Dict

class MemoryMonitor:
    """内存监控器"""

    def __init__(self, redis_client, quota_manager):
        self.redis = redis_client
        self.quota_manager = quota_manager
        self.running = False
        self.monitor_thread = None

        # Prometheus指标
        self.memory_usage_gauge = Gauge(
            'redis_tenant_memory_usage_bytes',
            'Memory usage by tenant',
            ['tenant_id']
        )
        self.memory_quota_gauge = Gauge(
            'redis_tenant_memory_quota_bytes',
            'Memory quota by tenant',
            ['tenant_id']
        )
        self.memory_usage_percent_gauge = Gauge(
            'redis_tenant_memory_usage_percent',
            'Memory usage percentage by tenant',
            ['tenant_id']
        )

    def start_monitoring(self, interval=60):
        """启动监控"""
        self.running = True
        self.monitor_thread = threading.Thread(
            target=self._monitor_loop,
            args=(interval,),
            daemon=True
        )
        self.monitor_thread.start()

    def stop_monitoring(self):
        """停止监控"""
        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join()

    def _monitor_loop(self, interval):
        """监控循环"""
        while self.running:
            try:
                self.collect_metrics()
                time.sleep(interval)
            except Exception as e:
                print(f"Monitoring error: {e}")
                time.sleep(interval)

    def collect_metrics(self):
        """采集指标"""
        # 获取所有租户
        tenants = self.quota_manager.redis.hgetall(self.quota_manager.quota_key)

        for tenant_id in tenants.keys():
            quota = self.quota_manager.get_quota(tenant_id)
            usage = self.quota_manager.get_usage(tenant_id)

            # 更新Prometheus指标
            self.memory_usage_gauge.labels(tenant_id=tenant_id).set(usage)
            if quota:
                self.memory_quota_gauge.labels(tenant_id=tenant_id).set(quota)
                usage_percent = (usage / quota) * 100
                self.memory_usage_percent_gauge.labels(tenant_id=tenant_id).set(usage_percent)

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
quota_manager = MemoryQuotaManager(redis_client)
monitor = MemoryMonitor(redis_client, quota_manager)

# 启动监控
monitor.start_monitoring(interval=60)
```

### 2.3 内存超限处理

**内存超限处理器**：

```python
#!/usr/bin/env python3
# memory-overlimit-handler.py

import redis
import logging
from typing import Callable, Optional

class MemoryOverlimitHandler:
    """内存超限处理器"""

    def __init__(self, redis_client, quota_manager):
        self.redis = redis_client
        self.quota_manager = quota_manager
        self.handlers = {}  # tenant_id -> handler_function
        self.logger = logging.getLogger(__name__)

    def register_handler(self, tenant_id, handler: Callable):
        """注册超限处理函数"""
        self.handlers[tenant_id] = handler

    def check_and_handle(self, tenant_id, additional_memory: int = 0):
        """检查并处理超限"""
        allowed, info = self.quota_manager.check_quota(tenant_id, additional_memory)

        if not allowed:
            self.logger.warning(
                f"Tenant {tenant_id} memory quota exceeded: "
                f"{info['usage_percent']:.2f}% used"
            )

            # 执行处理函数
            if tenant_id in self.handlers:
                self.handlers[tenant_id](info)
            else:
                # 默认处理：拒绝操作
                raise MemoryQuotaExceededError(
                    f"Memory quota exceeded for tenant {tenant_id}"
                )

        return allowed, info

    def handle_overlimit_default(self, tenant_id, info):
        """默认超限处理"""
        # 1. 清理过期键
        self.cleanup_expired_keys(tenant_id)

        # 2. 清理LRU键
        if info['usage_percent'] > 95:
            self.cleanup_lru_keys(tenant_id)

        # 3. 发送告警
        self.send_alert(tenant_id, info)

    def cleanup_expired_keys(self, tenant_id):
        """清理过期键"""
        # 实现清理逻辑
        pass

    def cleanup_lru_keys(self, tenant_id):
        """清理LRU键"""
        # 实现清理逻辑
        pass

    def send_alert(self, tenant_id, info):
        """发送告警"""
        # 实现告警逻辑
        pass

class MemoryQuotaExceededError(Exception):
    pass

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
quota_manager = MemoryQuotaManager(redis_client)
handler = MemoryOverlimitHandler(redis_client, quota_manager)

# 注册处理函数
handler.register_handler('tenant1', handler.handle_overlimit_default)

# 检查并处理
allowed, info = handler.check_and_handle('tenant1', 100 * 1024 * 1024)
```

---

## 3. CPU隔离

### 3.1 CPU配额管理

**CPU配额管理器**：

```python
#!/usr/bin/env python3
# cpu-quota-manager.py

import redis
import subprocess
import os

class CPUQuotaManager:
    """CPU配额管理器"""

    def __init__(self):
        self.tenant_cpu_map = {}  # tenant_id -> cpu_limit

    def set_cpu_quota(self, tenant_id, cpu_limit: float):
        """设置CPU配额（0.0-1.0表示CPU核心数）"""
        self.tenant_cpu_map[tenant_id] = cpu_limit

        # 使用cgroup设置CPU限制
        self.set_cgroup_cpu_limit(tenant_id, cpu_limit)

    def set_cgroup_cpu_limit(self, tenant_id, cpu_limit: float):
        """使用cgroup设置CPU限制"""
        cgroup_path = f"/sys/fs/cgroup/cpu/tenant-{tenant_id}"

        # 创建cgroup目录
        os.makedirs(cgroup_path, exist_ok=True)

        # 设置CPU配额（以微秒为单位）
        # cpu.cfs_quota_us = cpu_limit * cpu.cfs_period_us
        period_us = 100000  # 100ms
        quota_us = int(cpu_limit * period_us)

        with open(f"{cgroup_path}/cpu.cfs_period_us", 'w') as f:
            f.write(str(period_us))

        with open(f"{cgroup_path}/cpu.cfs_quota_us", 'w') as f:
            f.write(str(quota_us))

    def assign_process_to_cgroup(self, tenant_id, pid: int):
        """将进程分配到cgroup"""
        cgroup_path = f"/sys/fs/cgroup/cpu/tenant-{tenant_id}"

        with open(f"{cgroup_path}/cgroup.procs", 'w') as f:
            f.write(str(pid))

    def get_cpu_usage(self, tenant_id) -> float:
        """获取CPU使用率"""
        cgroup_path = f"/sys/fs/cgroup/cpu/tenant-{tenant_id}"

        try:
            with open(f"{cgroup_path}/cpuacct.usage", 'r') as f:
                usage_ns = int(f.read().strip())

            # 计算CPU使用率（需要时间间隔）
            # 这里简化处理
            return 0.0
        except:
            return 0.0

# 使用示例
cpu_manager = CPUQuotaManager()

# 设置CPU配额
cpu_manager.set_cpu_quota('tenant1', 0.5)  # 0.5核心
cpu_manager.set_cpu_quota('tenant2', 1.0)  # 1.0核心

# 分配进程
import os
pid = os.getpid()
cpu_manager.assign_process_to_cgroup('tenant1', pid)
```

### 3.2 CPU使用监控

**CPU监控器**：

```python
#!/usr/bin/env python3
# cpu-monitor.py

import time
import psutil
from prometheus_client import Gauge
from typing import Dict

class CPUMonitor:
    """CPU监控器"""

    def __init__(self):
        self.cpu_usage_gauge = Gauge(
            'redis_tenant_cpu_usage_percent',
            'CPU usage by tenant',
            ['tenant_id']
        )
        self.tenant_processes = {}  # tenant_id -> [pids]

    def register_tenant_process(self, tenant_id, pid: int):
        """注册租户进程"""
        if tenant_id not in self.tenant_processes:
            self.tenant_processes[tenant_id] = []
        self.tenant_processes[tenant_id].append(pid)

    def get_tenant_cpu_usage(self, tenant_id) -> float:
        """获取租户CPU使用率"""
        if tenant_id not in self.tenant_processes:
            return 0.0

        total_cpu = 0.0
        for pid in self.tenant_processes[tenant_id]:
            try:
                process = psutil.Process(pid)
                cpu_percent = process.cpu_percent(interval=1)
                total_cpu += cpu_percent
            except:
                pass

        return total_cpu

    def collect_metrics(self):
        """采集指标"""
        for tenant_id in self.tenant_processes.keys():
            cpu_usage = self.get_tenant_cpu_usage(tenant_id)
            self.cpu_usage_gauge.labels(tenant_id=tenant_id).set(cpu_usage)

# 使用示例
monitor = CPUMonitor()

# 注册租户进程
monitor.register_tenant_process('tenant1', 12345)
monitor.register_tenant_process('tenant2', 12346)

# 采集指标
monitor.collect_metrics()
```

### 3.3 CPU限制实现

**CPU限制实现（Docker）**：

```yaml
# docker-compose.yml
version: '3.8'
services:
  redis-tenant1:
    image: redis:7.2
    container_name: redis-tenant1
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 1G
        reservations:
          cpus: '0.25'
          memory: 512M

  redis-tenant2:
    image: redis:7.2
    container_name: redis-tenant2
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 2G
        reservations:
          cpus: '0.5'
          memory: 1G
```

**CPU限制实现（Kubernetes）**：

```yaml
# redis-tenant-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-tenant1
spec:
  template:
    spec:
      containers:
      - name: redis
        image: redis:7.2
        resources:
          limits:
            cpu: "500m"
            memory: "1Gi"
          requests:
            cpu: "250m"
            memory: "512Mi"
```

---

## 4. 网络隔离

### 4.1 带宽限制

**带宽限制实现（tc）**：

```bash
#!/bin/bash
# bandwidth-limit.sh

TENANT_ID="$1"
BANDWIDTH_MBPS="$2"
INTERFACE="eth0"

# 创建HTB队列
tc qdisc add dev $INTERFACE root handle 1: htb default 30

# 创建租户类
tc class add dev $INTERFACE \
    parent 1: \
    classid 1:${TENANT_ID} \
    htb rate ${BANDWIDTH_MBPS}mbps \
    ceil ${BANDWIDTH_MBPS}mbps

# 标记租户流量
iptables -t mangle -A OUTPUT \
    -m owner --uid-owner redis-${TENANT_ID} \
    -j MARK --set-mark ${TENANT_ID}

# 将标记的流量分配到对应类
tc filter add dev $INTERFACE \
    protocol ip \
    parent 1:0 \
    prio 1 \
    handle ${TENANT_ID} fw \
    flowid 1:${TENANT_ID}
```

**带宽限制实现（Python）**：

```python
#!/usr/bin/env python3
# bandwidth-limiter.py

import subprocess
from typing import Dict

class BandwidthLimiter:
    """带宽限制器"""

    def __init__(self, interface='eth0'):
        self.interface = interface
        self.tenant_limits = {}  # tenant_id -> bandwidth_mbps

    def set_bandwidth_limit(self, tenant_id, bandwidth_mbps: int):
        """设置带宽限制"""
        self.tenant_limits[tenant_id] = bandwidth_mbps

        # 使用tc设置带宽限制
        self._setup_tc_limit(tenant_id, bandwidth_mbps)

    def _setup_tc_limit(self, tenant_id, bandwidth_mbps: int):
        """设置tc带宽限制"""
        # 创建HTB队列（如果不存在）
        subprocess.run([
            'tc', 'qdisc', 'add', 'dev', self.interface,
            'root', 'handle', '1:', 'htb', 'default', '30'
        ], check=False)

        # 创建租户类
        subprocess.run([
            'tc', 'class', 'add', 'dev', self.interface,
            'parent', '1:',
            'classid', f'1:{tenant_id}',
            'htb', 'rate', f'{bandwidth_mbps}mbps',
            'ceil', f'{bandwidth_mbps}mbps'
        ], check=False)

        # 标记流量
        subprocess.run([
            'iptables', '-t', 'mangle', '-A', 'OUTPUT',
            '-m', 'owner', '--uid-owner', f'redis-{tenant_id}',
            '-j', 'MARK', '--set-mark', str(tenant_id)
        ], check=False)

        # 分配流量
        subprocess.run([
            'tc', 'filter', 'add', 'dev', self.interface,
            'protocol', 'ip',
            'parent', '1:0',
            'prio', '1',
            'handle', str(tenant_id), 'fw',
            'flowid', f'1:{tenant_id}'
        ], check=False)

# 使用示例
limiter = BandwidthLimiter()

# 设置带宽限制
limiter.set_bandwidth_limit('tenant1', 100)  # 100 Mbps
limiter.set_bandwidth_limit('tenant2', 200)  # 200 Mbps
```

### 4.2 连接数限制

见8.2节。

### 4.3 网络QoS

**网络QoS配置**：

```bash
#!/bin/bash
# network-qos.sh

# 为租户设置网络QoS
TENANT_ID="$1"
PRIORITY="$2"  # 0-7, 0最高优先级

# 设置DSCP标记
iptables -t mangle -A OUTPUT \
    -m owner --uid-owner redis-${TENANT_ID} \
    -j DSCP --set-dscp-class ${PRIORITY}
```

---

## 5. 存储隔离

### 5.1 存储配额管理

**存储配额管理器**：

```python
#!/usr/bin/env python3
# storage-quota-manager.py

import os
import redis
from typing import Optional

class StorageQuotaManager:
    """存储配额管理器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.quota_key = "tenant:storage:quota"
        self.usage_key = "tenant:storage:usage"
        self.tenant_storage_map = {}  # tenant_id -> storage_path

    def set_storage_path(self, tenant_id, storage_path: str):
        """设置存储路径"""
        self.tenant_storage_map[tenant_id] = storage_path
        os.makedirs(storage_path, exist_ok=True)

    def set_quota(self, tenant_id, quota_gb: int):
        """设置存储配额"""
        quota_bytes = quota_gb * 1024 * 1024 * 1024
        self.redis.hset(self.quota_key, tenant_id, quota_bytes)

    def get_quota(self, tenant_id) -> Optional[int]:
        """获取存储配额（字节）"""
        quota_bytes = self.redis.hget(self.quota_key, tenant_id)
        return int(quota_bytes) if quota_bytes else None

    def get_usage(self, tenant_id) -> int:
        """获取存储使用量（字节）"""
        if tenant_id not in self.tenant_storage_map:
            return 0

        storage_path = self.tenant_storage_map[tenant_id]
        total_size = 0

        for dirpath, dirnames, filenames in os.walk(storage_path):
            for filename in filenames:
                filepath = os.path.join(dirpath, filename)
                try:
                    total_size += os.path.getsize(filepath)
                except:
                    pass

        # 更新使用量
        self.redis.hset(self.usage_key, tenant_id, total_size)

        return total_size

    def check_quota(self, tenant_id, additional_bytes: int = 0) -> tuple[bool, Dict]:
        """检查存储配额"""
        quota = self.get_quota(tenant_id)
        if quota is None:
            return True, {'unlimited': True}

        current_usage = self.get_usage(tenant_id)
        total_usage = current_usage + additional_bytes

        usage_percent = (total_usage / quota) * 100

        return total_usage <= quota, {
            'quota': quota,
            'current_usage': current_usage,
            'total_usage': total_usage,
            'usage_percent': usage_percent,
            'available': quota - total_usage
        }

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
storage_manager = StorageQuotaManager(redis_client)

# 设置存储路径
storage_manager.set_storage_path('tenant1', '/data/redis/tenant1')
storage_manager.set_storage_path('tenant2', '/data/redis/tenant2')

# 设置配额
storage_manager.set_quota('tenant1', 100)  # 100GB
storage_manager.set_quota('tenant2', 200)  # 200GB

# 检查配额
allowed, info = storage_manager.check_quota('tenant1', 10 * 1024 * 1024 * 1024)
```

### 5.2 存储使用监控

**存储监控器**：

```python
#!/usr/bin/env python3
# storage-monitor.py

import time
import threading
from prometheus_client import Gauge
from storage_quota_manager import StorageQuotaManager

class StorageMonitor:
    """存储监控器"""

    def __init__(self, storage_manager: StorageQuotaManager):
        self.storage_manager = storage_manager
        self.running = False

        # Prometheus指标
        self.storage_usage_gauge = Gauge(
            'redis_tenant_storage_usage_bytes',
            'Storage usage by tenant',
            ['tenant_id']
        )
        self.storage_quota_gauge = Gauge(
            'redis_tenant_storage_quota_bytes',
            'Storage quota by tenant',
            ['tenant_id']
        )

    def start_monitoring(self, interval=300):
        """启动监控"""
        self.running = True
        monitor_thread = threading.Thread(
            target=self._monitor_loop,
            args=(interval,),
            daemon=True
        )
        monitor_thread.start()

    def _monitor_loop(self, interval):
        """监控循环"""
        while self.running:
            try:
                self.collect_metrics()
                time.sleep(interval)
            except Exception as e:
                print(f"Storage monitoring error: {e}")
                time.sleep(interval)

    def collect_metrics(self):
        """采集指标"""
        tenants = self.storage_manager.redis.hgetall(
            self.storage_manager.quota_key
        )

        for tenant_id in tenants.keys():
            quota = self.storage_manager.get_quota(tenant_id)
            usage = self.storage_manager.get_usage(tenant_id)

            self.storage_usage_gauge.labels(tenant_id=tenant_id).set(usage)
            if quota:
                self.storage_quota_gauge.labels(tenant_id=tenant_id).set(quota)
```

### 5.3 存储清理策略

**存储清理器**：

```python
#!/usr/bin/env python3
# storage-cleaner.py

import redis
import os
import time
from datetime import datetime, timedelta

class StorageCleaner:
    """存储清理器"""

    def __init__(self, redis_client, storage_manager):
        self.redis = redis_client
        self.storage_manager = storage_manager

    def cleanup_old_backups(self, tenant_id, retention_days=30):
        """清理旧备份"""
        storage_path = self.storage_manager.tenant_storage_map.get(tenant_id)
        if not storage_path:
            return

        backup_dir = os.path.join(storage_path, 'backups')
        if not os.path.exists(backup_dir):
            return

        cutoff_time = time.time() - (retention_days * 24 * 3600)

        for filename in os.listdir(backup_dir):
            filepath = os.path.join(backup_dir, filename)
            if os.path.isfile(filepath):
                if os.path.getmtime(filepath) < cutoff_time:
                    os.remove(filepath)
                    print(f"Deleted old backup: {filepath}")

    def cleanup_old_logs(self, tenant_id, retention_days=7):
        """清理旧日志"""
        storage_path = self.storage_manager.tenant_storage_map.get(tenant_id)
        if not storage_path:
            return

        log_dir = os.path.join(storage_path, 'logs')
        if not os.path.exists(log_dir):
            return

        cutoff_time = time.time() - (retention_days * 24 * 3600)

        for filename in os.listdir(log_dir):
            filepath = os.path.join(log_dir, filename)
            if os.path.isfile(filepath):
                if os.path.getmtime(filepath) < cutoff_time:
                    os.remove(filepath)
                    print(f"Deleted old log: {filepath}")

    def cleanup_when_over_quota(self, tenant_id):
        """配额超限时清理"""
        allowed, info = self.storage_manager.check_quota(tenant_id)

        if not allowed:
            # 清理旧备份
            self.cleanup_old_backups(tenant_id, retention_days=7)

            # 清理旧日志
            self.cleanup_old_logs(tenant_id, retention_days=3)

            # 如果仍然超限，清理更多数据
            allowed, info = self.storage_manager.check_quota(tenant_id)
            if not allowed:
                self.cleanup_old_backups(tenant_id, retention_days=1)

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
storage_manager = StorageQuotaManager(redis_client)
cleaner = StorageCleaner(redis_client, storage_manager)

# 清理旧数据
cleaner.cleanup_old_backups('tenant1', retention_days=30)
cleaner.cleanup_old_logs('tenant1', retention_days=7)

# 配额超限清理
cleaner.cleanup_when_over_quota('tenant1')
```

---

## 6. 性能隔离

### 6.1 QPS隔离

**QPS限制器（Redis实现）**：

```python
#!/usr/bin/env python3
# qps-limiter-redis.py

import redis
import time
from typing import Optional

class RedisQPSLimiter:
    """基于Redis的QPS限制器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.quota_key_prefix = "tenant:qps:quota:"
        self.usage_key_prefix = "tenant:qps:usage:"

    def set_qps_limit(self, tenant_id, qps_limit: int):
        """设置QPS限制"""
        self.redis.set(f"{self.quota_key_prefix}{tenant_id}", qps_limit)

    def check_qps(self, tenant_id) -> bool:
        """检查QPS限制"""
        qps_limit = self.redis.get(f"{self.quota_key_prefix}{tenant_id}")
        if not qps_limit:
            return True  # 无限制

        qps_limit = int(qps_limit)
        current_time = int(time.time())
        usage_key = f"{self.usage_key_prefix}{tenant_id}:{current_time}"

        # 使用滑动窗口计数
        current_count = self.redis.incr(usage_key)
        self.redis.expire(usage_key, 2)  # 2秒过期

        return current_count <= qps_limit

    def get_current_qps(self, tenant_id) -> int:
        """获取当前QPS"""
        current_time = int(time.time())
        usage_key = f"{self.usage_key_prefix}{tenant_id}:{current_time}"
        return int(self.redis.get(usage_key) or 0)

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
qps_limiter = RedisQPSLimiter(redis_client)

# 设置QPS限制
qps_limiter.set_qps_limit('tenant1', 1000)
qps_limiter.set_qps_limit('tenant2', 5000)

# 检查QPS
if qps_limiter.check_qps('tenant1'):
    # 允许请求
    pass
else:
    # 拒绝请求
    raise QPSLimitExceededError("QPS limit exceeded")
```

**QPS限制器（Token Bucket）**：

```python
#!/usr/bin/env python3
# token-bucket-limiter.py

import redis
import time

class TokenBucketLimiter:
    """令牌桶QPS限制器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.bucket_key_prefix = "tenant:token_bucket:"

    def set_qps_limit(self, tenant_id, qps_limit: int, burst_size: int = None):
        """设置QPS限制"""
        if burst_size is None:
            burst_size = qps_limit * 2

        bucket_key = f"{self.bucket_key_prefix}{tenant_id}"

        # 存储配置
        config = {
            'qps_limit': qps_limit,
            'burst_size': burst_size,
            'last_refill': time.time(),
            'tokens': burst_size
        }

        self.redis.hset(bucket_key, mapping={
            'qps_limit': qps_limit,
            'burst_size': burst_size,
            'last_refill': time.time(),
            'tokens': burst_size
        })

    def consume_token(self, tenant_id, tokens: int = 1) -> bool:
        """消耗令牌"""
        bucket_key = f"{self.bucket_key_prefix}{tenant_id}"

        # 使用Lua脚本原子操作
        lua_script = """
        local bucket_key = KEYS[1]
        local tokens_to_consume = tonumber(ARGV[1])
        local current_time = tonumber(ARGV[2])

        local qps_limit = tonumber(redis.call('HGET', bucket_key, 'qps_limit'))
        local burst_size = tonumber(redis.call('HGET', bucket_key, 'burst_size'))
        local last_refill = tonumber(redis.call('HGET', bucket_key, 'last_refill'))
        local tokens = tonumber(redis.call('HGET', bucket_key, 'tokens'))

        -- 计算需要补充的令牌数
        local time_passed = current_time - last_refill
        local tokens_to_add = math.floor(time_passed * qps_limit)

        -- 补充令牌
        tokens = math.min(burst_size, tokens + tokens_to_add)

        -- 消耗令牌
        if tokens >= tokens_to_consume then
            tokens = tokens - tokens_to_consume
            redis.call('HSET', bucket_key, 'tokens', tokens)
            redis.call('HSET', bucket_key, 'last_refill', current_time)
            return 1
        else
            redis.call('HSET', bucket_key, 'tokens', tokens)
            redis.call('HSET', bucket_key, 'last_refill', current_time)
            return 0
        end
        """

        result = self.redis.eval(
            lua_script,
            1,
            bucket_key,
            tokens,
            time.time()
        )

        return bool(result)

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
limiter = TokenBucketLimiter(redis_client)

# 设置QPS限制
limiter.set_qps_limit('tenant1', 1000, burst_size=2000)

# 消耗令牌
if limiter.consume_token('tenant1', tokens=1):
    # 允许请求
    pass
else:
    # 拒绝请求
    raise QPSLimitExceededError("QPS limit exceeded")
```

### 6.2 延迟隔离

见8.4节。

### 6.3 吞吐量隔离

**吞吐量限制器**：

```python
#!/usr/bin/env python3
# throughput-limiter.py

import redis
import time

class ThroughputLimiter:
    """吞吐量限制器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.quota_key_prefix = "tenant:throughput:quota:"
        self.usage_key_prefix = "tenant:throughput:usage:"

    def set_throughput_limit(self, tenant_id, throughput_mbps: float):
        """设置吞吐量限制（MB/s）"""
        throughput_bytes_per_sec = throughput_mbps * 1024 * 1024
        self.redis.set(f"{self.quota_key_prefix}{tenant_id}", throughput_bytes_per_sec)

    def check_throughput(self, tenant_id, data_size: int) -> bool:
        """检查吞吐量限制"""
        limit_bytes_per_sec = self.redis.get(f"{self.quota_key_prefix}{tenant_id}")
        if not limit_bytes_per_sec:
            return True  # 无限制

        limit_bytes_per_sec = float(limit_bytes_per_sec)
        current_time = time.time()
        window_start = int(current_time)

        # 计算当前窗口的吞吐量
        usage_key = f"{self.usage_key_prefix}{tenant_id}:{window_start}"
        current_usage = int(self.redis.get(usage_key) or 0)

        # 检查是否超限
        if current_usage + data_size > limit_bytes_per_sec:
            return False

        # 更新使用量
        self.redis.incrby(usage_key, data_size)
        self.redis.expire(usage_key, 2)

        return True

    def wait_if_needed(self, tenant_id, data_size: int):
        """如果需要，等待"""
        while not self.check_throughput(tenant_id, data_size):
            time.sleep(0.1)

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
limiter = ThroughputLimiter(redis_client)

# 设置吞吐量限制
limiter.set_throughput_limit('tenant1', 100.0)  # 100 MB/s
limiter.set_throughput_limit('tenant2', 200.0)  # 200 MB/s

# 检查吞吐量
data_size = 1024 * 1024  # 1MB
if limiter.check_throughput('tenant1', data_size):
    # 允许传输
    pass
else:
    # 等待或拒绝
    limiter.wait_if_needed('tenant1', data_size)
```

---

## 7. 资源配额系统

### 7.1 配额配置

**统一配额配置**：

```python
#!/usr/bin/env python3
# unified-quota-manager.py

import redis
import json
from typing import Dict, Optional

class UnifiedQuotaManager:
    """统一配额管理器"""

    def __init__(self, redis_client):
        self.redis = redis_client
        self.quota_config_key = "tenant:quota:config"

    def set_quota_config(self, tenant_id, quota_config: Dict):
        """设置配额配置"""
        self.redis.hset(
            self.quota_config_key,
            tenant_id,
            json.dumps(quota_config)
        )

    def get_quota_config(self, tenant_id) -> Optional[Dict]:
        """获取配额配置"""
        config_json = self.redis.hget(self.quota_config_key, tenant_id)
        if config_json:
            return json.loads(config_json)
        return None

    def check_all_quotas(self, tenant_id, resource_usage: Dict) -> tuple[bool, Dict]:
        """检查所有配额"""
        config = self.get_quota_config(tenant_id)
        if not config:
            return True, {'unlimited': True}

        results = {}
        all_passed = True

        for resource, usage in resource_usage.items():
            quota = config.get(resource)
            if quota is None:
                results[resource] = {'unlimited': True}
                continue

            passed = usage <= quota
            results[resource] = {
                'quota': quota,
                'usage': usage,
                'passed': passed,
                'usage_percent': (usage / quota) * 100 if quota > 0 else 0
            }

            if not passed:
                all_passed = False

        return all_passed, results

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
quota_manager = UnifiedQuotaManager(redis_client)

# 设置配额配置
quota_manager.set_quota_config('tenant1', {
    'memory_mb': 1024,
    'cpu_cores': 0.5,
    'qps': 10000,
    'connections': 1000,
    'bandwidth_mbps': 100,
    'storage_gb': 100
})

# 检查配额
resource_usage = {
    'memory_mb': 800,
    'cpu_cores': 0.4,
    'qps': 5000,
    'connections': 500,
    'bandwidth_mbps': 50,
    'storage_gb': 80
}

passed, results = quota_manager.check_all_quotas('tenant1', resource_usage)
```

### 7.2 配额检查

见7.1节。

### 7.3 配额动态调整

**配额动态调整器**：

```python
#!/usr/bin/env python3
# dynamic-quota-adjuster.py

import redis
import time
from typing import Dict

class DynamicQuotaAdjuster:
    """动态配额调整器"""

    def __init__(self, quota_manager: UnifiedQuotaManager):
        self.quota_manager = quota_manager
        self.usage_history = {}  # tenant_id -> [usage_history]

    def record_usage(self, tenant_id, resource_usage: Dict):
        """记录使用量"""
        if tenant_id not in self.usage_history:
            self.usage_history[tenant_id] = []

        usage_record = {
            'timestamp': time.time(),
            'usage': resource_usage
        }

        self.usage_history[tenant_id].append(usage_record)

        # 保留最近24小时的数据
        cutoff_time = time.time() - 24 * 3600
        self.usage_history[tenant_id] = [
            record for record in self.usage_history[tenant_id]
            if record['timestamp'] > cutoff_time
        ]

    def analyze_and_adjust(self, tenant_id):
        """分析并调整配额"""
        if tenant_id not in self.usage_history:
            return

        history = self.usage_history[tenant_id]
        if len(history) < 100:
            return  # 数据不足

        # 分析使用趋势
        current_config = self.quota_manager.get_quota_config(tenant_id)
        if not current_config:
            return

        adjustments = {}

        for resource in current_config.keys():
            usage_values = [record['usage'].get(resource, 0) for record in history]
            if not usage_values:
                continue

            avg_usage = sum(usage_values) / len(usage_values)
            max_usage = max(usage_values)
            current_quota = current_config[resource]

            # 如果平均使用率超过80%，建议增加配额
            if avg_usage / current_quota > 0.8:
                suggested_quota = int(max_usage * 1.2)  # 增加20%余量
                adjustments[resource] = suggested_quota

        return adjustments

    def auto_adjust(self, tenant_id, auto_apply=False):
        """自动调整配额"""
        adjustments = self.analyze_and_adjust(tenant_id)
        if not adjustments:
            return None

        if auto_apply:
            current_config = self.quota_manager.get_quota_config(tenant_id)
            current_config.update(adjustments)
            self.quota_manager.set_quota_config(tenant_id, current_config)

        return adjustments

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)
quota_manager = UnifiedQuotaManager(redis_client)
adjuster = DynamicQuotaAdjuster(quota_manager)

# 记录使用量
adjuster.record_usage('tenant1', {
    'memory_mb': 800,
    'qps': 5000
})

# 分析并调整
adjustments = adjuster.auto_adjust('tenant1', auto_apply=False)
if adjustments:
    print(f"Suggested adjustments: {adjustments}")
```

---

## 8. 资源监控与告警

### 8.1 资源使用监控

**统一资源监控器**：

```python
#!/usr/bin/env python3
# unified-resource-monitor.py

import time
import threading
from prometheus_client import Gauge, Counter
from unified_quota_manager import UnifiedQuotaManager

class UnifiedResourceMonitor:
    """统一资源监控器"""

    def __init__(self, quota_manager: UnifiedQuotaManager):
        self.quota_manager = quota_manager
        self.running = False

        # Prometheus指标
        self.resource_usage_gauges = {}
        self.resource_quota_gauges = {}
        self.resource_usage_percent_gauges = {}
        self.quota_violations_counter = Counter(
            'redis_tenant_quota_violations_total',
            'Quota violations by tenant and resource',
            ['tenant_id', 'resource']
        )

    def _init_gauges(self, resources):
        """初始化指标"""
        for resource in resources:
            self.resource_usage_gauges[resource] = Gauge(
                f'redis_tenant_{resource}_usage',
                f'{resource} usage by tenant',
                ['tenant_id']
            )
            self.resource_quota_gauges[resource] = Gauge(
                f'redis_tenant_{resource}_quota',
                f'{resource} quota by tenant',
                ['tenant_id']
            )
            self.resource_usage_percent_gauges[resource] = Gauge(
                f'redis_tenant_{resource}_usage_percent',
                f'{resource} usage percentage by tenant',
                ['tenant_id']
            )

    def start_monitoring(self, interval=60):
        """启动监控"""
        self.running = True
        monitor_thread = threading.Thread(
            target=self._monitor_loop,
            args=(interval,),
            daemon=True
        )
        monitor_thread.start()

    def _monitor_loop(self, interval):
        """监控循环"""
        while self.running:
            try:
                self.collect_metrics()
                time.sleep(interval)
            except Exception as e:
                print(f"Monitoring error: {e}")
                time.sleep(interval)

    def collect_metrics(self):
        """采集指标"""
        # 获取所有租户
        tenants = self.quota_manager.redis.hgetall(
            self.quota_manager.quota_config_key
        )

        for tenant_id in tenants.keys():
            config = self.quota_manager.get_quota_config(tenant_id)
            if not config:
                continue

            # 获取实际使用量（需要实现）
            usage = self.get_tenant_usage(tenant_id)

            # 更新指标
            for resource in config.keys():
                quota = config[resource]
                resource_usage = usage.get(resource, 0)

                if resource in self.resource_usage_gauges:
                    self.resource_usage_gauges[resource].labels(
                        tenant_id=tenant_id
                    ).set(resource_usage)

                if resource in self.resource_quota_gauges:
                    self.resource_quota_gauges[resource].labels(
                        tenant_id=tenant_id
                    ).set(quota)

                if resource in self.resource_usage_percent_gauges:
                    usage_percent = (resource_usage / quota) * 100 if quota > 0 else 0
                    self.resource_usage_percent_gauges[resource].labels(
                        tenant_id=tenant_id
                    ).set(usage_percent)

                # 检查配额违反
                if resource_usage > quota:
                    self.quota_violations_counter.labels(
                        tenant_id=tenant_id,
                        resource=resource
                    ).inc()

    def get_tenant_usage(self, tenant_id) -> Dict:
        """获取租户使用量"""
        # 实现获取使用量逻辑
        return {}
```

### 8.2 配额使用告警

**配额告警规则**：

```yaml
# quota-alerts.yml
groups:
  - name: tenant_quota_alerts
    interval: 30s
    rules:
      # 内存使用率告警
      - alert: TenantHighMemoryUsage
        expr: |
          redis_tenant_memory_usage_percent > 80
        for: 5m
        labels:
          severity: warning
          team: platform
        annotations:
          summary: "High memory usage for tenant {{ $labels.tenant_id }}"
          description: "Memory usage is {{ $value }}% for tenant {{ $labels.tenant_id }}"

      # 内存使用率临界告警
      - alert: TenantCriticalMemoryUsage
        expr: |
          redis_tenant_memory_usage_percent > 95
        for: 2m
        labels:
          severity: critical
          team: platform
        annotations:
          summary: "Critical memory usage for tenant {{ $labels.tenant_id }}"
          description: "Memory usage is {{ $value }}% for tenant {{ $labels.tenant_id }}"

      # QPS使用率告警
      - alert: TenantHighQPSUsage
        expr: |
          redis_tenant_qps_usage_percent > 80
        for: 5m
        labels:
          severity: warning
          team: platform
        annotations:
          summary: "High QPS usage for tenant {{ $labels.tenant_id }}"
          description: "QPS usage is {{ $value }}% for tenant {{ $labels.tenant_id }}"

      # 配额违反告警
      - alert: TenantQuotaViolation
        expr: |
          increase(redis_tenant_quota_violations_total[5m]) > 0
        for: 1m
        labels:
          severity: critical
          team: platform
        annotations:
          summary: "Quota violation for tenant {{ $labels.tenant_id }}"
          description: "Resource {{ $labels.resource }} quota violated for tenant {{ $labels.tenant_id }}"
```

### 8.3 资源超限告警

#### 8.3.1 告警系统实现

```python
#!/usr/bin/env python3
# resource-alert-system.py

import redis
from redis.cluster import RedisCluster
from datetime import datetime
import smtplib
from email.mime.text import MIMEText
from typing import Dict, List

class ResourceAlertSystem:
    """资源告警系统"""

    def __init__(self, redis_cluster_nodes, alert_thresholds=None):
        self.cluster = RedisCluster(
            startup_nodes=redis_cluster_nodes,
            decode_responses=True,
            skip_full_coverage_check=True
        )
        self.alert_thresholds = alert_thresholds or {
            'memory_warning': 0.8,  # 80%
            'memory_critical': 0.95,  # 95%
            'qps_warning': 0.8,
            'qps_critical': 0.95
        }
        self.alert_history = []

    def check_tenant_alerts(self, tenant_id):
        """检查租户告警"""
        alerts = []

        # 获取租户资源使用
        usage = self._get_tenant_usage(tenant_id)
        if not usage:
            return alerts

        # 获取租户配额
        quota = self._get_tenant_quota(tenant_id)
        if not quota:
            return alerts

        # 检查内存告警
        memory_usage_ratio = usage['memory_used'] / quota['memory_quota'] if quota['memory_quota'] > 0 else 0

        if memory_usage_ratio >= self.alert_thresholds['memory_critical']:
            alerts.append({
                'tenant_id': tenant_id,
                'type': 'memory_critical',
                'severity': 'critical',
                'usage_ratio': memory_usage_ratio,
                'message': f"内存使用率 {memory_usage_ratio*100:.2f}% 超过临界阈值"
            })
        elif memory_usage_ratio >= self.alert_thresholds['memory_warning']:
            alerts.append({
                'tenant_id': tenant_id,
                'type': 'memory_warning',
                'severity': 'warning',
                'usage_ratio': memory_usage_ratio,
                'message': f"内存使用率 {memory_usage_ratio*100:.2f}% 超过警告阈值"
            })

        # 检查QPS告警
        qps_usage_ratio = usage['qps'] / quota['qps_limit'] if quota['qps_limit'] > 0 else 0

        if qps_usage_ratio >= self.alert_thresholds['qps_critical']:
            alerts.append({
                'tenant_id': tenant_id,
                'type': 'qps_critical',
                'severity': 'critical',
                'usage_ratio': qps_usage_ratio,
                'message': f"QPS使用率 {qps_usage_ratio*100:.2f}% 超过临界阈值"
            })
        elif qps_usage_ratio >= self.alert_thresholds['qps_warning']:
            alerts.append({
                'tenant_id': tenant_id,
                'type': 'qps_warning',
                'severity': 'warning',
                'usage_ratio': qps_usage_ratio,
                'message': f"QPS使用率 {qps_usage_ratio*100:.2f}% 超过警告阈值"
            })

        return alerts

    def check_all_tenants(self):
        """检查所有租户告警"""
        all_alerts = []

        # 获取所有租户
        tenants = self._list_all_tenants()

        for tenant_id in tenants:
            alerts = self.check_tenant_alerts(tenant_id)
            all_alerts.extend(alerts)

        return all_alerts

    def send_alerts(self, alerts: List[Dict]):
        """发送告警"""
        for alert in alerts:
            # 记录告警历史
            self.alert_history.append({
                **alert,
                'timestamp': datetime.utcnow().isoformat()
            })

            # 发送告警通知
            if alert['severity'] == 'critical':
                self._send_critical_alert(alert)
            else:
                self._send_warning_alert(alert)

    def _send_critical_alert(self, alert):
        """发送严重告警"""
        print(f"[CRITICAL] {alert['message']}")
        # 实现邮件/短信/钉钉等告警发送逻辑
        # self._send_email(alert)
        # self._send_sms(alert)

    def _send_warning_alert(self, alert):
        """发送警告告警"""
        print(f"[WARNING] {alert['message']}")
        # 实现告警发送逻辑

    def _get_tenant_usage(self, tenant_id):
        """获取租户资源使用"""
        # 实现获取租户资源使用的逻辑
        return {
            'memory_used': 0,
            'qps': 0
        }

    def _get_tenant_quota(self, tenant_id):
        """获取租户配额"""
        # 实现获取租户配额的逻辑
        return {
            'memory_quota': 0,
            'qps_limit': 0
        }

    def _list_all_tenants(self):
        """列出所有租户"""
        # 实现列出所有租户的逻辑
        return []

# 使用示例
if __name__ == '__main__':
    cluster_nodes = [
        {'host': '127.0.0.1', 'port': 7000}
    ]

    alert_system = ResourceAlertSystem(cluster_nodes)

    # 检查所有租户告警
    alerts = alert_system.check_all_tenants()

    # 发送告警
    if alerts:
        alert_system.send_alerts(alerts)
        print(f"发送 {len(alerts)} 个告警")
```

---

## 9. 资源隔离最佳实践

### 9.1 隔离策略选择

**隔离策略选择矩阵**：

| 租户规模 | 内存隔离 | CPU隔离 | 网络隔离 | 性能隔离 |
|---------|---------|---------|---------|---------|
| 小租户 | Key前缀 | 共享CPU | 共享带宽 | QPS限制 |
| 中租户 | 数据库隔离 | cgroup | 带宽限制 | QPS+延迟 |
| 大租户 | 独立实例 | 独立CPU | 独立网络 | 完全隔离 |

### 9.2 配额设置原则

**配额设置原则**：

1. **基于历史数据**：根据历史使用数据设置配额
2. **预留余量**：配额设置时预留20-30%余量
3. **动态调整**：根据实际使用情况动态调整
4. **分级管理**：不同规模租户设置不同配额

### 9.3 监控告警配置

**监控告警配置**：

1. **实时监控**：实时监控资源使用情况
2. **多级告警**：80%警告，95% critical
3. **自动处理**：超限时自动清理或扩容
4. **告警聚合**：相关告警聚合发送

---

## 10. 扩展阅读

- [多租户架构设计](07.08.01-多租户架构设计.md)
- [多租户运维管理](07.08.03-多租户运维管理.md)
- [集群容量规划](../07.05-集群管理/07.05.04-集群容量规划.md)

---

## 11. 权威参考

- [Redis资源限制](https://redis.io/docs/manual/configuration/)
- [Linux cgroups](https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt)

---

**文档版本**：v1.0
**最后更新**：2025-01
**文档状态**：✅ 完成（1200+行实质性内容）
