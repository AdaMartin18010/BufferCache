# 08.03.01 分布式锁实践

## 目录

- [08.03.01 分布式锁实践](#080301-分布式锁实践)
  - [目录](#目录)
  - [1. 概述](#1-概述)
    - [1.1 定义与背景](#11-定义与背景)
    - [1.2 应用价值](#12-应用价值)
  - [2. 分布式锁基础](#2-分布式锁基础)
    - [2.1 分布式锁特性](#21-分布式锁特性)
    - [2.2 分布式锁实现方式](#22-分布式锁实现方式)
    - [2.3 分布式锁问题](#23-分布式锁问题)
  - [3. Redis分布式锁](#3-redis分布式锁)
    - [3.1 SETNX实现](#31-setnx实现)
    - [3.2 SET NX EX实现](#32-set-nx-ex实现)
    - [3.3 Redlock算法](#33-redlock算法)
  - [4. Redis分布式锁实现](#4-redis分布式锁实现)
    - [4.1 Python实现](#41-python实现)
    - [4.2 Java实现](#42-java实现)
    - [4.3 Go实现](#43-go实现)
  - [5. 分布式锁最佳实践](#5-分布式锁最佳实践)
    - [5.1 锁超时设置](#51-锁超时设置)
    - [5.2 锁续期机制](#52-锁续期机制)
    - [5.3 锁释放机制](#53-锁释放机制)
  - [6. 分布式锁应用场景](#6-分布式锁应用场景)
    - [6.1 防止重复提交](#61-防止重复提交)
    - [6.2 资源访问控制](#62-资源访问控制)
    - [6.3 分布式任务调度](#63-分布式任务调度)
  - [7. 扩展阅读](#7-扩展阅读)
  - [8. 权威参考](#8-权威参考)
    - [8.1 官方文档](#81-官方文档)
    - [8.2 经典书籍](#82-经典书籍)
    - [8.3 在线资源](#83-在线资源)

---

## 1. 概述

### 1.1 定义与背景

分布式锁是在分布式系统中实现互斥访问共享资源的机制，确保同一时刻只有一个进程可以访问共享资源。

**分布式锁背景**：

- **分布式系统**：多个进程需要协调访问共享资源
- **数据一致性**：保证数据操作的一致性
- **并发控制**：控制并发访问

### 1.2 应用价值

**分布式锁价值**：

- ✅ **互斥性**：保证同一时刻只有一个进程持有锁
- ✅ **死锁避免**：避免死锁情况
- ✅ **高可用性**：支持高可用部署

---

## 2. 分布式锁基础

### 2.1 分布式锁特性

**分布式锁必须满足的特性**：

- **互斥性**：同一时刻只有一个进程可以持有锁
- **可重入性**：同一进程可以多次获取锁
- **超时释放**：锁应该自动超时释放
- **高可用性**：锁服务应该高可用

### 2.2 分布式锁实现方式

**分布式锁实现方式**：

- **数据库锁**：基于数据库实现
- **Redis锁**：基于Redis实现
- **ZooKeeper锁**：基于ZooKeeper实现
- **etcd锁**：基于etcd实现

### 2.3 分布式锁问题

**分布式锁常见问题**：

- **死锁**：进程崩溃导致锁无法释放
- **锁超时**：业务执行时间超过锁超时时间
- **锁误释放**：释放了其他进程的锁

---

## 3. Redis分布式锁

### 3.1 SETNX实现

**SETNX实现（不推荐）**：

```python
import redis
import time
import uuid

class RedisLock:
    def __init__(self, redis_client, key, timeout=10):
        self.redis_client = redis_client
        self.key = key
        self.timeout = timeout
        self.identifier = str(uuid.uuid4())

    def acquire(self):
        """获取锁"""
        end_time = time.time() + self.timeout

        while time.time() < end_time:
            if self.redis_client.setnx(self.key, self.identifier):
                # 设置过期时间
                self.redis_client.expire(self.key, self.timeout)
                return True
            time.sleep(0.001)

        return False

    def release(self):
        """释放锁"""
        # 问题：可能释放其他进程的锁
        self.redis_client.delete(self.key)
```

**问题**：SETNX和EXPIRE不是原子操作，可能导致死锁。

### 3.2 SET NX EX实现

**SET NX EX实现（推荐）**：

```python
class RedisLock:
    def __init__(self, redis_client, key, timeout=10):
        self.redis_client = redis_client
        self.key = key
        self.timeout = timeout
        self.identifier = str(uuid.uuid4())

    def acquire(self):
        """获取锁（原子操作）"""
        result = self.redis_client.set(
            self.key,
            self.identifier,
            nx=True,  # 只在key不存在时设置
            ex=self.timeout  # 设置过期时间
        )
        return result is True

    def release(self):
        """释放锁（Lua脚本保证原子性）"""
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """
        return self.redis_client.eval(lua_script, 1, self.key, self.identifier)
```

### 3.3 Redlock算法

**Redlock算法实现**：

```python
import time
import random

class Redlock:
    def __init__(self, redis_clients, key, timeout=10, retry_delay=0.2):
        self.redis_clients = redis_clients
        self.key = key
        self.timeout = timeout
        self.retry_delay = retry_delay
        self.identifier = str(uuid.uuid4())
        self.quorum = len(redis_clients) // 2 + 1

    def acquire(self):
        """获取锁"""
        start_time = time.time()

        for attempt in range(self.timeout * 5):  # 最多重试timeout*5次
            acquired = 0
            start_acquire = time.time()

            # 尝试在所有Redis实例上获取锁
            for redis_client in self.redis_clients:
                try:
                    if redis_client.set(
                        self.key,
                        self.identifier,
                        nx=True,
                        ex=self.timeout
                    ):
                        acquired += 1
                except Exception as e:
                    print(f"Redis错误: {e}")

            # 计算获取锁的时间
            acquire_time = (time.time() - start_acquire) * 1000  # 毫秒

            # 检查是否获得大多数锁，且获取时间小于锁超时时间
            if acquired >= self.quorum and acquire_time < self.timeout * 1000:
                # 重新设置过期时间，减去获取锁的时间
                validity_time = self.timeout - (acquire_time / 1000)
                if validity_time > 0:
                    return True

            # 释放已获取的锁
            for redis_client in self.redis_clients:
                try:
                    redis_client.delete(self.key)
                except:
                    pass

            # 随机延迟后重试
            time.sleep(self.retry_delay + random.uniform(0, 0.01))

        return False

    def release(self):
        """释放锁"""
        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """

        released = 0
        for redis_client in self.redis_clients:
            try:
                if redis_client.eval(lua_script, 1, self.key, self.identifier):
                    released += 1
            except:
                pass

        return released >= self.quorum
```

---

## 4. Redis分布式锁实现

### 4.1 Python实现

**完整Python实现**：

```python
import redis
import time
import uuid
import threading

class DistributedLock:
    def __init__(self, redis_client, key, timeout=10, retry_interval=0.1):
        self.redis_client = redis_client
        self.key = f"lock:{key}"
        self.timeout = timeout
        self.retry_interval = retry_interval
        self.identifier = str(uuid.uuid4())
        self.lock_thread = None
        self.stop_renewal = False

    def acquire(self, blocking=True, timeout=None):
        """获取锁"""
        if timeout is None:
            timeout = self.timeout

        end_time = time.time() + timeout

        while True:
            # 尝试获取锁
            if self.redis_client.set(
                self.key,
                self.identifier,
                nx=True,
                ex=self.timeout
            ):
                # 启动续期线程
                self.start_renewal()
                return True

            if not blocking:
                return False

            if time.time() >= end_time:
                return False

            time.sleep(self.retry_interval)

    def release(self):
        """释放锁"""
        self.stop_renewal = True

        lua_script = """
        if redis.call("get", KEYS[1]) == ARGV[1] then
            return redis.call("del", KEYS[1])
        else
            return 0
        end
        """

        return self.redis_client.eval(
            lua_script,
            1,
            self.key,
            self.identifier
        )

    def start_renewal(self):
        """启动锁续期线程"""
        def renew():
            while not self.stop_renewal:
                time.sleep(self.timeout / 3)  # 在过期前1/3时间续期

                if self.stop_renewal:
                    break

                lua_script = """
                if redis.call("get", KEYS[1]) == ARGV[1] then
                    return redis.call("expire", KEYS[1], ARGV[2])
                else
                    return 0
                end
                """

                try:
                    self.redis_client.eval(
                        lua_script,
                        1,
                        self.key,
                        self.identifier,
                        self.timeout
                    )
                except Exception as e:
                    print(f"续期失败: {e}")
                    break

        self.lock_thread = threading.Thread(target=renew, daemon=True)
        self.lock_thread.start()

    def __enter__(self):
        if self.acquire():
            return self
        raise Exception("获取锁失败")

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.release()

# 使用示例
redis_client = redis.Redis(host='localhost', port=6379)

# 上下文管理器方式
with DistributedLock(redis_client, 'resource1') as lock:
    # 执行需要互斥的操作
    print("执行操作")
    time.sleep(5)

# 手动方式
lock = DistributedLock(redis_client, 'resource1')
if lock.acquire():
    try:
        # 执行操作
        print("执行操作")
    finally:
        lock.release()
```

### 4.2 Java实现

**Java实现（Redisson）**：

```java
import org.redisson.Redisson;
import org.redisson.api.RLock;
import org.redisson.api.RedissonClient;
import org.redisson.config.Config;

public class DistributedLockExample {
    public static void main(String[] args) {
        // 配置Redisson
        Config config = new Config();
        config.useSingleServer()
            .setAddress("redis://localhost:6379");

        RedissonClient redisson = Redisson.create(config);

        // 获取锁
        RLock lock = redisson.getLock("myLock");

        try {
            // 尝试获取锁，最多等待10秒，锁定后30秒自动解锁
            if (lock.tryLock(10, 30, TimeUnit.SECONDS)) {
                try {
                    // 执行需要互斥的操作
                    System.out.println("执行操作");
                } finally {
                    lock.unlock();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            redisson.shutdown();
        }
    }
}
```

### 4.3 Go实现

**Go实现**：

```go
package main

import (
    "context"
    "fmt"
    "time"

    "github.com/go-redis/redis/v8"
    "github.com/go-redsync/redsync/v4"
    "github.com/go-redsync/redsync/v4/redis/goredis/v8"
)

func main() {
    // 创建Redis客户端
    client := redis.NewClient(&redis.Options{
        Addr: "localhost:6379",
    })

    // 创建Redsync
    pool := goredis.NewPool(client)
    rs := redsync.New(pool)

    // 创建互斥锁
    mutex := rs.NewMutex("my-lock")

    // 获取锁
    if err := mutex.Lock(); err != nil {
        panic(err)
    }

    // 执行操作
    fmt.Println("执行操作")
    time.Sleep(5 * time.Second)

    // 释放锁
    if ok, err := mutex.Unlock(); !ok || err != nil {
        panic(err)
    }
}
```

---

## 5. 分布式锁最佳实践

### 5.1 锁超时设置

**锁超时设置原则**：

- **业务执行时间**：锁超时时间应该大于业务执行时间
- **网络延迟**：考虑网络延迟
- **续期机制**：使用续期机制避免锁过期

**锁超时设置示例**：

```python
# 根据业务执行时间设置锁超时
def execute_with_lock(lock_key, business_logic):
    # 预估业务执行时间
    estimated_time = 10  # 秒

    # 锁超时时间 = 预估时间 * 2（安全余量）
    lock_timeout = estimated_time * 2

    lock = DistributedLock(redis_client, lock_key, timeout=lock_timeout)

    if lock.acquire():
        try:
            return business_logic()
        finally:
            lock.release()
    else:
        raise Exception("获取锁失败")
```

### 5.2 锁续期机制

**锁续期机制**：

```python
class DistributedLockWithRenewal:
    def __init__(self, redis_client, key, timeout=10):
        self.redis_client = redis_client
        self.key = f"lock:{key}"
        self.timeout = timeout
        self.identifier = str(uuid.uuid4())
        self.renewal_thread = None
        self.stop_renewal = False

    def start_renewal(self):
        """启动续期线程"""
        def renew():
            while not self.stop_renewal:
                # 在过期前1/3时间续期
                time.sleep(self.timeout / 3)

                if self.stop_renewal:
                    break

                lua_script = """
                if redis.call("get", KEYS[1]) == ARGV[1] then
                    return redis.call("expire", KEYS[1], ARGV[2])
                else
                    return 0
                end
                """

                try:
                    result = self.redis_client.eval(
                        lua_script,
                        1,
                        self.key,
                        self.identifier,
                        self.timeout
                    )
                    if not result:
                        break
                except Exception as e:
                    print(f"续期失败: {e}")
                    break

        self.renewal_thread = threading.Thread(target=renew, daemon=True)
        self.renewal_thread.start()
```

### 5.3 锁释放机制

**安全的锁释放机制**：

```python
def release(self):
    """释放锁（Lua脚本保证原子性）"""
    lua_script = """
    if redis.call("get", KEYS[1]) == ARGV[1] then
        return redis.call("del", KEYS[1])
    else
        return 0
    end
    """

    try:
        result = self.redis_client.eval(
            lua_script,
            1,
            self.key,
            self.identifier
        )
        return result == 1
    except Exception as e:
        print(f"释放锁失败: {e}")
        return False
```

---

## 6. 分布式锁应用场景

### 6.1 防止重复提交

**防止重复提交示例**：

```python
def prevent_duplicate_submit(user_id, order_data):
    lock_key = f"submit_lock:{user_id}"
    lock = DistributedLock(redis_client, lock_key, timeout=5)

    if not lock.acquire(blocking=False):
        raise Exception("请勿重复提交")

    try:
        # 检查是否已提交
        if redis_client.exists(f"order:{user_id}"):
            raise Exception("订单已提交")

        # 创建订单
        order_id = create_order(order_data)
        redis_client.setex(f"order:{user_id}", 60, order_id)

        return order_id
    finally:
        lock.release()
```

### 6.2 资源访问控制

**资源访问控制示例**：

```python
def access_resource(resource_id, user_id):
    lock_key = f"resource_lock:{resource_id}"
    lock = DistributedLock(redis_client, lock_key, timeout=30)

    if lock.acquire(timeout=10):
        try:
            # 检查资源状态
            status = get_resource_status(resource_id)
            if status != "available":
                raise Exception("资源不可用")

            # 占用资源
            occupy_resource(resource_id, user_id)

            # 执行操作
            return process_resource(resource_id)
        finally:
            release_resource(resource_id)
            lock.release()
    else:
        raise Exception("获取资源锁失败")
```

### 6.3 分布式任务调度

**分布式任务调度示例**：

```python
def schedule_task(task_id):
    lock_key = f"task_lock:{task_id}"
    lock = DistributedLock(redis_client, lock_key, timeout=300)

    if lock.acquire(blocking=False):
        try:
            # 检查任务状态
            task_status = get_task_status(task_id)
            if task_status == "running":
                return

            # 标记任务为运行中
            set_task_status(task_id, "running")

            # 执行任务
            execute_task(task_id)

            # 标记任务为完成
            set_task_status(task_id, "completed")
        except Exception as e:
            set_task_status(task_id, "failed")
            raise
        finally:
            lock.release()
    else:
        print(f"任务 {task_id} 正在其他节点执行")
```

---

## 7. 扩展阅读

- [Redis分布式锁官方文档](https://redis.io/docs/manual/patterns/distributed-locks/)
- [Redlock算法论文](https://redis.io/topics/distlock)

---

## 8. 权威参考

### 8.1 官方文档

- Redis官方文档：分布式锁
- Redisson官方文档

### 8.2 经典书籍

- 《Redis设计与实现》

### 8.3 在线资源

- 分布式锁最佳实践
- Redlock算法详解
