# 08.04.01 分布式限流实践

## 目录

- [08.04.01 分布式限流实践](#080401-分布式限流实践)
  - [目录](#目录)
  - [1. 概述](#1-概述)
  - [2. 限流算法](#2-限流算法)
    - [2.1 固定窗口算法](#21-固定窗口算法)
    - [2.2 滑动窗口算法](#22-滑动窗口算法)
    - [2.3 令牌桶算法](#23-令牌桶算法)
    - [2.4 漏桶算法](#24-漏桶算法)
  - [3. Redis限流实现](#3-redis限流实现)
    - [3.1 单机限流](#31-单机限流)
    - [3.2 分布式限流](#32-分布式限流)
  - [4. 分布式限流方案](#4-分布式限流方案)
    - [4.1 基于Redis的分布式限流](#41-基于redis的分布式限流)
    - [4.2 多级限流](#42-多级限流)
  - [5. 最佳实践](#5-最佳实践)
    - [5.1 限流策略](#51-限流策略)
    - [5.2 限流响应](#52-限流响应)
    - [5.3 限流监控](#53-限流监控)
  - [6. 扩展阅读](#6-扩展阅读)

---

## 1. 概述

分布式限流是在分布式系统中限制请求速率，保护系统不被过载的机制。

**限流目标**：

- 保护系统资源
- 防止服务雪崩
- 保证服务质量

---

## 2. 限流算法

### 2.1 固定窗口算法

```python
import redis
import time

class FixedWindowLimiter:
    def __init__(self, redis_client, key, limit, window):
        self.redis_client = redis_client
        self.key = key
        self.limit = limit
        self.window = window

    def is_allowed(self):
        """检查是否允许请求"""
        current_window = int(time.time() / self.window)
        window_key = f"{self.key}:{current_window}"

        current = self.redis_client.incr(window_key)
        if current == 1:
            self.redis_client.expire(window_key, self.window)

        return current <= self.limit
```

### 2.2 滑动窗口算法

```python
class SlidingWindowLimiter:
    def __init__(self, redis_client, key, limit, window):
        self.redis_client = redis_client
        self.key = key
        self.limit = limit
        self.window = window

    def is_allowed(self):
        """检查是否允许请求"""
        now = time.time()
        window_start = now - self.window

        # 使用ZSet存储请求时间戳
        pipe = self.redis_client.pipeline()
        pipe.zremrangebyscore(self.key, 0, window_start)
        pipe.zcard(self.key)
        pipe.zadd(self.key, {str(now): now})
        pipe.expire(self.key, self.window)
        results = pipe.execute()

        current_count = results[1] + 1
        return current_count <= self.limit
```

### 2.3 令牌桶算法

```python
class TokenBucketLimiter:
    def __init__(self, redis_client, key, capacity, refill_rate):
        self.redis_client = redis_client
        self.key = key
        self.capacity = capacity
        self.refill_rate = refill_rate

    def is_allowed(self, tokens=1):
        """检查是否允许请求"""
        now = time.time()

        lua_script = """
        local key = KEYS[1]
        local capacity = tonumber(ARGV[1])
        local refill_rate = tonumber(ARGV[2])
        local tokens_requested = tonumber(ARGV[3])
        local now = tonumber(ARGV[4])

        local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
        local current_tokens = tonumber(bucket[1]) or capacity
        local last_refill = tonumber(bucket[2]) or now

        -- 计算需要补充的令牌数
        local elapsed = now - last_refill
        local tokens_to_add = math.floor(elapsed * refill_rate)
        current_tokens = math.min(capacity, current_tokens + tokens_to_add)

        -- 检查是否有足够的令牌
        if current_tokens >= tokens_requested then
            current_tokens = current_tokens - tokens_requested
            redis.call('HMSET', key, 'tokens', current_tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)
            return 1
        else
            redis.call('HMSET', key, 'tokens', current_tokens, 'last_refill', now)
            redis.call('EXPIRE', key, 3600)
            return 0
        end
        """

        result = self.redis_client.eval(
            lua_script,
            1,
            self.key,
            self.capacity,
            self.refill_rate,
            tokens,
            now
        )

        return result == 1
```

### 2.4 漏桶算法

```python
class LeakyBucketLimiter:
    def __init__(self, redis_client, key, capacity, leak_rate):
        self.redis_client = redis_client
        self.key = key
        self.capacity = capacity
        self.leak_rate = leak_rate

    def is_allowed(self):
        """检查是否允许请求"""
        now = time.time()

        lua_script = """
        local key = KEYS[1]
        local capacity = tonumber(ARGV[1])
        local leak_rate = tonumber(ARGV[2])
        local now = tonumber(ARGV[3])

        local bucket = redis.call('HMGET', key, 'water', 'last_leak')
        local water = tonumber(bucket[1]) or 0
        local last_leak = tonumber(bucket[2]) or now

        -- 计算漏出的水量
        local elapsed = now - last_leak
        local leaked = math.floor(elapsed * leak_rate)
        water = math.max(0, water - leaked)

        -- 检查是否可以添加水
        if water < capacity then
            water = water + 1
            redis.call('HMSET', key, 'water', water, 'last_leak', now)
            redis.call('EXPIRE', key, 3600)
            return 1
        else
            redis.call('HMSET', key, 'water', water, 'last_leak', now)
            redis.call('EXPIRE', key, 3600)
            return 0
        end
        """

        result = self.redis_client.eval(
            lua_script,
            1,
            self.key,
            self.capacity,
            self.leak_rate,
            now
        )

        return result == 1
```

---

## 3. Redis限流实现

### 3.1 单机限流

```python
class RedisLimiter:
    def __init__(self, redis_client, key_prefix='limiter'):
        self.redis_client = redis_client
        self.key_prefix = key_prefix

    def limit(self, identifier, limit, window, algorithm='sliding_window'):
        """限流"""
        key = f"{self.key_prefix}:{identifier}"

        if algorithm == 'sliding_window':
            return self._sliding_window(key, limit, window)
        elif algorithm == 'token_bucket':
            return self._token_bucket(key, limit, window)
        else:
            raise ValueError(f"Unknown algorithm: {algorithm}")

    def _sliding_window(self, key, limit, window):
        """滑动窗口限流"""
        now = time.time()
        window_start = now - window

        pipe = self.redis_client.pipeline()
        pipe.zremrangebyscore(key, 0, window_start)
        pipe.zcard(key)
        pipe.zadd(key, {str(now): now})
        pipe.expire(key, window)
        results = pipe.execute()

        current_count = results[1] + 1
        return current_count <= limit
```

### 3.2 分布式限流

```python
class DistributedLimiter:
    def __init__(self, redis_clients, key_prefix='limiter'):
        self.redis_clients = redis_clients
        self.key_prefix = key_prefix
        self.quorum = len(redis_clients) // 2 + 1

    def limit(self, identifier, limit, window):
        """分布式限流"""
        key = f"{self.key_prefix}:{identifier}"
        allowed_count = 0

        for redis_client in self.redis_clients:
            try:
                if self._sliding_window(redis_client, key, limit, window):
                    allowed_count += 1
            except Exception as e:
                print(f"Redis错误: {e}")

        return allowed_count >= self.quorum
```

---

## 4. 分布式限流方案

### 4.1 基于Redis的分布式限流

```python
# 使用Redis Cluster
class RedisClusterLimiter:
    def __init__(self, redis_cluster, key_prefix='limiter'):
        self.redis_cluster = redis_cluster
        self.key_prefix = key_prefix

    def limit(self, identifier, limit, window):
        """限流"""
        key = f"{self.key_prefix}:{identifier}"
        return self._sliding_window(key, limit, window)
```

### 4.2 多级限流

```python
class MultiLevelLimiter:
    def __init__(self, redis_client):
        self.redis_client = redis_client
        self.user_limiter = RedisLimiter(redis_client, 'user')
        self.ip_limiter = RedisLimiter(redis_client, 'ip')
        self.global_limiter = RedisLimiter(redis_client, 'global')

    def limit(self, user_id, ip, limit_config):
        """多级限流"""
        # 用户级限流
        if not self.user_limiter.limit(
            user_id,
            limit_config['user_limit'],
            limit_config['window']
        ):
            return False

        # IP级限流
        if not self.ip_limiter.limit(
            ip,
            limit_config['ip_limit'],
            limit_config['window']
        ):
            return False

        # 全局限流
        if not self.global_limiter.limit(
            'global',
            limit_config['global_limit'],
            limit_config['window']
        ):
            return False

        return True
```

---

## 5. 最佳实践

### 5.1 限流策略

- ✅ 根据业务场景选择限流算法
- ✅ 设置合理的限流阈值
- ✅ 实现多级限流

### 5.2 限流响应

- ✅ 返回429状态码
- ✅ 提供重试时间提示
- ✅ 记录限流日志

### 5.3 限流监控

- ✅ 监控限流触发率
- ✅ 分析限流原因
- ✅ 调整限流策略

---

## 6. 扩展阅读

- [Redis限流最佳实践](https://redis.io/docs/manual/patterns/rate-limiting/)
- [分布式限流算法](https://en.wikipedia.org/wiki/Rate_limiting)
